{"version":3,"file":"ink-full.js","sources":["../src/compiler/CompilerOptions.ts","../src/compiler/Parser/ErrorType.ts","../src/compiler/DebugSourceRange.ts","../src/compiler/Parser/ParsedHierarchy/Argument.ts","../src/engine/TypeAssertion.ts","../src/compiler/Parser/ParsedHierarchy/Object.ts","../src/engine/Debug.ts","../src/compiler/Parser/ParsedHierarchy/AuthorWarning.ts","../src/engine/Path.ts","../src/engine/NullException.ts","../src/engine/Object.ts","../src/engine/StringBuilder.ts","../src/engine/InkList.ts","../src/engine/StoryException.ts","../src/engine/TryGetResult.ts","../src/engine/Value.ts","../src/engine/SearchResult.ts","../src/engine/Container.ts","../src/engine/ControlCommand.ts","../src/compiler/Parser/ParsedHierarchy/Expression/Expression.ts","../src/engine/Void.ts","../src/engine/NativeFunctionCall.ts","../src/compiler/Parser/ParsedHierarchy/Expression/NumberExpression.ts","../src/compiler/Parser/ParsedHierarchy/Expression/UnaryExpression.ts","../src/compiler/Parser/ParsedHierarchy/Expression/BinaryExpression.ts","../src/compiler/Parser/CharacterSet.ts","../src/compiler/Parser/CharacterRange.ts","../src/engine/ChoicePoint.ts","../src/engine/PushPop.ts","../src/engine/Pointer.ts","../src/compiler/Parser/ParsedHierarchy/SymbolType.ts","../src/engine/Divert.ts","../src/engine/VariableAssignment.ts","../src/compiler/Parser/ParsedHierarchy/Choice.ts","../src/compiler/Parser/StringParser/StringParserElement.ts","../src/compiler/Parser/StringParser/StringParserState.ts","../src/compiler/Parser/StringParser/StringParser.ts","../src/compiler/Parser/CommentEliminator.ts","../src/compiler/Parser/ParsedHierarchy/Flow/FlowLevel.ts","../src/compiler/Parser/ParsedHierarchy/Conditional/Conditional.ts","../src/compiler/Parser/ParsedHierarchy/Text.ts","../src/compiler/Parser/ParsedHierarchy/Declaration/ConstantDeclaration.ts","../src/compiler/Parser/ParsedHierarchy/Gather/Gather.ts","../src/compiler/Parser/ParsedHierarchy/Path.ts","../src/compiler/Parser/ParsedHierarchy/ReturnType.ts","../src/compiler/Parser/ParsedHierarchy/Flow/ClosestFlowBase.ts","../src/compiler/Parser/ParsedHierarchy/Identifier.ts","../src/compiler/Parser/ParsedHierarchy/Flow/FlowBase.ts","../src/compiler/Parser/ParsedHierarchy/ContentList.ts","../src/engine/VariableReference.ts","../src/compiler/Parser/ParsedHierarchy/Variable/VariableReference.ts","../src/compiler/Parser/ParsedHierarchy/FunctionCall.ts","../src/compiler/Parser/ParsedHierarchy/Expression/MultipleConditionExpression.ts","../src/compiler/Parser/ParsedHierarchy/Sequence/SequenceType.ts","../src/compiler/Parser/ParsedHierarchy/Divert/DivertTarget.ts","../src/compiler/Parser/ParsedHierarchy/Divert/Divert.ts","../src/compiler/Parser/ParsedHierarchy/Gather/GatherPointToResolve.ts","../src/compiler/Parser/ParsedHierarchy/Sequence/SequenceDivertToResolve.ts","../src/compiler/Parser/ParsedHierarchy/Sequence/Sequence.ts","../src/compiler/Parser/CustomFlags.ts","../src/compiler/Parser/ParsedHierarchy/TunnelOnwards.ts","../src/engine/ListDefinition.ts","../src/compiler/Parser/ParsedHierarchy/List/ListDefinition.ts","../src/compiler/Parser/ParsedHierarchy/Variable/VariableAssignment.ts","../src/compiler/Parser/ParsedHierarchy/Weave.ts","../src/compiler/Parser/ParsedHierarchy/Conditional/ConditionalSingleBranch.ts","../src/engine/DebugMetadata.ts","../src/compiler/Parser/StatementLevel.ts","../src/compiler/Parser/ParsedHierarchy/Declaration/ExternalDeclaration.ts","../src/compiler/Parser/FlowDecl.ts","../src/compiler/Parser/ParsedHierarchy/Glue.ts","../src/compiler/Parser/ParsedHierarchy/Wrap.ts","../src/engine/Glue.ts","../src/compiler/Parser/ParsedHierarchy/Expression/IncDecExpression.ts","../src/compiler/Parser/ParsedHierarchy/IncludedFile.ts","../src/compiler/Parser/InfixOperator.ts","../src/compiler/Parser/ParsedHierarchy/Knot.ts","../src/compiler/Parser/ParsedHierarchy/List/List.ts","../src/compiler/Parser/ParsedHierarchy/List/ListElementDefinition.ts","../src/compiler/Parser/ParsedHierarchy/Stitch.ts","../src/engine/Tag.ts","../src/engine/Choice.ts","../src/engine/ListDefinitionsOrigin.ts","../src/engine/JsonSerialisation.ts","../src/engine/CallStack.ts","../src/engine/VariablesState.ts","../src/engine/PRNG.ts","../src/engine/StatePatch.ts","../src/engine/SimpleJson.ts","../src/engine/Flow.ts","../src/engine/Error.ts","../src/engine/StoryState.ts","../src/engine/StopWatch.ts","../src/engine/Story.ts","../src/compiler/Parser/ParsedHierarchy/Story.ts","../src/compiler/Parser/ParsedHierarchy/Expression/StringExpression.ts","../src/compiler/Parser/ParsedHierarchy/Tag.ts","../src/compiler/FileHandler/DefaultFileHandler.ts","../src/compiler/Parser/InkParser.ts","../src/compiler/FileHandler/JsonFileHandler.ts","../src/compiler/Compiler.ts"],"sourcesContent":["import { ErrorHandler } from \"../engine/Error\";\nimport { IFileHandler } from \"./IFileHandler\";\n\nexport class CompilerOptions {\n  constructor(\n    public readonly sourceFilename: string | null = null,\n    public readonly pluginNames: string[] = [],\n    public readonly countAllVisits: boolean = false,\n    public readonly errorHandler: ErrorHandler | null = null,\n    public readonly fileHandler: IFileHandler | null = null\n  ) {}\n}\n","// TODO: Unifify with Engine.\n\nexport enum ErrorType {\n  Author,\n  Warning,\n  Error,\n}\n","import { DebugMetadata } from \"../engine/DebugMetadata\";\n\nexport class DebugSourceRange {\n  constructor(\n    public readonly length: number,\n    public readonly debugMetadata: DebugMetadata | null,\n    public text: string\n  ) {}\n}\n","import { Identifier } from \"./Identifier\";\n\nexport class Argument {\n  constructor(\n    public identifier: Identifier | null = null,\n    public isByReference: boolean | null = null,\n    public isDivertTarget: boolean | null = null\n  ) {}\n\n  get typeName(): string {\n    return \"Argument\";\n  }\n}\n","import { INamedContent } from \"./INamedContent\";\n\nexport function asOrNull<T>(\n  obj: any,\n  type: (new (...arg: any[]) => T) | (Function & { prototype: T })\n): T | null {\n  if (obj instanceof type) {\n    return unsafeTypeAssertion(obj, type);\n  } else {\n    return null;\n  }\n}\n\nexport function asOrThrows<T>(\n  obj: any,\n  type: (new (...arg: any[]) => T) | (Function & { prototype: T })\n): T | never {\n  if (obj instanceof type) {\n    return unsafeTypeAssertion(obj, type);\n  } else {\n    throw new Error(`${obj} is not of type ${type}`);\n  }\n}\n\nexport function asNumberOrThrows(obj: any) {\n  if (typeof obj === \"number\") {\n    return obj as number;\n  } else {\n    throw new Error(`${obj} is not a number`);\n  }\n}\n\nexport function asBooleanOrThrows(obj: any) {\n  if (typeof obj === \"boolean\") {\n    return obj as boolean;\n  } else {\n    throw new Error(`${obj} is not a boolean`);\n  }\n}\n\n// So here, in the reference implementation, contentObj is casted to an INamedContent\n// but here we use js-style duck typing: if it implements the same props as the interface,\n// we treat it as valid.\nexport function asINamedContentOrNull(obj: any): INamedContent | null {\n  if (obj.hasValidName && obj.name) {\n    return obj as INamedContent;\n  }\n\n  return null;\n}\n\nexport function nullIfUndefined<T>(obj: T | undefined): T | null {\n  if (typeof obj === \"undefined\") {\n    return null;\n  }\n\n  return obj;\n}\n\nexport function isEquatable(type: any) {\n  return typeof type === \"object\" && typeof type.Equals === \"function\";\n}\n\nfunction unsafeTypeAssertion<T>(\n  obj: any,\n  type: (new () => T) | (Function & { prototype: T })\n) {\n  return obj as T;\n}\n\nexport function filterUndef<T>(element: T | undefined): element is T {\n  return element != undefined;\n}\n","import { Container as RuntimeContainer } from \"../../../engine/Container\";\nimport { DebugMetadata } from \"../../../engine/DebugMetadata\";\nimport { FindQueryFunc } from \"./FindQueryFunc\";\nimport { InkObject as RuntimeObject } from \"../../../engine/Object\";\nimport { Path as RuntimePath } from \"../../../engine/Path\";\nimport { Story } from \"./Story\";\nimport { asOrNull } from \"../../../engine/TypeAssertion\";\n\nexport abstract class ParsedObject {\n  public abstract readonly GenerateRuntimeObject: () => RuntimeObject | null;\n\n  private _alreadyHadError: boolean = false;\n  private _alreadyHadWarning: boolean = false;\n  private _debugMetadata: DebugMetadata | null = null;\n  private _runtimeObject: RuntimeObject | null = null;\n\n  public content: ParsedObject[] = [];\n  public parent: ParsedObject | null = null;\n\n  get debugMetadata() {\n    if (this._debugMetadata === null && this.parent) {\n      return this.parent.debugMetadata;\n    }\n\n    return this._debugMetadata;\n  }\n\n  set debugMetadata(value: DebugMetadata | null) {\n    this._debugMetadata = value;\n  }\n\n  get hasOwnDebugMetadata(): boolean {\n    return Boolean(this.debugMetadata);\n  }\n\n  get typeName(): string {\n    return \"ParsedObject\";\n  }\n\n  public readonly GetType = (): string => this.typeName;\n\n  get story(): Story {\n    let ancestor: ParsedObject = this;\n    while (ancestor.parent) {\n      ancestor = ancestor.parent;\n    }\n\n    return ancestor as Story;\n  }\n\n  get runtimeObject(): RuntimeObject {\n    if (!this._runtimeObject) {\n      this._runtimeObject = this.GenerateRuntimeObject();\n      if (this._runtimeObject) {\n        this._runtimeObject.debugMetadata = this.debugMetadata;\n      }\n    }\n\n    return this._runtimeObject as RuntimeObject;\n  }\n\n  set runtimeObject(value: RuntimeObject) {\n    this._runtimeObject = value;\n  }\n\n  get runtimePath(): RuntimePath {\n    if (!this.runtimeObject.path) {\n      throw new Error();\n    }\n\n    return this.runtimeObject.path;\n  }\n\n  // When counting visits and turns since, different object\n  // types may have different containers that needs to be counted.\n  // For most it'll just be the object's main runtime object,\n  // but for e.g. choices, it'll be the target container.\n  get containerForCounting(): RuntimeContainer | null {\n    return this.runtimeObject as RuntimeContainer;\n  }\n\n  get ancestry(): ParsedObject[] {\n    let result = [];\n\n    let ancestor = this.parent;\n    while (ancestor) {\n      result.push(ancestor);\n      ancestor = ancestor.parent;\n    }\n\n    result = result.reverse();\n\n    return result;\n  }\n\n  /*\n  get descriptionOfScope(): string {\n    const locationNames: string[] = [];\n\n    let ancestor: ParsedObject | null = this;\n    while (ancestor) {\n      var ancestorFlow = ancestor as FlowBase;\n      if (ancestorFlow && ancestorFlow.name != null) {\n        locationNames.push(`'${ancestorFlow.name}'`);\n      }\n      ancestor = ancestor.parent;\n    }\n\n    let scopeSB = '';\n    if (locationNames.length > 0) {\n      const locationsListStr = locationNames.join(', ');\n      scopeSB += `${locationsListStr} and`;\n    }\n\n    scopeSB += 'at top scope';\n\n    return scopeSB;\n  }\n*/\n\n  // Return the object so that method can be chained easily\n  public readonly AddContent = <T extends ParsedObject, V extends T | T[]>(\n    subContent: V\n  ) => {\n    if (this.content === null) {\n      this.content = [];\n    }\n\n    const sub = Array.isArray(subContent) ? subContent : [subContent];\n\n    // Make resilient to content not existing, which can happen\n    // in the case of parse errors where we've already reported\n    // an error but still want a valid structure so we can\n    // carry on parsing.\n    for (const ss of sub) {\n      if (ss.hasOwnProperty(\"parent\")) {\n        ss.parent = this;\n      }\n      this.content.push(ss);\n    }\n\n    if (Array.isArray(subContent)) {\n      return;\n    } else {\n      return subContent;\n    }\n  };\n\n  public readonly InsertContent = <T extends ParsedObject>(\n    index: number,\n    subContent: T\n  ): T => {\n    if (this.content === null) {\n      this.content = [];\n    }\n\n    subContent.parent = this;\n    this.content.splice(index, 0, subContent);\n\n    return subContent;\n  };\n\n  public readonly Find =\n    <T extends ParsedObject>(\n      type: (new (...arg: any[]) => T) | (Function & { prototype: T })\n    ) =>\n    (queryFunc: FindQueryFunc<T> | null = null): T | null => {\n      let tObj = asOrNull(this, type) as any as T;\n      if (tObj !== null && (queryFunc === null || queryFunc(tObj) === true)) {\n        return tObj;\n      }\n\n      if (this.content === null) {\n        return null;\n      }\n\n      for (const obj of this.content) {\n        let nestedResult = obj.Find && obj.Find(type)(queryFunc);\n        if (nestedResult) {\n          return nestedResult as T;\n        }\n      }\n\n      return null;\n    };\n\n  public readonly FindAll =\n    <T extends ParsedObject>(\n      type: (new (...arg: any[]) => T) | (Function & { prototype: T })\n    ) =>\n    (queryFunc?: FindQueryFunc<T>, foundSoFar?: T[]): T[] => {\n      const found = Array.isArray(foundSoFar) ? foundSoFar : [];\n\n      const tObj = asOrNull(this, type);\n      if (tObj !== null && (!queryFunc || queryFunc(tObj) === true)) {\n        found.push(tObj);\n      }\n\n      if (this.content === null) {\n        return [];\n      }\n\n      for (const obj of this.content) {\n        obj.FindAll && obj.FindAll(type)(queryFunc, found);\n      }\n\n      return found;\n    };\n\n  public ResolveReferences(context: Story) {\n    if (this.content !== null) {\n      for (const obj of this.content) {\n        obj.ResolveReferences(context);\n      }\n    }\n  }\n\n  public Error(\n    message: string,\n    source: ParsedObject | null = null,\n    isWarning: boolean = false\n  ): void {\n    if (source === null) {\n      source = this;\n    }\n\n    // Only allow a single parsed object to have a single error *directly* associated with it\n    if (\n      (source._alreadyHadError && !isWarning) ||\n      (source._alreadyHadWarning && isWarning)\n    ) {\n      return;\n    }\n\n    if (this.parent) {\n      this.parent.Error(message, source, isWarning);\n    } else {\n      throw new Error(`No parent object to send error to: ${message}`);\n    }\n\n    if (isWarning) {\n      source._alreadyHadWarning = true;\n    } else {\n      source._alreadyHadError = true;\n    }\n  }\n\n  public readonly Warning = (\n    message: string,\n    source: ParsedObject | null = null\n  ): void => {\n    this.Error(message, source, true);\n  };\n}\n","export namespace Debug {\n  export function AssertType<T>(\n    variable: any,\n    type: new () => T,\n    message: string\n  ): void | never {\n    Assert(variable instanceof type, message);\n  }\n\n  export function Assert(condition: boolean, message?: string): void | never {\n    if (!condition) {\n      if (typeof message !== \"undefined\") {\n        console.warn(message);\n      }\n\n      if (console.trace) {\n        console.trace();\n      }\n\n      throw new Error(\"\");\n    }\n  }\n}\n","﻿import { ParsedObject } from \"./Object\";\n\nexport class AuthorWarning extends ParsedObject {\n  constructor(public readonly warningMessage: string) {\n    super();\n  }\n\n  get typeName(): string {\n    return \"AuthorWarning\";\n  }\n\n  public readonly GenerateRuntimeObject = (): null => {\n    this.Warning(this.warningMessage);\n    return null;\n  };\n}\n","export class Path {\n  public static parentId = \"^\";\n\n  public _isRelative: boolean;\n  public _components: Path.Component[];\n  public _componentsString: string | null;\n\n  constructor();\n  constructor(componentsString: string);\n  constructor(head: Path.Component, tail: Path);\n  constructor(head: Path.Component[], relative?: boolean);\n  constructor() {\n    this._components = [];\n    this._componentsString = null;\n    this._isRelative = false;\n\n    if (typeof arguments[0] == \"string\") {\n      let componentsString = arguments[0] as string;\n      this.componentsString = componentsString;\n    } else if (\n      arguments[0] instanceof Path.Component &&\n      arguments[1] instanceof Path\n    ) {\n      let head = arguments[0] as Path.Component;\n      let tail = arguments[1] as Path;\n      this._components.push(head);\n      this._components = this._components.concat(tail._components);\n    } else if (arguments[0] instanceof Array) {\n      let head = arguments[0] as Path.Component[];\n      let relative = !!arguments[1] as boolean;\n      this._components = this._components.concat(head);\n      this._isRelative = relative;\n    }\n  }\n  get isRelative() {\n    return this._isRelative;\n  }\n  get componentCount(): number {\n    return this._components.length;\n  }\n  get head(): Path.Component | null {\n    if (this._components.length > 0) {\n      return this._components[0];\n    } else {\n      return null;\n    }\n  }\n  get tail(): Path {\n    if (this._components.length >= 2) {\n      // careful, the original code uses length-1 here. This is because the second argument of\n      // List.GetRange is a number of elements to extract, wherease Array.slice uses an index\n      let tailComps = this._components.slice(1, this._components.length);\n      return new Path(tailComps);\n    } else {\n      return Path.self;\n    }\n  }\n  get length(): number {\n    return this._components.length;\n  }\n  get lastComponent(): Path.Component | null {\n    let lastComponentIdx = this._components.length - 1;\n    if (lastComponentIdx >= 0) {\n      return this._components[lastComponentIdx];\n    } else {\n      return null;\n    }\n  }\n  get containsNamedComponent(): boolean {\n    for (let i = 0, l = this._components.length; i < l; i++) {\n      if (!this._components[i].isIndex) {\n        return true;\n      }\n    }\n    return false;\n  }\n  static get self(): Path {\n    let path = new Path();\n    path._isRelative = true;\n    return path;\n  }\n\n  public GetComponent(index: number): Path.Component {\n    return this._components[index];\n  }\n  public PathByAppendingPath(pathToAppend: Path): Path {\n    let p = new Path();\n\n    let upwardMoves = 0;\n    for (let i = 0; i < pathToAppend._components.length; ++i) {\n      if (pathToAppend._components[i].isParent) {\n        upwardMoves++;\n      } else {\n        break;\n      }\n    }\n\n    for (let i = 0; i < this._components.length - upwardMoves; ++i) {\n      p._components.push(this._components[i]);\n    }\n\n    for (let i = upwardMoves; i < pathToAppend._components.length; ++i) {\n      p._components.push(pathToAppend._components[i]);\n    }\n\n    return p;\n  }\n  get componentsString(): string {\n    if (this._componentsString == null) {\n      this._componentsString = this._components.join(\".\");\n      if (this.isRelative)\n        this._componentsString = \".\" + this._componentsString;\n    }\n\n    return this._componentsString;\n  }\n  set componentsString(value: string) {\n    this._components.length = 0;\n\n    this._componentsString = value;\n\n    if (this._componentsString == null || this._componentsString == \"\") return;\n\n    if (this._componentsString[0] == \".\") {\n      this._isRelative = true;\n      this._componentsString = this._componentsString.substring(1);\n    }\n\n    let componentStrings = this._componentsString.split(\".\");\n    for (let str of componentStrings) {\n      // we need to distinguish between named components that start with a number, eg \"42somewhere\", and indexed components\n      // the normal parseInt won't do for the detection because it's too relaxed.\n      // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt\n      if (/^(\\-|\\+)?([0-9]+|Infinity)$/.test(str)) {\n        this._components.push(new Path.Component(parseInt(str)));\n      } else {\n        this._components.push(new Path.Component(str));\n      }\n    }\n  }\n  public toString(): string {\n    return this.componentsString;\n  }\n  public Equals(otherPath: Path | null): boolean {\n    if (otherPath == null) return false;\n\n    if (otherPath._components.length != this._components.length) return false;\n\n    if (otherPath.isRelative != this.isRelative) return false;\n\n    // the original code uses SequenceEqual here, so we need to iterate over the components manually.\n    for (let i = 0, l = otherPath._components.length; i < l; i++) {\n      // it's not quite clear whether this test should use Equals or a simple == operator,\n      // see https://github.com/y-lohse/inkjs/issues/22\n      if (!otherPath._components[i].Equals(this._components[i])) return false;\n    }\n\n    return true;\n  }\n  public PathByAppendingComponent(c: Path.Component): Path {\n    let p = new Path();\n    p._components.push(...this._components);\n    p._components.push(c);\n    return p;\n  }\n}\n\nexport namespace Path {\n  export class Component {\n    public readonly index: number;\n    public readonly name: string | null;\n\n    constructor(indexOrName: string | number) {\n      this.index = -1;\n      this.name = null;\n      if (typeof indexOrName == \"string\") {\n        this.name = indexOrName;\n      } else {\n        this.index = indexOrName;\n      }\n    }\n    get isIndex(): boolean {\n      return this.index >= 0;\n    }\n    get isParent(): boolean {\n      return this.name == Path.parentId;\n    }\n\n    public static ToParent(): Component {\n      return new Component(Path.parentId);\n    }\n    public toString(): string | null {\n      if (this.isIndex) {\n        return this.index.toString();\n      } else {\n        return this.name;\n      }\n    }\n    public Equals(otherComp: Component): boolean {\n      if (otherComp != null && otherComp.isIndex == this.isIndex) {\n        if (this.isIndex) {\n          return this.index == otherComp.index;\n        } else {\n          return this.name == otherComp.name;\n        }\n      }\n\n      return false;\n    }\n  }\n}\n","/**\n * In the original C# code, a SystemException would be thrown when passing\n * null to methods expected a valid instance. Javascript has no such\n * concept, but TypeScript will not allow `null` to be passed to methods\n * explicitely requiring a valid type.\n *\n * Whenever TypeScript complain about the possibility of a `null` value,\n * check the offending value and it it's null, throw this exception using\n * `throwNullException(name: string)`.\n */\nexport class NullException extends Error {}\n\n/**\n * Throw a NullException.\n *\n * @param name a short description of the offending value (often its name within the code).\n */\nexport function throwNullException(name: string): never {\n  throw new NullException(`${name} is null or undefined`);\n}\n","import { Path } from \"./Path\";\nimport { Container } from \"./Container\";\nimport { Debug } from \"./Debug\";\nimport { asOrNull, asINamedContentOrNull } from \"./TypeAssertion\";\nimport { throwNullException } from \"./NullException\";\nimport { SearchResult } from \"./SearchResult\";\nimport { DebugMetadata } from \"./DebugMetadata\";\n\nexport class InkObject {\n  public parent: InkObject | null = null;\n\n  get debugMetadata(): DebugMetadata | null {\n    if (this._debugMetadata === null) {\n      if (this.parent) {\n        return this.parent.debugMetadata;\n      }\n    }\n\n    return this._debugMetadata;\n  }\n\n  set debugMetadata(value) {\n    this._debugMetadata = value;\n  }\n\n  get ownDebugMetadata() {\n    return this._debugMetadata;\n  }\n\n  private _debugMetadata: DebugMetadata | null = null;\n\n  public DebugLineNumberOfPath(path: Path) {\n    if (path === null) return null;\n\n    // Try to get a line number from debug metadata\n    let root = this.rootContentContainer;\n    if (root) {\n      let targetContent = root.ContentAtPath(path).obj;\n      if (targetContent) {\n        let dm = targetContent.debugMetadata;\n        if (dm !== null) {\n          return dm.startLineNumber;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  get path() {\n    if (this._path == null) {\n      if (this.parent == null) {\n        this._path = new Path();\n      } else {\n        let comps: Path.Component[] = [];\n\n        let child: InkObject = this;\n        let container = asOrNull(child.parent, Container);\n\n        while (container !== null) {\n          let namedChild = asINamedContentOrNull(child);\n          if (namedChild != null && namedChild.hasValidName) {\n            if (namedChild.name === null)\n              return throwNullException(\"namedChild.name\");\n            comps.unshift(new Path.Component(namedChild.name!));\n          } else {\n            comps.unshift(new Path.Component(container.content.indexOf(child)));\n          }\n\n          child = container;\n          container = asOrNull(container.parent, Container);\n        }\n\n        this._path = new Path(comps);\n      }\n    }\n\n    return this._path;\n  }\n  private _path: Path | null = null;\n\n  public ResolvePath(path: Path | null): SearchResult {\n    if (path === null) return throwNullException(\"path\");\n    if (path.isRelative) {\n      let nearestContainer = asOrNull(this, Container);\n\n      if (nearestContainer === null) {\n        Debug.Assert(\n          this.parent !== null,\n          \"Can't resolve relative path because we don't have a parent\"\n        );\n        nearestContainer = asOrNull(this.parent, Container);\n        Debug.Assert(\n          nearestContainer !== null,\n          \"Expected parent to be a container\"\n        );\n        Debug.Assert(path.GetComponent(0).isParent);\n        path = path.tail;\n      }\n\n      if (nearestContainer === null) {\n        return throwNullException(\"nearestContainer\");\n      }\n      return nearestContainer.ContentAtPath(path);\n    } else {\n      let contentContainer = this.rootContentContainer;\n      if (contentContainer === null) {\n        return throwNullException(\"contentContainer\");\n      }\n      return contentContainer.ContentAtPath(path);\n    }\n  }\n\n  public ConvertPathToRelative(globalPath: Path) {\n    let ownPath = this.path;\n\n    let minPathLength = Math.min(globalPath.length, ownPath.length);\n    let lastSharedPathCompIndex = -1;\n\n    for (let i = 0; i < minPathLength; ++i) {\n      let ownComp = ownPath.GetComponent(i);\n      let otherComp = globalPath.GetComponent(i);\n\n      if (ownComp.Equals(otherComp)) {\n        lastSharedPathCompIndex = i;\n      } else {\n        break;\n      }\n    }\n\n    // No shared path components, so just use global path\n    if (lastSharedPathCompIndex == -1) return globalPath;\n\n    let numUpwardsMoves = ownPath.componentCount - 1 - lastSharedPathCompIndex;\n\n    let newPathComps: Path.Component[] = [];\n\n    for (let up = 0; up < numUpwardsMoves; ++up)\n      newPathComps.push(Path.Component.ToParent());\n\n    for (\n      let down = lastSharedPathCompIndex + 1;\n      down < globalPath.componentCount;\n      ++down\n    )\n      newPathComps.push(globalPath.GetComponent(down));\n\n    let relativePath = new Path(newPathComps, true);\n    return relativePath;\n  }\n\n  public CompactPathString(otherPath: Path) {\n    let globalPathStr = null;\n    let relativePathStr = null;\n\n    if (otherPath.isRelative) {\n      relativePathStr = otherPath.componentsString;\n      globalPathStr = this.path.PathByAppendingPath(otherPath).componentsString;\n    } else {\n      let relativePath = this.ConvertPathToRelative(otherPath);\n      relativePathStr = relativePath.componentsString;\n      globalPathStr = otherPath.componentsString;\n    }\n\n    if (relativePathStr.length < globalPathStr.length) return relativePathStr;\n    else return globalPathStr;\n  }\n\n  get rootContentContainer() {\n    let ancestor: InkObject = this;\n    while (ancestor.parent) {\n      ancestor = ancestor.parent;\n    }\n    return asOrNull(ancestor, Container);\n  }\n\n  public Copy(): InkObject {\n    throw Error(\"Not Implemented: Doesn't support copying\");\n  }\n  // SetChild works slightly diferently in the js implementation.\n  // Since we can't pass an objets property by reference, we instead pass\n  // the object and the property string.\n  // TODO: This method can probably be rewritten with type-safety in mind.\n  public SetChild(obj: any, prop: any, value: any) {\n    if (obj[prop]) obj[prop] = null;\n\n    obj[prop] = value;\n\n    if (obj[prop]) obj[prop].parent = this;\n  }\n\n  public Equals(obj: any) {\n    return obj === this;\n  }\n}\n","export class StringBuilder {\n  private string: string;\n\n  constructor(str?: string) {\n    str = typeof str !== \"undefined\" ? str.toString() : \"\";\n    this.string = str;\n  }\n  get Length(): number {\n    return this.string.length;\n  }\n  public Append(str: string | null) {\n    if (str !== null) {\n      this.string += str;\n    }\n  }\n  public AppendLine(str?: string) {\n    if (typeof str !== \"undefined\") this.Append(str);\n    this.string += \"\\n\";\n  }\n  public AppendFormat(format: string, ...args: any[]) {\n    // taken from http://stackoverflow.com/questions/610406/javascript-equivalent-to-printf-string-format\n    this.string += format.replace(/{(\\d+)}/g, (match: string, num: number) =>\n      typeof args[num] != \"undefined\" ? args[num] : match\n    );\n  }\n  public toString(): string {\n    return this.string;\n  }\n\n  public Clear() {\n    this.string = \"\";\n  }\n}\n","import { throwNullException } from \"./NullException\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { Story } from \"./Story\";\n\nexport class InkListItem implements IInkListItem {\n  // InkListItem is a struct\n\n  public readonly originName: string | null = null;\n  public readonly itemName: string | null = null;\n\n  constructor(originName: string | null, itemName: string | null);\n  constructor(fullName: string | null);\n  constructor() {\n    if (typeof arguments[1] !== \"undefined\") {\n      let originName = arguments[0] as string | null;\n      let itemName = arguments[1] as string | null;\n\n      this.originName = originName;\n      this.itemName = itemName;\n    } else if (arguments[0]) {\n      let fullName = arguments[0] as string;\n\n      let nameParts = fullName.toString().split(\".\");\n      this.originName = nameParts[0];\n      this.itemName = nameParts[1];\n    }\n  }\n  public static get Null() {\n    return new InkListItem(null, null);\n  }\n  public get isNull() {\n    return this.originName == null && this.itemName == null;\n  }\n  get fullName() {\n    return (\n      (this.originName !== null ? this.originName : \"?\") + \".\" + this.itemName\n    );\n  }\n  public toString(): string {\n    return this.fullName;\n  }\n  public Equals(obj: InkListItem) {\n    if (obj instanceof InkListItem) {\n      let otherItem = obj;\n      return (\n        otherItem.itemName == this.itemName &&\n        otherItem.originName == this.originName\n      );\n    }\n\n    return false;\n  }\n\n  // These methods did not exist in the original C# code. Their purpose is to\n  // make `InkListItem` mimics the value-type semantics of the original\n  // struct. Please refer to the end of this file, for a more in-depth\n  // explanation.\n\n  /**\n   * Returns a shallow clone of the current instance.\n   */\n  public copy() {\n    return new InkListItem(this.originName, this.itemName);\n  }\n  /**\n   * Returns a `SerializedInkListItem` representing the current\n   * instance. The result is intended to be used as a key inside a Map.\n   */\n  public serialized(): SerializedInkListItem {\n    // We are simply using a JSON representation as a value-typed key.\n    return JSON.stringify({\n      originName: this.originName,\n      itemName: this.itemName,\n    });\n  }\n\n  /**\n   * Reconstructs a `InkListItem` from the given SerializedInkListItem.\n   */\n  public static fromSerializedKey(key: SerializedInkListItem): InkListItem {\n    let obj = JSON.parse(key);\n    if (!InkListItem.isLikeInkListItem(obj)) return InkListItem.Null;\n\n    let inkListItem = obj as IInkListItem;\n\n    return new InkListItem(inkListItem.originName, inkListItem.itemName);\n  }\n\n  /**\n   * Determines whether the given item is sufficiently `InkListItem`-like\n   * to be used as a template when reconstructing the InkListItem.\n   */\n  private static isLikeInkListItem(item: any) {\n    if (typeof item !== \"object\") return false;\n    if (!item.hasOwnProperty(\"originName\") || !item.hasOwnProperty(\"itemName\"))\n      return false;\n    if (typeof item.originName !== \"string\" && typeof item.originName !== null)\n      return false;\n    if (typeof item.itemName !== \"string\" && typeof item.itemName !== null)\n      return false;\n\n    return true;\n  }\n}\n\nexport class InkList extends Map<SerializedInkListItem, number> {\n  public origins: ListDefinition[] | null = null;\n  public _originNames: string[] | null = [];\n\n  constructor();\n  constructor(otherList: InkList);\n  constructor(singleOriginListName: string, originStory: Story);\n  constructor(singleElement: KeyValuePair<InkListItem, number>);\n  constructor() {\n    // Trying to be smart here, this emulates the constructor inheritance found\n    // in the original code, but only if otherList is an InkList. IIFE FTW.\n    super(\n      (() => {\n        if (arguments[0] instanceof InkList) {\n          return arguments[0];\n        } else {\n          return [];\n        }\n      })()\n    );\n\n    if (arguments[0] instanceof InkList) {\n      let otherList = arguments[0] as InkList;\n\n      let otherOriginNames = otherList.originNames as string[];\n      if (otherOriginNames !== null)\n        this._originNames = otherOriginNames.slice();\n      if (otherList.origins !== null) {\n        this.origins = otherList.origins.slice();\n      }\n    } else if (typeof arguments[0] === \"string\") {\n      let singleOriginListName = arguments[0] as string;\n      let originStory = arguments[1] as Story;\n      this.SetInitialOriginName(singleOriginListName);\n\n      if (originStory.listDefinitions === null) {\n        return throwNullException(\"originStory.listDefinitions\");\n      }\n      let def = originStory.listDefinitions.TryListGetDefinition(\n        singleOriginListName,\n        null\n      );\n      if (def.exists) {\n        // Throwing now, because if the value is `null` it will\n        // eventually throw down the line.\n        if (def.result === null) {\n          return throwNullException(\"def.result\");\n        }\n        this.origins = [def.result];\n      } else {\n        throw new Error(\n          \"InkList origin could not be found in story when constructing new list: \" +\n            singleOriginListName\n        );\n      }\n    } else if (\n      typeof arguments[0] === \"object\" &&\n      arguments[0].hasOwnProperty(\"Key\") &&\n      arguments[0].hasOwnProperty(\"Value\")\n    ) {\n      let singleElement = arguments[0] as KeyValuePair<InkListItem, number>;\n      this.Add(singleElement.Key, singleElement.Value);\n    }\n  }\n\n  public static FromString(myListItem: string, originStory: Story) {\n    let listValue =\n      originStory.listDefinitions?.FindSingleItemListWithName(myListItem);\n    if (listValue) {\n      if (listValue.value === null) {\n        return throwNullException(\"listValue.value\");\n      }\n      return new InkList(listValue.value);\n    } else {\n      throw new Error(\n        \"Could not find the InkListItem from the string '\" +\n          myListItem +\n          \"' to create an InkList because it doesn't exist in the original list definition in ink.\"\n      );\n    }\n  }\n\n  public AddItem(itemOrItemName: InkListItem | string | null) {\n    if (itemOrItemName instanceof InkListItem) {\n      let item = itemOrItemName;\n\n      if (item.originName == null) {\n        this.AddItem(item.itemName);\n        return;\n      }\n\n      if (this.origins === null) return throwNullException(\"this.origins\");\n\n      for (let origin of this.origins) {\n        if (origin.name == item.originName) {\n          let intVal = origin.TryGetValueForItem(item, 0);\n          if (intVal.exists) {\n            this.Add(item, intVal.result);\n            return;\n          } else {\n            throw new Error(\n              \"Could not add the item \" +\n                item +\n                \" to this list because it doesn't exist in the original list definition in ink.\"\n            );\n          }\n        }\n      }\n\n      throw new Error(\n        \"Failed to add item to list because the item was from a new list definition that wasn't previously known to this list. Only items from previously known lists can be used, so that the int value can be found.\"\n      );\n    } else {\n      let itemName = itemOrItemName as string | null;\n\n      let foundListDef: ListDefinition | null = null;\n\n      if (this.origins === null) return throwNullException(\"this.origins\");\n\n      for (let origin of this.origins) {\n        if (itemName === null) return throwNullException(\"itemName\");\n\n        if (origin.ContainsItemWithName(itemName)) {\n          if (foundListDef != null) {\n            throw new Error(\n              \"Could not add the item \" +\n                itemName +\n                \" to this list because it could come from either \" +\n                origin.name +\n                \" or \" +\n                foundListDef.name\n            );\n          } else {\n            foundListDef = origin;\n          }\n        }\n      }\n\n      if (foundListDef == null)\n        throw new Error(\n          \"Could not add the item \" +\n            itemName +\n            \" to this list because it isn't known to any list definitions previously associated with this list.\"\n        );\n\n      let item = new InkListItem(foundListDef.name, itemName);\n      let itemVal = foundListDef.ValueForItem(item);\n      this.Add(item, itemVal);\n    }\n  }\n  public ContainsItemNamed(itemName: string | null) {\n    for (let [key] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      if (item.itemName == itemName) return true;\n    }\n\n    return false;\n  }\n  public ContainsKey(key: InkListItem) {\n    return this.has(key.serialized());\n  }\n  public Add(key: InkListItem, value: number) {\n    let serializedKey = key.serialized();\n    if (this.has(serializedKey)) {\n      // Throw an exception to match the C# behavior.\n      throw new Error(`The Map already contains an entry for ${key}`);\n    }\n    this.set(serializedKey, value);\n  }\n  public Remove(key: InkListItem) {\n    return this.delete(key.serialized());\n  }\n  get Count() {\n    return this.size;\n  }\n  get originOfMaxItem(): ListDefinition | null {\n    if (this.origins == null) return null;\n\n    let maxOriginName = this.maxItem.Key.originName;\n    let result = null;\n    this.origins.every((origin) => {\n      if (origin.name == maxOriginName) {\n        result = origin;\n        return false;\n      } else return true;\n    });\n\n    return result;\n  }\n  get originNames(): string[] {\n    if (this.Count > 0) {\n      if (this._originNames == null && this.Count > 0) this._originNames = [];\n      else {\n        if (!this._originNames) this._originNames = [];\n        this._originNames.length = 0;\n      }\n\n      for (let [key] of this) {\n        let item = InkListItem.fromSerializedKey(key);\n        if (item.originName === null)\n          return throwNullException(\"item.originName\");\n        this._originNames.push(item.originName);\n      }\n    }\n\n    return this._originNames as string[];\n  }\n  public SetInitialOriginName(initialOriginName: string) {\n    this._originNames = [initialOriginName];\n  }\n  public SetInitialOriginNames(initialOriginNames: string[]) {\n    if (initialOriginNames == null) this._originNames = null;\n    else this._originNames = initialOriginNames.slice(); // store a copy\n  }\n  get maxItem() {\n    let max: KeyValuePair<InkListItem, number> = {\n      Key: InkListItem.Null,\n      Value: 0,\n    };\n    for (let [key, value] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      if (max.Key.isNull || value > max.Value)\n        max = { Key: item, Value: value };\n    }\n\n    return max;\n  }\n  get minItem() {\n    let min: KeyValuePair<InkListItem, number> = {\n      Key: InkListItem.Null,\n      Value: 0,\n    };\n    for (let [key, value] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      if (min.Key.isNull || value < min.Value) {\n        min = { Key: item, Value: value };\n      }\n    }\n    return min;\n  }\n  get inverse() {\n    let list = new InkList();\n    if (this.origins != null) {\n      for (let origin of this.origins) {\n        for (let [key, value] of origin.items) {\n          let item = InkListItem.fromSerializedKey(key);\n          if (!this.ContainsKey(item)) list.Add(item, value);\n        }\n      }\n    }\n    return list;\n  }\n  get all() {\n    let list = new InkList();\n    if (this.origins != null) {\n      for (let origin of this.origins) {\n        for (let [key, value] of origin.items) {\n          let item = InkListItem.fromSerializedKey(key);\n          list.set(item.serialized(), value);\n        }\n      }\n    }\n    return list;\n  }\n  public Union(otherList: InkList) {\n    let union = new InkList(this);\n    for (let [key, value] of otherList) {\n      union.set(key, value);\n    }\n    return union;\n  }\n  public Intersect(otherList: InkList) {\n    let intersection = new InkList();\n    for (let [key, value] of this) {\n      if (otherList.has(key)) intersection.set(key, value);\n    }\n\n    return intersection;\n  }\n  public HasIntersection(otherList: InkList): boolean {\n    for (let [key] of this) {\n      if (otherList.has(key)) return true;\n    }\n    return false;\n  }\n  public Without(listToRemove: InkList) {\n    let result = new InkList(this);\n    for (let [key] of listToRemove) {\n      result.delete(key);\n    }\n\n    return result;\n  }\n\n  public Contains(key: string): boolean;\n  public Contains(otherList: InkList): boolean;\n  public Contains(what: string | InkList): boolean {\n    if (typeof what == \"string\") return this.ContainsItemNamed(what);\n    const otherList = what;\n    if (otherList.size == 0 || this.size == 0) return false;\n    for (let [key] of otherList) {\n      if (!this.has(key)) return false;\n    }\n\n    return true;\n  }\n  public GreaterThan(otherList: InkList) {\n    if (this.Count == 0) return false;\n    if (otherList.Count == 0) return true;\n\n    return this.minItem.Value > otherList.maxItem.Value;\n  }\n  public GreaterThanOrEquals(otherList: InkList) {\n    if (this.Count == 0) return false;\n    if (otherList.Count == 0) return true;\n\n    return (\n      this.minItem.Value >= otherList.minItem.Value &&\n      this.maxItem.Value >= otherList.maxItem.Value\n    );\n  }\n  public LessThan(otherList: InkList) {\n    if (otherList.Count == 0) return false;\n    if (this.Count == 0) return true;\n\n    return this.maxItem.Value < otherList.minItem.Value;\n  }\n  public LessThanOrEquals(otherList: InkList) {\n    if (otherList.Count == 0) return false;\n    if (this.Count == 0) return true;\n\n    return (\n      this.maxItem.Value <= otherList.maxItem.Value &&\n      this.minItem.Value <= otherList.minItem.Value\n    );\n  }\n  public MaxAsList() {\n    if (this.Count > 0) return new InkList(this.maxItem);\n    else return new InkList();\n  }\n  public MinAsList() {\n    if (this.Count > 0) return new InkList(this.minItem);\n    else return new InkList();\n  }\n  public ListWithSubRange(minBound: any, maxBound: any) {\n    if (this.Count == 0) return new InkList();\n\n    let ordered = this.orderedItems;\n\n    let minValue = 0;\n    let maxValue = Number.MAX_SAFE_INTEGER;\n\n    if (Number.isInteger(minBound)) {\n      minValue = minBound;\n    } else {\n      if (minBound instanceof InkList && minBound.Count > 0)\n        minValue = minBound.minItem.Value;\n    }\n\n    if (Number.isInteger(maxBound)) {\n      maxValue = maxBound;\n    } else {\n      if (maxBound instanceof InkList && maxBound.Count > 0)\n        maxValue = maxBound.maxItem.Value;\n    }\n\n    let subList = new InkList();\n    subList.SetInitialOriginNames(this.originNames);\n    for (let item of ordered) {\n      if (item.Value >= minValue && item.Value <= maxValue) {\n        subList.Add(item.Key, item.Value);\n      }\n    }\n\n    return subList;\n  }\n  public Equals(otherInkList: InkList) {\n    if (otherInkList instanceof InkList === false) return false;\n    if (otherInkList.Count != this.Count) return false;\n\n    for (let [key] of this) {\n      if (!otherInkList.has(key)) return false;\n    }\n\n    return true;\n  }\n  // GetHashCode not implemented\n  get orderedItems() {\n    // List<KeyValuePair<InkListItem, int>>\n    let ordered = new Array<KeyValuePair<InkListItem, number>>();\n\n    for (let [key, value] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      ordered.push({ Key: item, Value: value });\n    }\n\n    ordered.sort((x, y) => {\n      if (x.Key.originName === null) {\n        return throwNullException(\"x.Key.originName\");\n      }\n      if (y.Key.originName === null) {\n        return throwNullException(\"y.Key.originName\");\n      }\n\n      if (x.Value == y.Value) {\n        return x.Key.originName.localeCompare(y.Key.originName);\n      } else {\n        // TODO: refactor this bit into a numberCompareTo method?\n        if (x.Value < y.Value) return -1;\n        return x.Value > y.Value ? 1 : 0;\n      }\n    });\n\n    return ordered;\n  }\n  public toString() {\n    let ordered = this.orderedItems;\n\n    let sb = new StringBuilder();\n    for (let i = 0; i < ordered.length; i++) {\n      if (i > 0) sb.Append(\", \");\n\n      let item = ordered[i].Key;\n      if (item.itemName === null) return throwNullException(\"item.itemName\");\n      sb.Append(item.itemName);\n    }\n\n    return sb.toString();\n  }\n  // casting a InkList to a Number, for somereason, actually gives a number.\n  // This messes up the type detection when creating a Value from a InkList.\n  // Returning NaN here prevents that.\n  public valueOf() {\n    return NaN;\n  }\n}\n\n/**\n * In the original C# code, `InkListItem` was defined as value type, meaning\n * that two `InkListItem` would be considered equal as long as they held the\n * same values. This doesn't hold true in Javascript, as `InkListItem` is a\n * reference type (Javascript doesn't allow the creation of custom value types).\n *\n * The key equality of Map objects is based on the \"SameValueZero\" algorithm;\n * since `InkListItem` is a value type, two keys will only be considered\n * equal if they are, in fact, the same object. As we are trying to emulate\n * the original behavior as close as possible, this will lead to unforeseen\n * side effects.\n *\n * In order to have a key equality based on value semantics, we'll convert\n * `InkListItem` to a valid string representation and use this representation\n * as a key (strings are value types in Javascript). Rather than using the\n * type `string` directly, we'll alias it to `SerializedInkListItem` and use\n * this type as the key for our Map-based `InkList`.\n *\n * Reducing `InkListItem` to a JSON representation would not be bulletproof\n * in the general case, but for our needs it works well. The major downside of\n * this method is that we will have to to reconstruct the original `InkListItem`\n * every time we'll need to access its properties.\n */\nexport type SerializedInkListItem = string;\n\n/**\n * An interface inherited by `InkListItem`, defining exposed\n * properties. It's mainly used when deserializing a `InkListItem` from its\n * key (`SerializedInkListItem`)\n */\ninterface IInkListItem {\n  readonly originName: string | null;\n  readonly itemName: string | null;\n}\nexport interface KeyValuePair<K, V> {\n  Key: K;\n  Value: V;\n}\n","export class StoryException extends Error {\n  public useEndLineNumber: boolean;\n  public message: string;\n  public name: string;\n\n  constructor(message: string) {\n    super(message);\n    this.useEndLineNumber = false;\n    this.message = message;\n    this.name = \"StoryException\";\n  }\n}\n","/**\n * This interface normalize the `TryGet` behavior found in the original\n * C# project. Any `TryGet` method will return a object conforming to this\n * interface.\n *\n * The original function returns a boolean and has a second parameter called\n * item that is an `out`. Both are needed and we can't just return the item\n * because it'll always be truthy. Instead, we return an object containing\n * whether the result exists (`exists`) and the result itself (`result`).\n *\n * For instance a `TryGet` prototype would look like this:\n```\nTryGetItemWithValue(val: number, item: InkListItem): TryGetResult<InkListItem>{\n```\n *\n * On the other hand, dealing with the result can be done in the following way:\n```\nvar item = item.TryGetItemWithValue(intVal, InkListItem.Null);\nif (item.exists) {\n\tconsole.log(item.result)\n}\n```\n *\n */\nexport interface TryGetResult<T> {\n  result: T;\n  exists: boolean;\n}\n\nexport function tryGetValueFromMap<K, V>(\n  map: Map<K, V> | null,\n  key: K,\n  /* out */ value: V\n): TryGetResult<V> {\n  if (map === null) {\n    return { result: value, exists: false };\n  }\n\n  let val = map.get(key);\n\n  if (typeof val === \"undefined\") {\n    return { result: value, exists: false };\n  } else {\n    return { result: val, exists: true };\n  }\n}\n\nexport function tryParseInt(\n  value: any,\n  /* out */ defaultValue: number = 0\n): TryGetResult<number> {\n  let val = parseInt(value);\n\n  if (!Number.isNaN(val)) {\n    return { result: val, exists: true };\n  } else {\n    return { result: defaultValue, exists: false };\n  }\n}\n\nexport function tryParseFloat(\n  value: any,\n  /* out */ defaultValue: number = 0\n): TryGetResult<number> {\n  let val = parseFloat(value);\n\n  if (!Number.isNaN(val)) {\n    return { result: val, exists: true };\n  } else {\n    return { result: defaultValue, exists: false };\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Path } from \"./Path\";\nimport { InkList, InkListItem } from \"./InkList\";\nimport { StoryException } from \"./StoryException\";\nimport { asOrNull, asOrThrows } from \"./TypeAssertion\";\nimport { tryParseInt, tryParseFloat } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\n\nexport abstract class AbstractValue extends InkObject {\n  public abstract get valueType(): ValueType;\n  public abstract get isTruthy(): boolean;\n  public abstract get valueObject(): any;\n\n  public abstract Cast(newType: ValueType): Value<any>;\n\n  public static Create(\n    val: any,\n    preferredNumberType?: ValueType\n  ): Value<any> | null {\n    // This code doesn't exist in upstream and is simply here to enforce\n    // the creation of the proper number value.\n    // If `preferredNumberType` is not provided or if value doesn't match\n    // `preferredNumberType`, this conditional does nothing.\n    if (preferredNumberType) {\n      if (\n        preferredNumberType === (ValueType.Int as ValueType) &&\n        Number.isInteger(Number(val))\n      ) {\n        return new IntValue(Number(val));\n      } else if (\n        preferredNumberType === (ValueType.Float as ValueType) &&\n        !isNaN(val)\n      ) {\n        return new FloatValue(Number(val));\n      }\n    }\n\n    if (typeof val === \"boolean\") {\n      return new BoolValue(Boolean(val));\n    }\n\n    // https://github.com/y-lohse/inkjs/issues/425\n    // Changed condition sequence, because Number('') is\n    // parsed to 0, which made setting string to empty\n    // impossible\n    if (typeof val === \"string\") {\n      return new StringValue(String(val));\n    } else if (Number.isInteger(Number(val))) {\n      return new IntValue(Number(val));\n    } else if (!isNaN(val)) {\n      return new FloatValue(Number(val));\n    } else if (val instanceof Path) {\n      return new DivertTargetValue(asOrThrows(val, Path));\n    } else if (val instanceof InkList) {\n      return new ListValue(asOrThrows(val, InkList));\n    }\n\n    return null;\n  }\n  public Copy() {\n    return asOrThrows(AbstractValue.Create(this.valueObject), InkObject);\n  }\n  public BadCastException(targetType: ValueType) {\n    return new StoryException(\n      \"Can't cast \" +\n        this.valueObject +\n        \" from \" +\n        this.valueType +\n        \" to \" +\n        targetType\n    );\n  }\n}\n\nexport abstract class Value<\n  T extends { toString: () => string }\n> extends AbstractValue {\n  public value: T | null;\n\n  constructor(val: T | null) {\n    super();\n    this.value = val;\n  }\n  public get valueObject() {\n    return this.value;\n  }\n  public toString() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value.toString();\n  }\n}\n\nexport class BoolValue extends Value<boolean> {\n  constructor(val: boolean) {\n    super(val || false);\n  }\n  public get isTruthy() {\n    return Boolean(this.value);\n  }\n  public get valueType() {\n    return ValueType.Bool;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Int) {\n      return new IntValue(this.value ? 1 : 0);\n    }\n\n    if (newType == ValueType.Float) {\n      return new FloatValue(this.value ? 1.0 : 0.0);\n    }\n\n    if (newType == ValueType.String) {\n      return new StringValue(this.value ? \"true\" : \"false\");\n    }\n\n    throw this.BadCastException(newType);\n  }\n\n  public toString() {\n    return this.value ? \"true\" : \"false\";\n  }\n}\n\nexport class IntValue extends Value<number> {\n  constructor(val: number) {\n    super(val || 0);\n  }\n  public get isTruthy() {\n    return this.value != 0;\n  }\n  public get valueType() {\n    return ValueType.Int;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Bool) {\n      return new BoolValue(this.value === 0 ? false : true);\n    }\n\n    if (newType == ValueType.Float) {\n      return new FloatValue(this.value);\n    }\n\n    if (newType == ValueType.String) {\n      return new StringValue(\"\" + this.value);\n    }\n\n    throw this.BadCastException(newType);\n  }\n}\n\nexport class FloatValue extends Value<number> {\n  constructor(val: number) {\n    super(val || 0.0);\n  }\n  public get isTruthy() {\n    return this.value != 0.0;\n  }\n  public get valueType() {\n    return ValueType.Float;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Bool) {\n      return new BoolValue(this.value === 0.0 ? false : true);\n    }\n\n    if (newType == ValueType.Int) {\n      return new IntValue(this.value);\n    }\n\n    if (newType == ValueType.String) {\n      return new StringValue(\"\" + this.value);\n    }\n\n    throw this.BadCastException(newType);\n  }\n}\n\nexport class StringValue extends Value<string> {\n  public _isNewline: boolean;\n  public _isInlineWhitespace: boolean;\n\n  constructor(val: string) {\n    super(val || \"\");\n\n    this._isNewline = this.value == \"\\n\";\n    this._isInlineWhitespace = true;\n\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (this.value.length > 0) {\n      this.value.split(\"\").every((c) => {\n        if (c != \" \" && c != \"\\t\") {\n          this._isInlineWhitespace = false;\n          return false;\n        }\n\n        return true;\n      });\n    }\n  }\n  public get valueType() {\n    return ValueType.String;\n  }\n  public get isTruthy() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value.length > 0;\n  }\n  public get isNewline() {\n    return this._isNewline;\n  }\n  public get isInlineWhitespace() {\n    return this._isInlineWhitespace;\n  }\n  public get isNonWhitespace() {\n    return !this.isNewline && !this.isInlineWhitespace;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Int) {\n      let parsedInt = tryParseInt(this.value);\n      if (parsedInt.exists) {\n        return new IntValue(parsedInt.result);\n      } else {\n        throw this.BadCastException(newType);\n      }\n    }\n\n    if (newType == ValueType.Float) {\n      let parsedFloat = tryParseFloat(this.value);\n      if (parsedFloat.exists) {\n        return new FloatValue(parsedFloat.result);\n      } else {\n        throw this.BadCastException(newType);\n      }\n    }\n\n    throw this.BadCastException(newType);\n  }\n}\n\nexport class DivertTargetValue extends Value<Path> {\n  constructor(targetPath: Path | null = null) {\n    super(targetPath);\n  }\n  public get valueType() {\n    return ValueType.DivertTarget;\n  }\n  public get targetPath() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value;\n  }\n  public set targetPath(value: Path) {\n    this.value = value;\n  }\n  public get isTruthy(): never {\n    throw new Error(\"Shouldn't be checking the truthiness of a divert target\");\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (newType == this.valueType) return this;\n\n    throw this.BadCastException(newType);\n  }\n  public toString() {\n    return \"DivertTargetValue(\" + this.targetPath + \")\";\n  }\n}\n\nexport class VariablePointerValue extends Value<string> {\n  public _contextIndex: number;\n\n  constructor(variableName: string, contextIndex: number = -1) {\n    super(variableName);\n\n    this._contextIndex = contextIndex;\n  }\n\n  public get contextIndex() {\n    return this._contextIndex;\n  }\n  public set contextIndex(value: number) {\n    this._contextIndex = value;\n  }\n  public get variableName() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value;\n  }\n  public set variableName(value: string) {\n    this.value = value;\n  }\n  public get valueType() {\n    return ValueType.VariablePointer;\n  }\n\n  public get isTruthy(): never {\n    throw new Error(\n      \"Shouldn't be checking the truthiness of a variable pointer\"\n    );\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (newType == this.valueType) return this;\n\n    throw this.BadCastException(newType);\n  }\n  public toString() {\n    return \"VariablePointerValue(\" + this.variableName + \")\";\n  }\n  public Copy() {\n    return new VariablePointerValue(this.variableName, this.contextIndex);\n  }\n}\n\nexport class ListValue extends Value<InkList> {\n  public get isTruthy() {\n    if (this.value === null) {\n      return throwNullException(\"this.value\");\n    }\n    return this.value.Count > 0;\n  }\n  public get valueType() {\n    return ValueType.List;\n  }\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == ValueType.Int) {\n      let max = this.value.maxItem;\n      if (max.Key.isNull) return new IntValue(0);\n      else return new IntValue(max.Value);\n    } else if (newType == ValueType.Float) {\n      let max = this.value.maxItem;\n      if (max.Key.isNull) return new FloatValue(0.0);\n      else return new FloatValue(max.Value);\n    } else if (newType == ValueType.String) {\n      let max = this.value.maxItem;\n      if (max.Key.isNull) return new StringValue(\"\");\n      else {\n        return new StringValue(max.Key.toString());\n      }\n    }\n\n    if (newType == this.valueType) return this;\n\n    throw this.BadCastException(newType);\n  }\n  constructor();\n  constructor(list: InkList);\n  constructor(listOrSingleItem: InkListItem, singleValue: number);\n  constructor(listOrSingleItem?: InkListItem | InkList, singleValue?: number) {\n    super(null);\n\n    if (!listOrSingleItem && !singleValue) {\n      this.value = new InkList();\n    } else if (listOrSingleItem instanceof InkList) {\n      this.value = new InkList(listOrSingleItem);\n    } else if (\n      listOrSingleItem instanceof InkListItem &&\n      typeof singleValue === \"number\"\n    ) {\n      this.value = new InkList({\n        Key: listOrSingleItem,\n        Value: singleValue,\n      });\n    }\n  }\n  public static RetainListOriginsForAssignment(\n    oldValue: InkObject | null,\n    newValue: InkObject\n  ) {\n    let oldList = asOrNull(oldValue, ListValue);\n    let newList = asOrNull(newValue, ListValue);\n\n    if (newList && newList.value === null)\n      return throwNullException(\"newList.value\");\n    if (oldList && oldList.value === null)\n      return throwNullException(\"oldList.value\");\n\n    // When assigning the empty list, try to retain any initial origin names\n    if (oldList && newList && newList.value!.Count == 0)\n      newList.value!.SetInitialOriginNames(oldList.value!.originNames);\n  }\n}\n\nexport enum ValueType {\n  Bool = -1,\n  Int = 0,\n  Float = 1,\n  List = 2,\n  String = 3,\n  DivertTarget = 4,\n  VariablePointer = 5,\n}\n","import { InkObject } from \"./Object\";\nimport { Container } from \"./Container\";\n\nexport class SearchResult {\n  public obj: InkObject | null = null;\n  public approximate: boolean = false;\n\n  get correctObj() {\n    return this.approximate ? null : this.obj;\n  }\n\n  get container() {\n    return this.obj instanceof Container ? this.obj : null;\n  }\n\n  public copy() {\n    let searchResult = new SearchResult();\n    searchResult.obj = this.obj;\n    searchResult.approximate = this.approximate;\n\n    return searchResult;\n  }\n}\n","import { StringValue } from \"./Value\";\nimport { throwNullException } from \"./NullException\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { INamedContent } from \"./INamedContent\";\nimport { InkObject } from \"./Object\";\nimport { SearchResult } from \"./SearchResult\";\nimport { Path } from \"./Path\";\nimport { Debug } from \"./Debug\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { asINamedContentOrNull, asOrNull, asOrThrows } from \"./TypeAssertion\";\n\nexport class Container extends InkObject implements INamedContent {\n  public name: string | null = null;\n\n  public _content: InkObject[] = [];\n  public namedContent: Map<string, INamedContent> = new Map();\n\n  public visitsShouldBeCounted: boolean = false;\n  public turnIndexShouldBeCounted: boolean = false;\n  public countingAtStartOnly: boolean = false;\n\n  public _pathToFirstLeafContent: Path | null = null;\n\n  get hasValidName() {\n    return this.name != null && this.name.length > 0;\n  }\n  get content() {\n    return this._content;\n  }\n  set content(value: InkObject[]) {\n    this.AddContent(value);\n  }\n  get namedOnlyContent() {\n    let namedOnlyContentDict: Map<string, InkObject> | null = new Map();\n\n    for (let [key, value] of this.namedContent) {\n      let inkObject = asOrThrows(value, InkObject);\n      namedOnlyContentDict.set(key, inkObject);\n    }\n\n    for (let c of this.content) {\n      let named = asINamedContentOrNull(c);\n      if (named != null && named.hasValidName) {\n        namedOnlyContentDict.delete(named.name!);\n      }\n    }\n\n    if (namedOnlyContentDict.size == 0) namedOnlyContentDict = null;\n\n    return namedOnlyContentDict;\n  }\n  set namedOnlyContent(value: Map<string, InkObject> | null) {\n    let existingNamedOnly = this.namedOnlyContent;\n    if (existingNamedOnly != null) {\n      for (let [key] of existingNamedOnly) {\n        this.namedContent.delete(key);\n      }\n    }\n\n    if (value == null) return;\n\n    for (let [, val] of value) {\n      let named = asINamedContentOrNull(val);\n      if (named != null) this.AddToNamedContentOnly(named);\n    }\n  }\n  get countFlags(): number {\n    let flags: Container.CountFlags = 0;\n    if (this.visitsShouldBeCounted) flags |= Container.CountFlags.Visits;\n    if (this.turnIndexShouldBeCounted) flags |= Container.CountFlags.Turns;\n    if (this.countingAtStartOnly) flags |= Container.CountFlags.CountStartOnly;\n\n    if (flags == Container.CountFlags.CountStartOnly) {\n      flags = 0;\n    }\n\n    return flags;\n  }\n  set countFlags(value: number) {\n    let flag: Container.CountFlags = value;\n    if ((flag & Container.CountFlags.Visits) > 0)\n      this.visitsShouldBeCounted = true;\n    if ((flag & Container.CountFlags.Turns) > 0)\n      this.turnIndexShouldBeCounted = true;\n    if ((flag & Container.CountFlags.CountStartOnly) > 0)\n      this.countingAtStartOnly = true;\n  }\n  get pathToFirstLeafContent() {\n    if (this._pathToFirstLeafContent == null)\n      this._pathToFirstLeafContent = this.path.PathByAppendingPath(\n        this.internalPathToFirstLeafContent\n      );\n\n    return this._pathToFirstLeafContent;\n  }\n  get internalPathToFirstLeafContent() {\n    let components: Path.Component[] = [];\n    let container: Container = this;\n    while (container instanceof Container) {\n      if (container.content.length > 0) {\n        components.push(new Path.Component(0));\n        container = container.content[0] as Container;\n      }\n    }\n    return new Path(components);\n  }\n\n  public AddContent(contentObjOrList: InkObject | InkObject[]) {\n    if (contentObjOrList instanceof Array) {\n      let contentList = contentObjOrList as InkObject[];\n\n      for (let c of contentList) {\n        this.AddContent(c);\n      }\n    } else {\n      let contentObj = contentObjOrList as InkObject;\n\n      this._content.push(contentObj);\n\n      if (contentObj.parent) {\n        throw new Error(\"content is already in \" + contentObj.parent);\n      }\n\n      contentObj.parent = this;\n\n      this.TryAddNamedContent(contentObj);\n    }\n  }\n  public TryAddNamedContent(contentObj: InkObject) {\n    let namedContentObj = asINamedContentOrNull(contentObj);\n    if (namedContentObj != null && namedContentObj.hasValidName) {\n      this.AddToNamedContentOnly(namedContentObj);\n    }\n  }\n  public AddToNamedContentOnly(namedContentObj: INamedContent) {\n    Debug.AssertType(\n      namedContentObj,\n      InkObject,\n      \"Can only add Runtime.Objects to a Runtime.Container\"\n    );\n    let runtimeObj = asOrThrows(namedContentObj, InkObject);\n    runtimeObj.parent = this;\n\n    if (namedContentObj.name === null)\n      return throwNullException(\"namedContentObj.name\");\n    this.namedContent.set(namedContentObj.name!, namedContentObj);\n  }\n  public ContentAtPath(\n    path: Path,\n    partialPathStart: number = 0,\n    partialPathLength: number = -1\n  ) {\n    if (partialPathLength == -1) partialPathLength = path.length;\n\n    let result = new SearchResult();\n    result.approximate = false;\n\n    let currentContainer: Container | null = this;\n    let currentObj: InkObject = this;\n\n    for (let i = partialPathStart; i < partialPathLength; ++i) {\n      let comp = path.GetComponent(i);\n      if (currentContainer == null) {\n        result.approximate = true;\n        break;\n      }\n\n      let foundObj: InkObject | null =\n        currentContainer.ContentWithPathComponent(comp);\n\n      if (foundObj == null) {\n        result.approximate = true;\n        break;\n      }\n\n      currentObj = foundObj;\n      currentContainer = asOrNull(foundObj, Container);\n    }\n\n    result.obj = currentObj;\n\n    return result;\n  }\n  public InsertContent(contentObj: InkObject, index: number) {\n    this.content.splice(index, 0, contentObj);\n\n    if (contentObj.parent) {\n      throw new Error(\"content is already in \" + contentObj.parent);\n    }\n\n    contentObj.parent = this;\n\n    this.TryAddNamedContent(contentObj);\n  }\n  public AddContentsOfContainer(otherContainer: Container) {\n    this.content.push(...otherContainer.content);\n\n    for (let obj of otherContainer.content) {\n      obj.parent = this;\n      this.TryAddNamedContent(obj);\n    }\n  }\n  public ContentWithPathComponent(component: Path.Component): InkObject | null {\n    if (component.isIndex) {\n      if (component.index >= 0 && component.index < this.content.length) {\n        return this.content[component.index];\n      } else {\n        return null;\n      }\n    } else if (component.isParent) {\n      return this.parent;\n    } else {\n      if (component.name === null) {\n        return throwNullException(\"component.name\");\n      }\n      let foundContent = tryGetValueFromMap(\n        this.namedContent,\n        component.name,\n        null\n      );\n      if (foundContent.exists) {\n        return asOrThrows(foundContent.result, InkObject);\n      } else {\n        return null;\n      }\n    }\n  }\n  public BuildStringOfHierarchy(): string;\n  public BuildStringOfHierarchy(\n    sb: StringBuilder,\n    indentation: number,\n    pointedObj: InkObject | null\n  ): string;\n  public BuildStringOfHierarchy() {\n    let sb: StringBuilder;\n    if (arguments.length == 0) {\n      sb = new StringBuilder();\n      this.BuildStringOfHierarchy(sb, 0, null);\n      return sb.toString();\n    }\n\n    sb = arguments[0] as StringBuilder;\n    let indentation = arguments[1] as number;\n    let pointedObj = arguments[2] as InkObject | null;\n\n    function appendIndentation() {\n      const spacesPerIndent = 4; // Truly const in the original code\n      for (let i = 0; i < spacesPerIndent * indentation; ++i) {\n        sb.Append(\" \");\n      }\n    }\n\n    appendIndentation();\n    sb.Append(\"[\");\n\n    if (this.hasValidName) {\n      sb.AppendFormat(\" ({0})\", this.name);\n    }\n\n    if (this == pointedObj) {\n      sb.Append(\"  <---\");\n    }\n\n    sb.AppendLine();\n\n    indentation++;\n\n    for (let i = 0; i < this.content.length; ++i) {\n      let obj = this.content[i];\n\n      if (obj instanceof Container) {\n        let container = obj as Container;\n\n        container.BuildStringOfHierarchy(sb, indentation, pointedObj);\n      } else {\n        appendIndentation();\n        if (obj instanceof StringValue) {\n          sb.Append('\"');\n          sb.Append(obj.toString().replace(\"\\n\", \"\\\\n\"));\n          sb.Append('\"');\n        } else {\n          sb.Append(obj.toString());\n        }\n      }\n\n      if (i != this.content.length - 1) {\n        sb.Append(\",\");\n      }\n\n      if (!(obj instanceof Container) && obj == pointedObj) {\n        sb.Append(\"  <---\");\n      }\n\n      sb.AppendLine();\n    }\n\n    let onlyNamed: Map<string, INamedContent> = new Map();\n\n    for (let [key, value] of this.namedContent) {\n      if (this.content.indexOf(asOrThrows(value, InkObject)) >= 0) {\n        continue;\n      } else {\n        onlyNamed.set(key, value);\n      }\n    }\n\n    if (onlyNamed.size > 0) {\n      appendIndentation();\n      sb.AppendLine(\"-- named: --\");\n\n      for (let [, value] of onlyNamed) {\n        Debug.AssertType(\n          value,\n          Container,\n          \"Can only print out named Containers\"\n        );\n        let container = value as Container;\n        container.BuildStringOfHierarchy(sb, indentation, pointedObj);\n        sb.AppendLine();\n      }\n    }\n\n    indentation--;\n\n    appendIndentation();\n    sb.Append(\"]\");\n  }\n}\n\nexport namespace Container {\n  export enum CountFlags {\n    Visits = 1,\n    Turns = 2,\n    CountStartOnly = 4,\n  }\n}\n","import { InkObject } from \"./Object\";\n\nexport class ControlCommand extends InkObject {\n  private _commandType: ControlCommand.CommandType;\n\n  get commandType(): ControlCommand.CommandType {\n    return this._commandType;\n  }\n\n  constructor(\n    commandType: ControlCommand.CommandType = ControlCommand.CommandType.NotSet\n  ) {\n    super();\n    this._commandType = commandType;\n  }\n\n  public Copy() {\n    return new ControlCommand(this.commandType);\n  }\n  public static EvalStart() {\n    return new ControlCommand(ControlCommand.CommandType.EvalStart);\n  }\n  public static EvalOutput() {\n    return new ControlCommand(ControlCommand.CommandType.EvalOutput);\n  }\n  public static EvalEnd() {\n    return new ControlCommand(ControlCommand.CommandType.EvalEnd);\n  }\n  public static Duplicate() {\n    return new ControlCommand(ControlCommand.CommandType.Duplicate);\n  }\n  public static PopEvaluatedValue() {\n    return new ControlCommand(ControlCommand.CommandType.PopEvaluatedValue);\n  }\n  public static PopFunction() {\n    return new ControlCommand(ControlCommand.CommandType.PopFunction);\n  }\n  public static PopTunnel() {\n    return new ControlCommand(ControlCommand.CommandType.PopTunnel);\n  }\n  public static BeginString() {\n    return new ControlCommand(ControlCommand.CommandType.BeginString);\n  }\n  public static EndString() {\n    return new ControlCommand(ControlCommand.CommandType.EndString);\n  }\n  public static NoOp() {\n    return new ControlCommand(ControlCommand.CommandType.NoOp);\n  }\n  public static ChoiceCount() {\n    return new ControlCommand(ControlCommand.CommandType.ChoiceCount);\n  }\n  public static Turns() {\n    return new ControlCommand(ControlCommand.CommandType.Turns);\n  }\n  public static TurnsSince() {\n    return new ControlCommand(ControlCommand.CommandType.TurnsSince);\n  }\n  public static ReadCount() {\n    return new ControlCommand(ControlCommand.CommandType.ReadCount);\n  }\n  public static Random() {\n    return new ControlCommand(ControlCommand.CommandType.Random);\n  }\n  public static SeedRandom() {\n    return new ControlCommand(ControlCommand.CommandType.SeedRandom);\n  }\n  public static VisitIndex() {\n    return new ControlCommand(ControlCommand.CommandType.VisitIndex);\n  }\n  public static SequenceShuffleIndex() {\n    return new ControlCommand(ControlCommand.CommandType.SequenceShuffleIndex);\n  }\n  public static StartThread() {\n    return new ControlCommand(ControlCommand.CommandType.StartThread);\n  }\n  public static Done() {\n    return new ControlCommand(ControlCommand.CommandType.Done);\n  }\n  public static End() {\n    return new ControlCommand(ControlCommand.CommandType.End);\n  }\n  public static ListFromInt() {\n    return new ControlCommand(ControlCommand.CommandType.ListFromInt);\n  }\n  public static ListRange() {\n    return new ControlCommand(ControlCommand.CommandType.ListRange);\n  }\n  public static ListRandom() {\n    return new ControlCommand(ControlCommand.CommandType.ListRandom);\n  }\n  public static BeginTag() {\n    return new ControlCommand(ControlCommand.CommandType.BeginTag);\n  }\n  public static EndTag() {\n    return new ControlCommand(ControlCommand.CommandType.EndTag);\n  }\n  public toString() {\n    return this.commandType.toString();\n  }\n}\n\nexport namespace ControlCommand {\n  export enum CommandType {\n    NotSet = -1,\n    EvalStart, // 0\n    EvalOutput, // 1\n    EvalEnd, // 2\n    Duplicate, // 3\n    PopEvaluatedValue, // 4\n    PopFunction, // 5\n    PopTunnel, // 6\n    BeginString, // 7\n    EndString, // 8\n    NoOp, // 9\n    ChoiceCount, // 10\n    Turns, // 11\n    TurnsSince, // 12\n    ReadCount, // 13\n    Random, // 14\n    SeedRandom, // 15\n    VisitIndex, // 16\n    SequenceShuffleIndex, // 17\n    StartThread, // 18\n    Done, // 19\n    End, // 20\n    ListFromInt, // 21\n    ListRange, // 22\n    ListRandom, // 23\n    BeginTag, // 24\n    EndTag, // 25\n\n    TOTAL_VALUES,\n  }\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../../engine/ControlCommand\";\nimport { ParsedObject } from \"../Object\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\n\nexport abstract class Expression extends ParsedObject {\n  public abstract GenerateIntoContainer: (container: RuntimeContainer) => void;\n\n  private _prototypeRuntimeConstantExpression: RuntimeContainer | null = null;\n  public outputWhenComplete: boolean = false;\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    const container = new RuntimeContainer();\n\n    // Tell Runtime to start evaluating the following content as an expression\n    container.AddContent(RuntimeControlCommand.EvalStart());\n\n    this.GenerateIntoContainer(container);\n\n    // Tell Runtime to output the result of the expression evaluation to the output stream\n    if (this.outputWhenComplete) {\n      container.AddContent(RuntimeControlCommand.EvalOutput());\n    }\n\n    // Tell Runtime to stop evaluating the content as an expression\n    container.AddContent(RuntimeControlCommand.EvalEnd());\n\n    return container;\n  };\n\n  // When generating the value of a constant expression,\n  // we can't just keep generating the same constant expression into\n  // different places where the constant value is referenced, since then\n  // the same runtime objects would be used in multiple places, which\n  // is impossible since each runtime object should have one parent.\n  // Instead, we generate a prototype of the runtime object(s), then\n  // copy them each time they're used.\n  public readonly GenerateConstantIntoContainer = (\n    container: RuntimeContainer\n  ): void => {\n    if (this._prototypeRuntimeConstantExpression === null) {\n      this._prototypeRuntimeConstantExpression = new RuntimeContainer();\n      this.GenerateIntoContainer(this._prototypeRuntimeConstantExpression);\n    }\n\n    for (const runtimeObj of this._prototypeRuntimeConstantExpression.content) {\n      const copy = runtimeObj.Copy();\n      if (copy) {\n        container.AddContent(copy);\n      }\n    }\n  };\n\n  get typeName(): string {\n    return \"Expression\";\n  }\n\n  public Equals(obj: ParsedObject): boolean {\n    return false;\n  }\n\n  public readonly toString = () => \"No string value in JavaScript.\";\n}\n","import { InkObject } from \"./Object\";\n\nexport class Void extends InkObject {}\n","import { Value, ValueType, IntValue, ListValue, BoolValue } from \"./Value\";\nimport { StoryException } from \"./StoryException\";\nimport { Void } from \"./Void\";\nimport { Path } from \"./Path\";\nimport { InkList, InkListItem } from \"./InkList\";\nimport { InkObject } from \"./Object\";\nimport { asOrNull, asOrThrows, asBooleanOrThrows } from \"./TypeAssertion\";\nimport { throwNullException } from \"./NullException\";\n\ntype BinaryOp<T> = (left: T, right: T) => any;\ntype UnaryOp<T> = (val: T) => any;\n\nexport class NativeFunctionCall extends InkObject {\n  public static readonly Add: string = \"+\";\n  public static readonly Subtract: string = \"-\";\n  public static readonly Divide: string = \"/\";\n  public static readonly Multiply: string = \"*\";\n  public static readonly Mod: string = \"%\";\n  public static readonly Negate: string = \"_\";\n  public static readonly Equal: string = \"==\";\n  public static readonly Greater: string = \">\";\n  public static readonly Less: string = \"<\";\n  public static readonly GreaterThanOrEquals: string = \">=\";\n  public static readonly LessThanOrEquals: string = \"<=\";\n  public static readonly NotEquals: string = \"!=\";\n  public static readonly Not: string = \"!\";\n  public static readonly And: string = \"&&\";\n  public static readonly Or: string = \"||\";\n  public static readonly Min: string = \"MIN\";\n  public static readonly Max: string = \"MAX\";\n  public static readonly Pow: string = \"POW\";\n  public static readonly Floor: string = \"FLOOR\";\n  public static readonly Ceiling: string = \"CEILING\";\n  public static readonly Int: string = \"INT\";\n  public static readonly Float: string = \"FLOAT\";\n  public static readonly Has: string = \"?\";\n  public static readonly Hasnt: string = \"!?\";\n  public static readonly Intersect: string = \"^\";\n  public static readonly ListMin: string = \"LIST_MIN\";\n  public static readonly ListMax: string = \"LIST_MAX\";\n  public static readonly All: string = \"LIST_ALL\";\n  public static readonly Count: string = \"LIST_COUNT\";\n  public static readonly ValueOfList: string = \"LIST_VALUE\";\n  public static readonly Invert: string = \"LIST_INVERT\";\n\n  public static CallWithName(functionName: string) {\n    return new NativeFunctionCall(functionName);\n  }\n\n  public static CallExistsWithName(functionName: string) {\n    this.GenerateNativeFunctionsIfNecessary();\n    return this._nativeFunctions!.get(functionName);\n  }\n\n  get name() {\n    if (this._name === null)\n      return throwNullException(\"NativeFunctionCall._name\");\n    return this._name;\n  }\n  set name(value: string) {\n    this._name = value;\n    if (!this._isPrototype) {\n      if (NativeFunctionCall._nativeFunctions === null)\n        throwNullException(\"NativeFunctionCall._nativeFunctions\");\n      else\n        this._prototype =\n          NativeFunctionCall._nativeFunctions.get(this._name) || null;\n    }\n  }\n  public _name: string | null = null;\n\n  get numberOfParameters() {\n    if (this._prototype) {\n      return this._prototype.numberOfParameters;\n    } else {\n      return this._numberOfParameters;\n    }\n  }\n  set numberOfParameters(value: number) {\n    this._numberOfParameters = value;\n  }\n  public _numberOfParameters: number = 0;\n\n  public Call(parameters: InkObject[]): InkObject | null {\n    if (this._prototype) {\n      return this._prototype.Call(parameters);\n    }\n\n    if (this.numberOfParameters != parameters.length) {\n      throw new Error(\"Unexpected number of parameters\");\n    }\n\n    let hasList = false;\n    for (let p of parameters) {\n      if (p instanceof Void)\n        throw new StoryException(\n          'Attempting to perform operation on a void value. Did you forget to \"return\" a value from a function you called here?'\n        );\n      if (p instanceof ListValue) hasList = true;\n    }\n\n    if (parameters.length == 2 && hasList) {\n      return this.CallBinaryListOperation(parameters);\n    }\n\n    let coercedParams = this.CoerceValuesToSingleType(parameters);\n    let coercedType = coercedParams[0].valueType;\n\n    if (coercedType == ValueType.Int) {\n      return this.CallType<number>(coercedParams);\n    } else if (coercedType == ValueType.Float) {\n      return this.CallType<number>(coercedParams);\n    } else if (coercedType == ValueType.String) {\n      return this.CallType<string>(coercedParams);\n    } else if (coercedType == ValueType.DivertTarget) {\n      return this.CallType<Path>(coercedParams);\n    } else if (coercedType == ValueType.List) {\n      return this.CallType<InkList>(coercedParams);\n    }\n\n    return null;\n  }\n\n  public CallType<T extends { toString: () => string }>(\n    parametersOfSingleType: Array<Value<T>>\n  ) {\n    let param1 = asOrThrows(parametersOfSingleType[0], Value);\n    let valType = param1.valueType;\n\n    let val1 = param1 as Value<T>;\n\n    let paramCount = parametersOfSingleType.length;\n\n    if (paramCount == 2 || paramCount == 1) {\n      if (this._operationFuncs === null)\n        return throwNullException(\"NativeFunctionCall._operationFuncs\");\n      let opForTypeObj = this._operationFuncs.get(valType);\n      if (!opForTypeObj) {\n        const key = ValueType[valType];\n        throw new StoryException(\n          \"Cannot perform operation \" + this.name + \" on \" + key\n        );\n      }\n\n      if (paramCount == 2) {\n        let param2 = asOrThrows(parametersOfSingleType[1], Value);\n\n        let val2 = param2 as Value<T>;\n\n        let opForType = opForTypeObj as BinaryOp<T>;\n\n        if (val1.value === null || val2.value === null)\n          return throwNullException(\"NativeFunctionCall.Call BinaryOp values\");\n        let resultVal = opForType(val1.value, val2.value);\n\n        return Value.Create(resultVal);\n      } else {\n        let opForType = opForTypeObj as UnaryOp<T>;\n\n        if (val1.value === null)\n          return throwNullException(\"NativeFunctionCall.Call UnaryOp value\");\n        let resultVal = opForType(val1.value);\n\n        // This code is different from upstream. Since JavaScript treats\n        // integers and floats as the same numbers, it's impossible\n        // to force an number to be either an integer or a float.\n        //\n        // It can be useful to force a specific number type\n        // (especially for divisions), so the result of INT() & FLOAT()\n        // is coerced to the the proper value type.\n        //\n        // Note that we also force all other unary operation to\n        // return the same value type, although this is only\n        // meaningful for numbers. See `Value.Create`.\n        if (this.name === NativeFunctionCall.Int) {\n          return Value.Create(resultVal, ValueType.Int);\n        } else if (this.name === NativeFunctionCall.Float) {\n          return Value.Create(resultVal, ValueType.Float);\n        } else {\n          return Value.Create(resultVal, param1.valueType);\n        }\n      }\n    } else {\n      throw new Error(\n        \"Unexpected number of parameters to NativeFunctionCall: \" +\n          parametersOfSingleType.length\n      );\n    }\n  }\n\n  public CallBinaryListOperation(parameters: InkObject[]) {\n    if (\n      (this.name == \"+\" || this.name == \"-\") &&\n      parameters[0] instanceof ListValue &&\n      parameters[1] instanceof IntValue\n    )\n      return this.CallListIncrementOperation(parameters);\n\n    let v1 = asOrThrows(parameters[0], Value);\n    let v2 = asOrThrows(parameters[1], Value);\n\n    if (\n      (this.name == \"&&\" || this.name == \"||\") &&\n      (v1.valueType != ValueType.List || v2.valueType != ValueType.List)\n    ) {\n      if (this._operationFuncs === null)\n        return throwNullException(\"NativeFunctionCall._operationFuncs\");\n      let op = this._operationFuncs.get(ValueType.Int) as BinaryOp<number>;\n      if (op === null)\n        return throwNullException(\n          \"NativeFunctionCall.CallBinaryListOperation op\"\n        );\n      let result = asBooleanOrThrows(\n        op(v1.isTruthy ? 1 : 0, v2.isTruthy ? 1 : 0)\n      );\n      return new BoolValue(result);\n    }\n\n    if (v1.valueType == ValueType.List && v2.valueType == ValueType.List)\n      return this.CallType<InkList>([v1, v2]);\n\n    throw new StoryException(\n      \"Can not call use \" +\n        this.name +\n        \" operation on \" +\n        ValueType[v1.valueType] +\n        \" and \" +\n        ValueType[v2.valueType]\n    );\n  }\n\n  public CallListIncrementOperation(listIntParams: InkObject[]) {\n    let listVal = asOrThrows(listIntParams[0], ListValue);\n    let intVal = asOrThrows(listIntParams[1], IntValue);\n\n    let resultInkList = new InkList();\n\n    if (listVal.value === null)\n      return throwNullException(\n        \"NativeFunctionCall.CallListIncrementOperation listVal.value\"\n      );\n    for (let [listItemKey, listItemValue] of listVal.value) {\n      let listItem = InkListItem.fromSerializedKey(listItemKey);\n\n      if (this._operationFuncs === null)\n        return throwNullException(\"NativeFunctionCall._operationFuncs\");\n      let intOp = this._operationFuncs.get(ValueType.Int) as BinaryOp<number>;\n\n      if (intVal.value === null)\n        return throwNullException(\n          \"NativeFunctionCall.CallListIncrementOperation intVal.value\"\n        );\n      let targetInt = intOp(listItemValue, intVal.value);\n\n      let itemOrigin = null;\n      if (listVal.value.origins === null)\n        return throwNullException(\n          \"NativeFunctionCall.CallListIncrementOperation listVal.value.origins\"\n        );\n      for (let origin of listVal.value.origins) {\n        if (origin.name == listItem.originName) {\n          itemOrigin = origin;\n          break;\n        }\n      }\n      if (itemOrigin != null) {\n        let incrementedItem = itemOrigin.TryGetItemWithValue(\n          targetInt,\n          InkListItem.Null\n        );\n        if (incrementedItem.exists)\n          resultInkList.Add(incrementedItem.result, targetInt);\n      }\n    }\n\n    return new ListValue(resultInkList);\n  }\n\n  public CoerceValuesToSingleType(parametersIn: InkObject[]) {\n    let valType = ValueType.Int;\n\n    let specialCaseList: null | ListValue = null;\n\n    for (let obj of parametersIn) {\n      let val = asOrThrows(obj, Value);\n      if (val.valueType > valType) {\n        valType = val.valueType;\n      }\n\n      if (val.valueType == ValueType.List) {\n        specialCaseList = asOrNull(val, ListValue);\n      }\n    }\n\n    let parametersOut = [];\n\n    if (ValueType[valType] == ValueType[ValueType.List]) {\n      for (let inkObjectVal of parametersIn) {\n        let val = asOrThrows(inkObjectVal, Value);\n        if (val.valueType == ValueType.List) {\n          parametersOut.push(val);\n        } else if (val.valueType == ValueType.Int) {\n          let intVal = parseInt(val.valueObject);\n\n          specialCaseList = asOrThrows(specialCaseList, ListValue);\n          if (specialCaseList.value === null)\n            return throwNullException(\n              \"NativeFunctionCall.CoerceValuesToSingleType specialCaseList.value\"\n            );\n          let list = specialCaseList.value.originOfMaxItem;\n\n          if (list === null)\n            return throwNullException(\n              \"NativeFunctionCall.CoerceValuesToSingleType list\"\n            );\n          let item = list.TryGetItemWithValue(intVal, InkListItem.Null);\n          if (item.exists) {\n            let castedValue = new ListValue(item.result, intVal);\n            parametersOut.push(castedValue);\n          } else\n            throw new StoryException(\n              \"Could not find List item with the value \" +\n                intVal +\n                \" in \" +\n                list.name\n            );\n        } else {\n          const key = ValueType[val.valueType];\n          throw new StoryException(\n            \"Cannot mix Lists and \" + key + \" values in this operation\"\n          );\n        }\n      }\n    } else {\n      for (let inkObjectVal of parametersIn) {\n        let val = asOrThrows(inkObjectVal, Value);\n        let castedValue = val.Cast(valType);\n        parametersOut.push(castedValue);\n      }\n    }\n\n    return parametersOut;\n  }\n\n  constructor(name: string);\n  constructor(name: string, numberOfParameters: number);\n  constructor();\n  constructor() {\n    super();\n\n    if (arguments.length === 0) {\n      NativeFunctionCall.GenerateNativeFunctionsIfNecessary();\n    } else if (arguments.length === 1) {\n      let name = arguments[0];\n      NativeFunctionCall.GenerateNativeFunctionsIfNecessary();\n      this.name = name;\n    } else if (arguments.length === 2) {\n      let name = arguments[0];\n      let numberOfParameters = arguments[1];\n\n      this._isPrototype = true;\n      this.name = name;\n      this.numberOfParameters = numberOfParameters;\n    }\n  }\n\n  public static Identity<T>(t: T): any {\n    return t;\n  }\n\n  public static GenerateNativeFunctionsIfNecessary() {\n    if (this._nativeFunctions == null) {\n      this._nativeFunctions = new Map();\n\n      // Int operations\n      this.AddIntBinaryOp(this.Add, (x, y) => x + y);\n      this.AddIntBinaryOp(this.Subtract, (x, y) => x - y);\n      this.AddIntBinaryOp(this.Multiply, (x, y) => x * y);\n      this.AddIntBinaryOp(this.Divide, (x, y) => Math.floor(x / y));\n      this.AddIntBinaryOp(this.Mod, (x, y) => x % y);\n      this.AddIntUnaryOp(this.Negate, (x) => -x);\n\n      this.AddIntBinaryOp(this.Equal, (x, y) => x == y);\n      this.AddIntBinaryOp(this.Greater, (x, y) => x > y);\n      this.AddIntBinaryOp(this.Less, (x, y) => x < y);\n      this.AddIntBinaryOp(this.GreaterThanOrEquals, (x, y) => x >= y);\n      this.AddIntBinaryOp(this.LessThanOrEquals, (x, y) => x <= y);\n      this.AddIntBinaryOp(this.NotEquals, (x, y) => x != y);\n      this.AddIntUnaryOp(this.Not, (x) => x == 0);\n\n      this.AddIntBinaryOp(this.And, (x, y) => x != 0 && y != 0);\n      this.AddIntBinaryOp(this.Or, (x, y) => x != 0 || y != 0);\n\n      this.AddIntBinaryOp(this.Max, (x, y) => Math.max(x, y));\n      this.AddIntBinaryOp(this.Min, (x, y) => Math.min(x, y));\n\n      this.AddIntBinaryOp(this.Pow, (x, y) => Math.pow(x, y));\n      this.AddIntUnaryOp(this.Floor, NativeFunctionCall.Identity);\n      this.AddIntUnaryOp(this.Ceiling, NativeFunctionCall.Identity);\n      this.AddIntUnaryOp(this.Int, NativeFunctionCall.Identity);\n      this.AddIntUnaryOp(this.Float, (x) => x);\n\n      // Float operations\n      this.AddFloatBinaryOp(this.Add, (x, y) => x + y);\n      this.AddFloatBinaryOp(this.Subtract, (x, y) => x - y);\n      this.AddFloatBinaryOp(this.Multiply, (x, y) => x * y);\n      this.AddFloatBinaryOp(this.Divide, (x, y) => x / y);\n      this.AddFloatBinaryOp(this.Mod, (x, y) => x % y);\n      this.AddFloatUnaryOp(this.Negate, (x) => -x);\n\n      this.AddFloatBinaryOp(this.Equal, (x, y) => x == y);\n      this.AddFloatBinaryOp(this.Greater, (x, y) => x > y);\n      this.AddFloatBinaryOp(this.Less, (x, y) => x < y);\n      this.AddFloatBinaryOp(this.GreaterThanOrEquals, (x, y) => x >= y);\n      this.AddFloatBinaryOp(this.LessThanOrEquals, (x, y) => x <= y);\n      this.AddFloatBinaryOp(this.NotEquals, (x, y) => x != y);\n      this.AddFloatUnaryOp(this.Not, (x) => x == 0.0);\n\n      this.AddFloatBinaryOp(this.And, (x, y) => x != 0.0 && y != 0.0);\n      this.AddFloatBinaryOp(this.Or, (x, y) => x != 0.0 || y != 0.0);\n\n      this.AddFloatBinaryOp(this.Max, (x, y) => Math.max(x, y));\n      this.AddFloatBinaryOp(this.Min, (x, y) => Math.min(x, y));\n\n      this.AddFloatBinaryOp(this.Pow, (x, y) => Math.pow(x, y));\n      this.AddFloatUnaryOp(this.Floor, (x) => Math.floor(x));\n      this.AddFloatUnaryOp(this.Ceiling, (x) => Math.ceil(x));\n      this.AddFloatUnaryOp(this.Int, (x) => Math.floor(x));\n      this.AddFloatUnaryOp(this.Float, NativeFunctionCall.Identity);\n\n      // String operations\n      this.AddStringBinaryOp(this.Add, (x, y) => x + y); // concat\n      this.AddStringBinaryOp(this.Equal, (x, y) => x === y);\n      this.AddStringBinaryOp(this.NotEquals, (x, y) => !(x === y));\n      this.AddStringBinaryOp(this.Has, (x, y) => x.includes(y));\n      this.AddStringBinaryOp(this.Hasnt, (x, y) => !x.includes(y));\n\n      this.AddListBinaryOp(this.Add, (x, y) => x.Union(y));\n      this.AddListBinaryOp(this.Subtract, (x, y) => x.Without(y));\n      this.AddListBinaryOp(this.Has, (x, y) => x.Contains(y));\n      this.AddListBinaryOp(this.Hasnt, (x, y) => !x.Contains(y));\n      this.AddListBinaryOp(this.Intersect, (x, y) => x.Intersect(y));\n\n      this.AddListBinaryOp(this.Equal, (x, y) => x.Equals(y));\n      this.AddListBinaryOp(this.Greater, (x, y) => x.GreaterThan(y));\n      this.AddListBinaryOp(this.Less, (x, y) => x.LessThan(y));\n      this.AddListBinaryOp(this.GreaterThanOrEquals, (x, y) =>\n        x.GreaterThanOrEquals(y)\n      );\n      this.AddListBinaryOp(this.LessThanOrEquals, (x, y) =>\n        x.LessThanOrEquals(y)\n      );\n      this.AddListBinaryOp(this.NotEquals, (x, y) => !x.Equals(y));\n\n      this.AddListBinaryOp(this.And, (x, y) => x.Count > 0 && y.Count > 0);\n      this.AddListBinaryOp(this.Or, (x, y) => x.Count > 0 || y.Count > 0);\n\n      this.AddListUnaryOp(this.Not, (x) => (x.Count == 0 ? 1 : 0));\n\n      this.AddListUnaryOp(this.Invert, (x) => x.inverse);\n      this.AddListUnaryOp(this.All, (x) => x.all);\n      this.AddListUnaryOp(this.ListMin, (x) => x.MinAsList());\n      this.AddListUnaryOp(this.ListMax, (x) => x.MaxAsList());\n      this.AddListUnaryOp(this.Count, (x) => x.Count);\n      this.AddListUnaryOp(this.ValueOfList, (x) => x.maxItem.Value);\n\n      let divertTargetsEqual = (d1: Path, d2: Path) => d1.Equals(d2);\n      let divertTargetsNotEqual = (d1: Path, d2: Path) => !d1.Equals(d2);\n      this.AddOpToNativeFunc(\n        this.Equal,\n        2,\n        ValueType.DivertTarget,\n        divertTargetsEqual\n      );\n      this.AddOpToNativeFunc(\n        this.NotEquals,\n        2,\n        ValueType.DivertTarget,\n        divertTargetsNotEqual\n      );\n    }\n  }\n\n  public AddOpFuncForType(\n    valType: ValueType,\n    op: UnaryOp<number | InkList> | BinaryOp<number | string | InkList | Path>\n  ): void {\n    if (this._operationFuncs == null) {\n      this._operationFuncs = new Map();\n    }\n\n    this._operationFuncs.set(valType, op);\n  }\n\n  public static AddOpToNativeFunc(\n    name: string,\n    args: number,\n    valType: ValueType,\n    op: UnaryOp<any> | BinaryOp<any>\n  ): void {\n    if (this._nativeFunctions === null)\n      return throwNullException(\"NativeFunctionCall._nativeFunctions\");\n    let nativeFunc = this._nativeFunctions.get(name);\n    if (!nativeFunc) {\n      nativeFunc = new NativeFunctionCall(name, args);\n      this._nativeFunctions.set(name, nativeFunc);\n    }\n\n    nativeFunc.AddOpFuncForType(valType, op);\n  }\n\n  public static AddIntBinaryOp(name: string, op: BinaryOp<number>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.Int, op);\n  }\n  public static AddIntUnaryOp(name: string, op: UnaryOp<number>) {\n    this.AddOpToNativeFunc(name, 1, ValueType.Int, op);\n  }\n\n  public static AddFloatBinaryOp(name: string, op: BinaryOp<number>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.Float, op);\n  }\n  public static AddFloatUnaryOp(name: string, op: UnaryOp<number>) {\n    this.AddOpToNativeFunc(name, 1, ValueType.Float, op);\n  }\n\n  public static AddStringBinaryOp(name: string, op: BinaryOp<string>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.String, op);\n  }\n\n  public static AddListBinaryOp(name: string, op: BinaryOp<InkList>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.List, op);\n  }\n  public static AddListUnaryOp(name: string, op: UnaryOp<InkList>) {\n    this.AddOpToNativeFunc(name, 1, ValueType.List, op);\n  }\n\n  public toString() {\n    return 'Native \"' + this.name + '\"';\n  }\n\n  public _prototype: NativeFunctionCall | null = null;\n  public _isPrototype: boolean = false;\n  public _operationFuncs: Map<ValueType, BinaryOp<any> | UnaryOp<any>> | null =\n    null;\n  public static _nativeFunctions: Map<string, NativeFunctionCall> | null = null;\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { Expression } from \"./Expression\";\nimport { BoolValue, FloatValue, IntValue } from \"../../../../engine/Value\";\nimport { asOrNull } from \"../../../../engine/TypeAssertion\";\nimport { ParsedObject } from \"../Object\";\n\n// This class is named Number in the C# codebase\n// but this conflict with the built-in Number class\nexport class NumberExpression extends Expression {\n  public value: number | boolean;\n  public subtype: \"int\" | \"float\" | \"bool\";\n\n  constructor(value: number | boolean, subtype: \"int\" | \"float\" | \"bool\") {\n    super();\n\n    if (\n      (typeof value === \"number\" && !Number.isNaN(value)) ||\n      typeof value == \"boolean\"\n    ) {\n      this.value = value;\n      this.subtype = subtype;\n    } else {\n      throw new Error(\"Unexpected object type in NumberExpression.\");\n    }\n  }\n\n  get typeName(): string {\n    return \"Number\";\n  }\n\n  public isInt = (): boolean => this.subtype == \"int\";\n\n  public isFloat = (): boolean => this.subtype == \"float\";\n\n  public isBool = (): boolean => this.subtype == \"bool\";\n\n  public readonly GenerateIntoContainer = (\n    container: RuntimeContainer\n  ): void => {\n    if (this.isInt()) {\n      container.AddContent(new IntValue(this.value as number));\n    } else if (this.isFloat()) {\n      container.AddContent(new FloatValue(this.value as number));\n    } else if (this.isBool()) {\n      container.AddContent(new BoolValue(this.value as boolean));\n    }\n  };\n\n  public readonly toString = (): string => String(this.value);\n\n  public Equals(obj: ParsedObject): boolean {\n    const numberExpression = asOrNull(obj, NumberExpression);\n    if (!numberExpression) return false;\n\n    return (\n      numberExpression.subtype == this.subtype &&\n      numberExpression.value == this.value\n    );\n  }\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { Expression } from \"./Expression\";\nimport { NativeFunctionCall } from \"../../../../engine/NativeFunctionCall\";\nimport { NumberExpression } from \"./NumberExpression\";\nimport { asOrNull } from \"../../../../engine/TypeAssertion\";\n\nexport class UnaryExpression extends Expression {\n  get nativeNameForOp(): string {\n    // Replace \"-\" with \"_\" to make it unique (compared to subtraction)\n    if (this.op === \"-\") {\n      return \"_\";\n    } else if (this.op === \"not\") {\n      return \"!\";\n    }\n\n    return this.op;\n  }\n\n  public innerExpression: Expression;\n\n  // Attempt to flatten inner expression immediately\n  // e.g. convert (-(5)) into (-5)\n  public static readonly WithInner = (\n    inner: Expression,\n    op: string\n  ): Expression => {\n    const innerNumber = asOrNull(inner, NumberExpression);\n\n    if (innerNumber) {\n      if (op === \"-\") {\n        if (innerNumber.isInt()) {\n          return new NumberExpression(-innerNumber.value, \"int\");\n        } else if (innerNumber.isFloat()) {\n          return new NumberExpression(-innerNumber.value, \"float\");\n        }\n      } else if (op == \"!\" || op == \"not\") {\n        if (innerNumber.isInt()) {\n          return new NumberExpression(innerNumber.value == 0, \"bool\");\n        } else if (innerNumber.isFloat()) {\n          return new NumberExpression(innerNumber.value == 0.0, \"bool\");\n        } else if (innerNumber.isBool()) {\n          return new NumberExpression(!innerNumber.value, \"bool\");\n        }\n      }\n\n      throw new Error(\"Unexpected operation or number type\");\n    }\n\n    // Normal fallback\n    const unary = new UnaryExpression(inner, op);\n\n    return unary;\n  };\n\n  constructor(inner: Expression, public readonly op: string) {\n    super();\n\n    this.innerExpression = this.AddContent(inner) as Expression;\n  }\n\n  get typeName(): string {\n    return \"UnaryExpression\";\n  }\n\n  public readonly GenerateIntoContainer = (container: RuntimeContainer) => {\n    this.innerExpression.GenerateIntoContainer(container);\n    container.AddContent(NativeFunctionCall.CallWithName(this.nativeNameForOp));\n  };\n\n  public readonly toString = (): string =>\n    this.nativeNameForOp + this.innerExpression;\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { Expression } from \"./Expression\";\nimport { NativeFunctionCall } from \"../../../../engine/NativeFunctionCall\";\nimport { Story } from \"../Story\";\nimport { UnaryExpression } from \"./UnaryExpression\";\nimport { asOrNull } from \"../../../../engine/TypeAssertion\";\n\nexport class BinaryExpression extends Expression {\n  public readonly leftExpression: Expression;\n  public readonly rightExpression: Expression;\n\n  constructor(left: Expression, right: Expression, public opName: string) {\n    super();\n\n    this.leftExpression = this.AddContent(left) as Expression;\n    this.rightExpression = this.AddContent(right) as Expression;\n\n    this.opName = opName;\n  }\n\n  get typeName(): string {\n    return \"BinaryExpression\";\n  }\n\n  public readonly GenerateIntoContainer = (container: RuntimeContainer) => {\n    this.leftExpression.GenerateIntoContainer(container);\n    this.rightExpression.GenerateIntoContainer(container);\n    this.opName = this.NativeNameForOp(this.opName);\n    container.AddContent(NativeFunctionCall.CallWithName(this.opName));\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    // Check for the following case:\n    //\n    //    (not A) ? B\n    //\n    // Since this easy to accidentally do:\n    //\n    //    not A ? B\n    //\n    // when you intend:\n    //\n    //    not (A ? B)\n    if (this.NativeNameForOp(this.opName) === \"?\") {\n      const leftUnary = asOrNull(this.leftExpression, UnaryExpression);\n      if (\n        leftUnary !== null &&\n        (leftUnary.op === \"not\" || leftUnary.op === \"!\")\n      ) {\n        this.Error(\n          `Using 'not' or '!' here negates '${leftUnary.innerExpression}' rather than the result of the '?' or 'has' operator. You need to add parentheses around the (A ? B) expression.`\n        );\n      }\n    }\n  }\n\n  public readonly NativeNameForOp = (opName: string): string => {\n    if (opName === \"and\") {\n      return \"&&\";\n    } else if (opName === \"or\") {\n      return \"||\";\n    } else if (opName === \"mod\") {\n      return \"%\";\n    } else if (opName === \"has\") {\n      return \"?\";\n    } else if (opName === \"hasnt\") {\n      return \"!?\";\n    }\n\n    return opName;\n  };\n\n  public readonly toString = (): string =>\n    `(${this.leftExpression} ${this.opName} ${this.rightExpression})`;\n}\n","export class CharacterSet {\n  public static readonly FromRange = (\n    start: string,\n    end: string\n  ): CharacterSet => new CharacterSet().AddRange(start, end);\n\n  public set: Set<string> = new Set<string>();\n\n  constructor(arg?: string | string[] | CharacterSet) {\n    if (arg) {\n      this.AddCharacters(arg);\n    }\n  }\n\n  public readonly Add = (arg: string) => this.set.add(arg);\n\n  public readonly AddRange = (start: string, end: string): CharacterSet => {\n    for (let c = start.charCodeAt(0); c <= end.charCodeAt(0); ++c) {\n      this.Add(String.fromCharCode(c));\n    }\n\n    return this;\n  };\n\n  public readonly AddCharacters = (\n    chars: string | string[] | CharacterSet\n  ): CharacterSet => {\n    if (typeof chars === \"string\" || Array.isArray(chars)) {\n      for (const c of chars) {\n        this.Add(c);\n      }\n    } else {\n      for (const c of chars.set) {\n        this.Add(c);\n      }\n    }\n\n    return this;\n  };\n}\n","import { CharacterSet } from \"./CharacterSet\";\n\n/// <summary>\n/// A class representing a character range. Allows for lazy-loading a corresponding <see cref=\"CharacterSet\">character set</see>.\n/// </summary>\nexport class CharacterRange {\n  public static Define = (\n    start: string,\n    end: string,\n    excludes: string[] | CharacterSet = []\n  ): CharacterRange => new CharacterRange(start, end, excludes);\n\n  private _correspondingCharSet: CharacterSet = new CharacterSet();\n  private _excludes = new Set<string>();\n\n  constructor(\n    private _start: string,\n    private _end: string,\n    excludes: string[] | CharacterSet = []\n  ) {\n    if (excludes instanceof CharacterSet) {\n      this._excludes = excludes.set;\n    } else {\n      for (const item of excludes) {\n        this._excludes.add(item);\n      }\n    }\n  }\n\n  get start(): string {\n    return this._start;\n  }\n\n  get end(): string {\n    return this._end;\n  }\n\n  /// <summary>\n  /// Returns a <see cref=\"CharacterSet\">character set</see> instance corresponding to the character range\n  /// represented by the current instance.\n  /// </summary>\n  /// <remarks>\n  /// The internal character set is created once and cached in memory.\n  /// </remarks>\n  /// <returns>The char set.</returns>\n  public readonly ToCharacterSet = (): CharacterSet => {\n    if (this._correspondingCharSet.set.size === 0) {\n      for (\n        let ii = this.start.charCodeAt(0), c;\n        ii <= this.end.charCodeAt(0);\n        ii += 1\n      ) {\n        c = String.fromCharCode(ii);\n        if (!this._excludes.has(c)) {\n          this._correspondingCharSet.AddCharacters(c);\n        }\n      }\n    }\n\n    return this._correspondingCharSet;\n  };\n}\n","import { InkObject } from \"./Object\";\nimport { Path } from \"./Path\";\nimport { Container } from \"./Container\";\nimport { throwNullException } from \"./NullException\";\n\nexport class ChoicePoint extends InkObject {\n  public _pathOnChoice: Path | null = null;\n  public hasCondition: boolean = false;\n  public hasStartContent: boolean = false;\n  public hasChoiceOnlyContent: boolean = false;\n  public isInvisibleDefault: boolean = false;\n  public onceOnly: boolean = true;\n\n  constructor(onceOnly: boolean = true) {\n    super();\n    this.onceOnly = onceOnly;\n  }\n  get pathOnChoice(): Path | null {\n    if (this._pathOnChoice != null && this._pathOnChoice.isRelative) {\n      let choiceTargetObj = this.choiceTarget;\n      if (choiceTargetObj) {\n        this._pathOnChoice = choiceTargetObj.path;\n      }\n    }\n    return this._pathOnChoice;\n  }\n  set pathOnChoice(value: Path | null) {\n    this._pathOnChoice = value;\n  }\n  get choiceTarget(): Container | null {\n    if (this._pathOnChoice === null)\n      return throwNullException(\"ChoicePoint._pathOnChoice\");\n    return this.ResolvePath(this._pathOnChoice).container;\n  }\n  get pathStringOnChoice(): string {\n    if (this.pathOnChoice === null)\n      return throwNullException(\"ChoicePoint.pathOnChoice\");\n    return this.CompactPathString(this.pathOnChoice);\n  }\n  set pathStringOnChoice(value: string) {\n    this.pathOnChoice = new Path(value);\n  }\n  get flags(): number {\n    let flags = 0;\n    if (this.hasCondition) flags |= 1;\n    if (this.hasStartContent) flags |= 2;\n    if (this.hasChoiceOnlyContent) flags |= 4;\n    if (this.isInvisibleDefault) flags |= 8;\n    if (this.onceOnly) flags |= 16;\n    return flags;\n  }\n  set flags(value: number) {\n    this.hasCondition = (value & 1) > 0;\n    this.hasStartContent = (value & 2) > 0;\n    this.hasChoiceOnlyContent = (value & 4) > 0;\n    this.isInvisibleDefault = (value & 8) > 0;\n    this.onceOnly = (value & 16) > 0;\n  }\n  public toString(): string {\n    if (this.pathOnChoice === null)\n      return throwNullException(\"ChoicePoint.pathOnChoice\");\n    // int? targetLineNum = DebugLineNumberOfPath (pathOnChoice);\n    let targetLineNum = null;\n    let targetString = this.pathOnChoice.toString();\n\n    if (targetLineNum != null) {\n      targetString = \" line \" + targetLineNum + \"(\" + targetString + \")\";\n    }\n\n    return \"Choice: -> \" + targetString;\n  }\n}\n","export enum PushPopType {\n  Tunnel = 0,\n  Function = 1,\n  FunctionEvaluationFromGame = 2,\n}\n","import { Path } from \"./Path\";\nimport { Container } from \"./Container\";\nimport { InkObject } from \"./Object\";\n\nexport class Pointer {\n  public container: Container | null = null;\n  public index: number = -1;\n\n  constructor();\n  constructor(container: Container | null, index: number);\n  constructor() {\n    if (arguments.length === 2) {\n      this.container = arguments[0];\n      this.index = arguments[1];\n    }\n  }\n\n  public Resolve(): InkObject | null {\n    if (this.index < 0) return this.container;\n    if (this.container == null) return null;\n    if (this.container.content.length == 0) return this.container;\n    if (this.index >= this.container.content.length) return null;\n\n    return this.container.content[this.index];\n  }\n\n  get isNull(): boolean {\n    return this.container == null;\n  }\n\n  get path(): Path | null {\n    if (this.isNull) return null;\n\n    if (this.index >= 0)\n      return this.container!.path.PathByAppendingComponent(\n        new Path.Component(this.index)\n      );\n    else return this.container!.path;\n  }\n\n  public toString(): string {\n    if (!this.container) return \"Ink Pointer (null)\";\n\n    return (\n      \"Ink Pointer -> \" +\n      this.container.path.toString() +\n      \" -- index \" +\n      this.index\n    );\n  }\n\n  // This method does not exist in the original C# code, but is here to maintain the\n  // value semantics of Pointer.\n  public copy(): Pointer {\n    return new Pointer(this.container, this.index);\n  }\n\n  public static StartOf(container: Container | null): Pointer {\n    return new Pointer(container, 0);\n  }\n\n  public static get Null(): Pointer {\n    return new Pointer(null, -1);\n  }\n}\n","export enum SymbolType {\n  Knot = 0,\n  List = 1,\n  ListItem = 2,\n  Var = 3,\n  SubFlowAndWeave = 4,\n  Arg = 5,\n  Temp = 6,\n}\n","import { Path } from \"./Path\";\nimport { PushPopType } from \"./PushPop\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { InkObject } from \"./Object\";\nimport { Pointer } from \"./Pointer\";\nimport { Container } from \"./Container\";\nimport { throwNullException } from \"./NullException\";\n\nexport class Divert extends InkObject {\n  get targetPath() {\n    if (this._targetPath != null && this._targetPath.isRelative) {\n      let targetObj = this.targetPointer.Resolve();\n      if (targetObj) {\n        this._targetPath = targetObj.path;\n      }\n    }\n\n    return this._targetPath;\n  }\n  set targetPath(value: Path | null) {\n    this._targetPath = value;\n    this._targetPointer = Pointer.Null;\n  }\n\n  public _targetPath: Path | null = null;\n\n  get targetPointer() {\n    if (this._targetPointer.isNull) {\n      let targetObj = this.ResolvePath(this._targetPath).obj;\n\n      if (this._targetPath === null)\n        return throwNullException(\"this._targetPath\");\n      if (this._targetPath.lastComponent === null)\n        return throwNullException(\"this._targetPath.lastComponent\");\n\n      if (this._targetPath.lastComponent.isIndex) {\n        if (targetObj === null) return throwNullException(\"targetObj\");\n        this._targetPointer.container =\n          targetObj.parent instanceof Container ? targetObj.parent : null;\n        this._targetPointer.index = this._targetPath.lastComponent.index;\n      } else {\n        this._targetPointer = Pointer.StartOf(\n          targetObj instanceof Container ? targetObj : null\n        );\n      }\n    }\n\n    return this._targetPointer.copy();\n  }\n\n  public _targetPointer: Pointer = Pointer.Null;\n\n  get targetPathString() {\n    if (this.targetPath == null) return null;\n\n    return this.CompactPathString(this.targetPath);\n  }\n  set targetPathString(value: string | null) {\n    if (value == null) {\n      this.targetPath = null;\n    } else {\n      this.targetPath = new Path(value);\n    }\n  }\n\n  public variableDivertName: string | null = null;\n  get hasVariableTarget() {\n    return this.variableDivertName != null;\n  }\n\n  public pushesToStack: boolean = false;\n  public stackPushType: PushPopType = 0;\n\n  public isExternal: boolean = false;\n  public externalArgs: number = 0;\n\n  public isConditional: boolean = false;\n\n  constructor(stackPushType?: PushPopType) {\n    super();\n    this.pushesToStack = false;\n\n    if (typeof stackPushType !== \"undefined\") {\n      this.pushesToStack = true;\n      this.stackPushType = stackPushType;\n    }\n  }\n\n  public Equals(obj: Divert | null) {\n    let otherDivert = obj;\n    if (otherDivert instanceof Divert) {\n      if (this.hasVariableTarget == otherDivert.hasVariableTarget) {\n        if (this.hasVariableTarget) {\n          return this.variableDivertName == otherDivert.variableDivertName;\n        } else {\n          if (this.targetPath === null)\n            return throwNullException(\"this.targetPath\");\n          return this.targetPath.Equals(otherDivert.targetPath);\n        }\n      }\n    }\n    return false;\n  }\n\n  public toString() {\n    if (this.hasVariableTarget) {\n      return \"Divert(variable: \" + this.variableDivertName + \")\";\n    } else if (this.targetPath == null) {\n      return \"Divert(null)\";\n    } else {\n      let sb = new StringBuilder();\n\n      let targetStr = this.targetPath.toString();\n      // int? targetLineNum = DebugLineNumberOfPath (targetPath);\n      let targetLineNum = null;\n      if (targetLineNum != null) {\n        targetStr = \"line \" + targetLineNum;\n      }\n\n      sb.Append(\"Divert\");\n\n      if (this.isConditional) sb.Append(\"?\");\n\n      if (this.pushesToStack) {\n        if (this.stackPushType == PushPopType.Function) {\n          sb.Append(\" function\");\n        } else {\n          sb.Append(\" tunnel\");\n        }\n      }\n\n      sb.Append(\" -> \");\n      sb.Append(this.targetPathString);\n\n      sb.Append(\" (\");\n      sb.Append(targetStr);\n      sb.Append(\")\");\n\n      return sb.toString();\n    }\n  }\n}\n","import { InkObject } from \"./Object\";\n\nexport class VariableAssignment extends InkObject {\n  public readonly variableName: string | null;\n  public readonly isNewDeclaration: boolean;\n  public isGlobal: boolean;\n\n  constructor(variableName: string | null, isNewDeclaration: boolean) {\n    super();\n    this.variableName = variableName || null;\n    this.isNewDeclaration = !!isNewDeclaration;\n    this.isGlobal = false;\n  }\n\n  public toString(): string {\n    return \"VarAssign to \" + this.variableName;\n  }\n}\n","import { ChoicePoint } from \"../../../engine/ChoicePoint\";\nimport { Container as RuntimeContainer } from \"../../../engine/Container\";\nimport { ContentList } from \"./ContentList\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../engine/ControlCommand\";\nimport { Divert as RuntimeDivert } from \"../../../engine/Divert\";\nimport { DivertTargetValue } from \"../../../engine/Value\";\nimport { INamedContent } from \"../../../engine/INamedContent\";\nimport { IWeavePoint } from \"./IWeavePoint\";\nimport { ParsedObject } from \"./Object\";\nimport { InkObject as RuntimeObject } from \"../../../engine/Object\";\nimport { Path as RuntimePath } from \"../../../engine/Path\";\nimport { Story } from \"./Story\";\nimport { SymbolType } from \"./SymbolType\";\nimport { VariableAssignment as RuntimeVariableAssignment } from \"../../../engine/VariableAssignment\";\nimport { Expression } from \"./Expression/Expression\";\nimport { Identifier } from \"./Identifier\";\n\nexport class Choice extends ParsedObject implements IWeavePoint, INamedContent {\n  private _condition: Expression | null = null;\n  private _innerContentContainer: RuntimeContainer | null = null;\n  private _outerContainer: RuntimeContainer | null = null;\n  private _runtimeChoice: ChoicePoint | null = null;\n  get runtimeChoice(): ChoicePoint {\n    if (!this._runtimeChoice) {\n      throw new Error();\n    }\n\n    return this._runtimeChoice;\n  }\n\n  private _returnToR1: DivertTargetValue | null = null;\n  private _returnToR2: DivertTargetValue | null = null;\n  private _r1Label: RuntimeContainer | null = null;\n  private _r2Label: RuntimeContainer | null = null;\n  private _divertToStartContentOuter: RuntimeDivert | null = null;\n  private _divertToStartContentInner: RuntimeDivert | null = null;\n  private _startContentRuntimeContainer: RuntimeContainer | null = null;\n\n  public startContent: ContentList;\n  public choiceOnlyContent: ContentList;\n  public innerContent: ContentList;\n  public identifier?: Identifier;\n  get name() {\n    return this.identifier?.name || null;\n  }\n  public onceOnly: boolean;\n  public isInvisibleDefault: boolean = false;\n  public indentationDepth: number;\n  public hasWeaveStyleInlineBrackets: boolean = false;\n\n  get condition() {\n    return this._condition;\n  }\n\n  set condition(value) {\n    this._condition = value;\n    if (value) {\n      this.AddContent(value as ParsedObject);\n    }\n  }\n\n  // Required for IWeavePoint interface\n  // Choice's target container. Used by weave to append any extra\n  // nested weave content into.\n  get runtimeContainer() {\n    return this._innerContentContainer;\n  }\n\n  get innerContentContainer() {\n    return this._innerContentContainer;\n  }\n\n  get containerForCounting() {\n    return this._innerContentContainer;\n  }\n\n  // Override runtimePath to point to the Choice's target content (after it's chosen),\n  // as opposed to the default implementation which would point to the choice itself\n  // (or it's outer container), which is what runtimeObject is.\n  get runtimePath(): RuntimePath {\n    if (!this.innerContentContainer || !this.innerContentContainer.path) {\n      throw new Error();\n    }\n\n    return this.innerContentContainer.path;\n  }\n\n  constructor(\n    startContent: ContentList,\n    choiceOnlyContent: ContentList,\n    innerContent: ContentList\n  ) {\n    super();\n\n    this.startContent = startContent;\n    this.choiceOnlyContent = choiceOnlyContent;\n    this.innerContent = innerContent;\n    this.indentationDepth = 1;\n\n    if (startContent) {\n      this.AddContent(this.startContent);\n    }\n\n    if (choiceOnlyContent) {\n      this.AddContent(this.choiceOnlyContent);\n    }\n\n    if (innerContent) {\n      this.AddContent(this.innerContent);\n    }\n\n    this.onceOnly = true; // default\n  }\n\n  get typeName(): string {\n    return \"Choice\";\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    this._outerContainer = new RuntimeContainer();\n\n    // Content names for different types of choice:\n    //  * start content [choice only content] inner content\n    //  * start content   -> divert\n    //  * start content\n    //  * [choice only content]\n\n    // Hmm, this structure has become slightly insane!\n    //\n    // [\n    //     EvalStart\n    //     assign $r = $r1   -- return target = return label 1\n    //     BeginString\n    //     -> s\n    //     [(r1)]            -- return label 1 (after start content)\n    //     EndString\n    //     BeginString\n    //     ... choice only content\n    //     EndEval\n    //     Condition expression\n    //     choice: -> \"c-0\"\n    //     (s) = [\n    //         start content\n    //         -> r          -- goto return label 1 or 2\n    //     ]\n    //  ]\n    //\n    //  in parent's container: (the inner content for the choice)\n    //\n    //  (c-0) = [\n    //      EvalStart\n    //      assign $r = $r2   -- return target = return label 2\n    //      EndEval\n    //      -> s\n    //      [(r2)]            -- return label 1 (after start content)\n    //      inner content\n    //  ]\n    //\n\n    this._runtimeChoice = new ChoicePoint(this.onceOnly);\n    this._runtimeChoice.isInvisibleDefault = this.isInvisibleDefault;\n\n    if (this.startContent || this.choiceOnlyContent || this.condition) {\n      this._outerContainer.AddContent(RuntimeControlCommand.EvalStart());\n    }\n\n    // Start content is put into a named container that's referenced both\n    // when displaying the choice initially, and when generating the text\n    // when the choice is chosen.\n    if (this.startContent) {\n      // Generate start content and return\n      //  - We can't use a function since it uses a call stack element, which would\n      //    put temporary values out of scope. Instead we manually divert around.\n      //  - $r is a variable divert target contains the return point\n      this._returnToR1 = new DivertTargetValue();\n      this._outerContainer.AddContent(this._returnToR1);\n\n      const varAssign = new RuntimeVariableAssignment(\"$r\", true);\n      this._outerContainer.AddContent(varAssign);\n\n      // Mark the start of the choice text generation, so that the runtime\n      // knows where to rewind to to extract the content from the output stream.\n      this._outerContainer.AddContent(RuntimeControlCommand.BeginString());\n\n      this._divertToStartContentOuter = new RuntimeDivert();\n      this._outerContainer.AddContent(this._divertToStartContentOuter);\n\n      // Start content itself in a named container\n      this._startContentRuntimeContainer =\n        this.startContent.GenerateRuntimeObject() as RuntimeContainer;\n      this._startContentRuntimeContainer.name = \"s\";\n\n      // Effectively, the \"return\" statement - return to the point specified by $r\n      const varDivert = new RuntimeDivert();\n      varDivert.variableDivertName = \"$r\";\n      this._startContentRuntimeContainer.AddContent(varDivert);\n\n      // Add the container\n      this._outerContainer.AddToNamedContentOnly(\n        this._startContentRuntimeContainer\n      );\n\n      // This is the label to return to\n      this._r1Label = new RuntimeContainer();\n      this._r1Label.name = \"$r1\";\n      this._outerContainer.AddContent(this._r1Label);\n\n      this._outerContainer.AddContent(RuntimeControlCommand.EndString());\n\n      this._runtimeChoice.hasStartContent = true;\n    }\n\n    // Choice only content - mark the start, then generate it directly into the outer container\n    if (this.choiceOnlyContent) {\n      this._outerContainer.AddContent(RuntimeControlCommand.BeginString());\n\n      const choiceOnlyRuntimeContent =\n        this.choiceOnlyContent.GenerateRuntimeObject() as RuntimeContainer;\n      this._outerContainer.AddContentsOfContainer(choiceOnlyRuntimeContent);\n\n      this._outerContainer.AddContent(RuntimeControlCommand.EndString());\n\n      this._runtimeChoice.hasChoiceOnlyContent = true;\n    }\n\n    // Generate any condition for this choice\n    if (this.condition) {\n      this.condition.GenerateIntoContainer(this._outerContainer);\n      this._runtimeChoice.hasCondition = true;\n    }\n\n    if (this.startContent || this.choiceOnlyContent || this.condition) {\n      this._outerContainer.AddContent(RuntimeControlCommand.EvalEnd());\n    }\n\n    // Add choice itself\n    this._outerContainer.AddContent(this._runtimeChoice);\n\n    // Container that choice points to for when it's chosen\n    this._innerContentContainer = new RuntimeContainer();\n\n    // Repeat start content by diverting to its container\n    if (this.startContent) {\n      // Set the return point when jumping back into the start content\n      //  - In this case, it's the $r2 point, within the choice content \"c\".\n      this._returnToR2 = new DivertTargetValue();\n      this._innerContentContainer.AddContent(RuntimeControlCommand.EvalStart());\n      this._innerContentContainer.AddContent(this._returnToR2);\n      this._innerContentContainer.AddContent(RuntimeControlCommand.EvalEnd());\n      const varAssign = new RuntimeVariableAssignment(\"$r\", true);\n      this._innerContentContainer.AddContent(varAssign);\n\n      // Main divert into start content\n      this._divertToStartContentInner = new RuntimeDivert();\n      this._innerContentContainer.AddContent(this._divertToStartContentInner);\n\n      // Define label to return to\n      this._r2Label = new RuntimeContainer();\n      this._r2Label.name = \"$r2\";\n      this._innerContentContainer.AddContent(this._r2Label);\n    }\n\n    // Choice's own inner content\n    if (this.innerContent) {\n      const innerChoiceOnlyContent =\n        this.innerContent.GenerateRuntimeObject() as RuntimeContainer;\n      this._innerContentContainer.AddContentsOfContainer(\n        innerChoiceOnlyContent\n      );\n    }\n\n    if (this.story.countAllVisits) {\n      this._innerContentContainer.visitsShouldBeCounted = true;\n    }\n\n    this._innerContentContainer.countingAtStartOnly = true;\n\n    return this._outerContainer;\n  };\n\n  public ResolveReferences(context: Story): void {\n    // Weave style choice - target own content container\n    if (this._innerContentContainer) {\n      this.runtimeChoice.pathOnChoice = this._innerContentContainer.path;\n\n      if (this.onceOnly) {\n        this._innerContentContainer.visitsShouldBeCounted = true;\n      }\n    }\n\n    if (this._returnToR1) {\n      if (!this._r1Label) {\n        throw new Error();\n      }\n\n      this._returnToR1.targetPath = this._r1Label.path;\n    }\n\n    if (this._returnToR2) {\n      if (!this._r2Label) {\n        throw new Error();\n      }\n\n      this._returnToR2.targetPath = this._r2Label.path;\n    }\n\n    if (this._divertToStartContentOuter) {\n      if (!this._startContentRuntimeContainer) {\n        throw new Error();\n      }\n\n      this._divertToStartContentOuter.targetPath =\n        this._startContentRuntimeContainer.path;\n    }\n\n    if (this._divertToStartContentInner) {\n      if (!this._startContentRuntimeContainer) {\n        throw new Error();\n      }\n\n      this._divertToStartContentInner.targetPath =\n        this._startContentRuntimeContainer.path;\n    }\n\n    super.ResolveReferences(context);\n\n    if (this.identifier && (this.identifier?.name || \"\").length > 0) {\n      context.CheckForNamingCollisions(\n        this as ParsedObject,\n        this.identifier,\n        SymbolType.SubFlowAndWeave\n      );\n    }\n  }\n\n  public readonly toString = () => {\n    if (this.choiceOnlyContent !== null) {\n      return `* ${this.startContent}[${this.choiceOnlyContent}]...`;\n    }\n\n    return `* ${this.startContent}...`;\n  };\n}\n","export class StringParserElement {\n  public static _uniqueIdCounter: number = 1000;\n\n  public characterIndex: number = 0;\n  public characterInLineIndex: number = 0;\n  public lineIndex: number = 0;\n  public reportedErrorInScope: boolean = false;\n  public uniqueId: number = 0;\n  public customFlags: number = 0;\n\n  public readonly CopyFrom = (fromElement: StringParserElement): void => {\n    StringParserElement._uniqueIdCounter++;\n    this.uniqueId = StringParserElement._uniqueIdCounter;\n    this.characterIndex = fromElement.characterIndex;\n    this.characterInLineIndex = fromElement.characterInLineIndex;\n    this.lineIndex = fromElement.lineIndex;\n    this.customFlags = fromElement.customFlags;\n    this.reportedErrorInScope = false;\n  };\n\n  // Squash is used when succeeding from a rule,\n  // so only the state information we wanted to carry forward is\n  // retained. e.g. characterIndex and lineIndex are global,\n  // however uniqueId is specific to the individual rule,\n  // and likewise, custom flags are designed for the temporary\n  // state of the individual rule too.\n  public readonly SquashFrom = (fromElement: StringParserElement): void => {\n    this.characterIndex = fromElement.characterIndex;\n    this.characterInLineIndex = fromElement.characterInLineIndex;\n    this.lineIndex = fromElement.lineIndex;\n    this.reportedErrorInScope = fromElement.reportedErrorInScope;\n    this.customFlags = fromElement.customFlags;\n  };\n}\n","import { StringParserElement } from \"./StringParserElement\";\n\nexport class StringParserState {\n  private _stack: StringParserElement[] = [];\n  private _numElements: number = 0;\n\n  get currentElement(): StringParserElement {\n    return this._stack[this._numElements - 1];\n  }\n\n  get lineIndex(): number {\n    return this.currentElement.lineIndex;\n  }\n\n  set lineIndex(value: number) {\n    this.currentElement.lineIndex = value;\n  }\n\n  get characterIndex(): number {\n    return this.currentElement.characterIndex;\n  }\n\n  set characterIndex(value: number) {\n    this.currentElement.characterIndex = value;\n  }\n\n  get characterInLineIndex(): number {\n    return this.currentElement.characterInLineIndex;\n  }\n\n  set characterInLineIndex(value: number) {\n    this.currentElement.characterInLineIndex = value;\n  }\n\n  get customFlags(): number {\n    return this.currentElement.customFlags;\n  }\n\n  set customFlags(value: number) {\n    this.currentElement.customFlags = value;\n  }\n\n  get errorReportedAlreadyInScope(): boolean {\n    return this.currentElement.reportedErrorInScope;\n  }\n\n  get stackHeight(): number {\n    return this._numElements;\n  }\n\n  constructor() {\n    const kExpectedMaxStackDepth = 200;\n    for (let i = 0; i < kExpectedMaxStackDepth; i++) {\n      this._stack[i] = new StringParserElement();\n    }\n    this._numElements = 1;\n  }\n\n  public readonly StringParserState = (): void => {\n    const kExpectedMaxStackDepth: number = 200;\n    this._stack = new Array(kExpectedMaxStackDepth);\n\n    for (let ii = 0; ii < kExpectedMaxStackDepth; ++ii) {\n      this._stack[ii] = new StringParserElement();\n    }\n\n    this._numElements = 1;\n  };\n\n  public readonly Push = (): number => {\n    if (this._numElements >= this._stack.length && this._numElements > 0) {\n      throw new Error(\"Stack overflow in parser state.\");\n    }\n\n    const prevElement = this._stack[this._numElements - 1];\n    const newElement = this._stack[this._numElements];\n    this._numElements++;\n\n    newElement.CopyFrom(prevElement);\n\n    return newElement.uniqueId;\n  };\n\n  public readonly Pop = (expectedRuleId: number): void => {\n    if (this._numElements == 1) {\n      throw new Error(\n        \"Attempting to remove final stack element is illegal! Mismatched Begin/Succceed/Fail?\"\n      );\n    }\n\n    if (this.currentElement.uniqueId != expectedRuleId) {\n      throw new Error(\n        \"Mismatched rule IDs while Poping - do you have mismatched Begin/Succeed/Fail?\"\n      );\n    }\n\n    // Restore state\n    this._numElements -= 1;\n  };\n\n  public Peek = (expectedRuleId: number) => {\n    if (this.currentElement.uniqueId != expectedRuleId) {\n      throw new Error(\n        \"Mismatched rule IDs while Peeking - do you have mismatched Begin/Succeed/Fail?\"\n      );\n    }\n\n    return this._stack[this._numElements - 1];\n  };\n\n  public readonly PeekPenultimate = (): StringParserElement | null => {\n    if (this._numElements >= 2) {\n      return this._stack[this._numElements - 2];\n    }\n\n    return null;\n  };\n\n  // Reduce stack height while maintaining currentElement\n  // Remove second last element: i.e. \"squash last two elements together\"\n  // Used when succeeding from a rule (and ONLY when succeeding, since\n  // the state of the top element is retained).\n  public readonly Squash = (): void => {\n    if (this._numElements < 2) {\n      throw new Error(\n        \"Attempting to remove final stack element is illegal! Mismatched Begin/Succceed/Fail?\"\n      );\n    }\n\n    const penultimateEl = this._stack[this._numElements - 2];\n    const lastEl = this._stack[this._numElements - 1];\n\n    penultimateEl.SquashFrom(lastEl);\n\n    this._numElements -= 1;\n  };\n\n  public readonly NoteErrorReported = (): void => {\n    for (const el of this._stack) {\n      el.reportedErrorInScope = true;\n    }\n  };\n}\n","import { CharacterSet } from \"../CharacterSet\";\nimport { ParsedObject } from \"../ParsedHierarchy/Object\";\nimport { StringParserState } from \"./StringParserState\";\nimport { StringParserElement } from \"./StringParserElement\";\n\nexport const ParseSuccess = Symbol(\"ParseSuccessStruct\");\n\nexport type ParseRule = () => ParseRuleReturn;\n\nexport type ParseRuleReturn =\n  | object\n  | string\n  | null\n  | number\n  | (typeof StringParser)[\"ParseSuccess\"];\n\nexport type SpecificParseRule<T extends ParseRule> = T;\n\nexport class StringParser {\n  public ParseRule: ParseRule | null = null;\n\n  public static readonly ParseSuccess: typeof ParseSuccess = ParseSuccess;\n  public static readonly numbersCharacterSet = new CharacterSet(\"0123456789\");\n\n  private _chars: string[];\n\n  public errorHandler:\n    | null\n    | ((\n        message: string,\n        index: number,\n        lineIndex?: number,\n        isWarning?: boolean\n      ) => void) = null;\n  public state: StringParserState;\n  public hadError: boolean = false;\n\n  constructor(str: string) {\n    const strPreProc = this.PreProcessInputString(str);\n    this.state = new StringParserState();\n\n    if (str) {\n      this._chars = strPreProc.split(\"\");\n    } else {\n      this._chars = [];\n    }\n\n    this.inputString = strPreProc;\n  }\n\n  get currentCharacter(): string {\n    if (this.index >= 0 && this.remainingLength > 0) {\n      return this._chars[this.index];\n    }\n\n    return \"0\";\n  }\n\n  // Don't do anything by default, but provide ability for subclasses\n  // to manipulate the string before it's used as input (converted to a char array)\n  public PreProcessInputString(str: string): string {\n    return str;\n  }\n\n  //--------------------------------\n  // Parse state\n  //--------------------------------\n\n  public readonly BeginRule = (): number => this.state.Push();\n\n  public readonly FailRule = (expectedRuleId: number): ParseRuleReturn => {\n    this.state.Pop(expectedRuleId);\n    return null;\n  };\n\n  public readonly CancelRule = (expectedRuleId: number): void => {\n    this.state.Pop(expectedRuleId);\n  };\n\n  public readonly SucceedRule = (\n    expectedRuleId: number,\n    result: ParseRuleReturn = null\n  ): ParseRuleReturn => {\n    // Get state at point where this rule stared evaluating\n    const stateAtSucceedRule = this.state.Peek(expectedRuleId);\n    const stateAtBeginRule = this.state.PeekPenultimate();\n\n    // Allow subclass to receive callback\n    if (this.RuleDidSucceed) {\n      this.RuleDidSucceed(result, stateAtBeginRule, stateAtSucceedRule);\n    }\n\n    // Flatten state stack so that we maintain the same values,\n    // but remove one level in the stack.\n    this.state.Squash();\n\n    let finalResult: ParseRuleReturn = result;\n    if (finalResult === null) {\n      finalResult = StringParser.ParseSuccess;\n    }\n\n    return finalResult;\n  };\n\n  public RuleDidSucceed?: (\n    result: ParseRuleReturn,\n    startState: StringParserElement | null,\n    endState: StringParserElement\n  ) => void;\n\n  public readonly Expect = (\n    rule: ParseRule,\n    message: string | null = null,\n    recoveryRule: ParseRule | null = null\n  ): ParseRuleReturn => {\n    let result: ParseRuleReturn = this.ParseObject(rule);\n    if (result === null) {\n      if (message === null) {\n        message = rule.name;\n      }\n\n      let butSaw: string;\n      const lineRemainder: string = this.LineRemainder();\n      if (lineRemainder === null || lineRemainder.length === 0) {\n        butSaw = \"end of line\";\n      } else {\n        butSaw = `'${lineRemainder}'`;\n      }\n\n      this.Error(`Expected ${message} but saw ${butSaw}`);\n\n      if (recoveryRule !== null) {\n        result = recoveryRule();\n      }\n    }\n\n    return result;\n  };\n\n  public Error = (message: string, isWarning: boolean = false): void => {\n    this.ErrorOnLine(message, this.lineIndex + 1, isWarning);\n  };\n\n  public readonly ErrorWithParsedObject = (\n    message: string,\n    result: ParsedObject,\n    isWarning: boolean = false\n  ): void => {\n    this.ErrorOnLine(\n      message,\n      result.debugMetadata ? result.debugMetadata.startLineNumber : -1,\n      isWarning\n    );\n  };\n\n  public readonly ErrorOnLine = (\n    message: string,\n    lineNumber: number,\n    isWarning: boolean\n  ): void => {\n    if (!this.state.errorReportedAlreadyInScope) {\n      const errorType = isWarning ? \"Warning\" : \"Error\";\n\n      if (!this.errorHandler) {\n        throw new Error(`${errorType} on line ${lineNumber}: ${message}`);\n      } else {\n        this.errorHandler(message, this.index, lineNumber - 1, isWarning);\n      }\n\n      this.state.NoteErrorReported();\n    }\n\n    if (!isWarning) {\n      this.hadError = true;\n    }\n  };\n\n  public readonly Warning = (message: string): void =>\n    this.Error(message, true);\n\n  get endOfInput(): boolean {\n    return this.index >= this._chars.length;\n  }\n\n  get remainingString(): string {\n    return this._chars\n      .slice(this.index, this.index + this.remainingLength)\n      .join(\"\");\n  }\n\n  public readonly LineRemainder = (): string =>\n    this.Peek(() => this.ParseUntilCharactersFromString(\"\\n\\r\")) as string;\n\n  get remainingLength() {\n    return this._chars.length - this.index;\n  }\n\n  public inputString: string;\n\n  get lineIndex() {\n    return this.state.lineIndex;\n  }\n\n  set lineIndex(value: number) {\n    this.state.lineIndex = value;\n  }\n\n  set characterInLineIndex(value: number) {\n    this.state.characterInLineIndex = value;\n  }\n\n  get characterInLineIndex() {\n    return this.state.characterInLineIndex;\n  }\n\n  get index(): number {\n    // If we want subclass parsers to be able to set the index directly,\n    // then we would need to know what the lineIndex of the new\n    // index would be - would we have to step through manually\n    // counting the newlines to do so?\n    return this.state.characterIndex;\n  }\n\n  set index(value: number) {\n    this.state.characterIndex = value;\n  }\n\n  public readonly SetFlag = (flag: number, trueOrFalse: boolean): void => {\n    if (trueOrFalse) {\n      this.state.customFlags |= flag;\n    } else {\n      this.state.customFlags &= ~flag;\n    }\n  };\n\n  public readonly GetFlag = (flag: number): boolean =>\n    Boolean(this.state.customFlags & flag);\n\n  //--------------------------------\n  // Structuring\n  //--------------------------------\n\n  public ParseObject = (rule: ParseRule): ParseRuleReturn => {\n    const ruleId: number = this.BeginRule();\n    const stackHeightBefore = this.state.stackHeight;\n    const result = rule();\n\n    if (stackHeightBefore !== this.state.stackHeight) {\n      throw new Error(\"Mismatched Begin/Fail/Succeed rules\");\n    }\n\n    if (result === null) {\n      return this.FailRule(ruleId);\n    }\n\n    this.SucceedRule(ruleId, result);\n\n    return result;\n  };\n\n  public readonly Parse = <T extends ParseRule>(\n    rule: SpecificParseRule<T>\n  ): ParseRuleReturn => {\n    const ruleId: number = this.BeginRule();\n\n    const result: ParseRuleReturn = rule();\n    if (result === null) {\n      this.FailRule(ruleId);\n      return null;\n    }\n\n    this.SucceedRule(ruleId, result);\n\n    return result;\n  };\n\n  public readonly OneOf = (array: ParseRule[]): ParseRuleReturn => {\n    for (const rule of array) {\n      const result = this.ParseObject(rule);\n      if (result !== null) {\n        return result;\n      }\n    }\n\n    return null;\n  };\n\n  public readonly OneOrMore = (rule: ParseRule): ParseRuleReturn[] | null => {\n    const results: ParseRuleReturn[] = [];\n    let result: ParseRuleReturn = null;\n\n    do {\n      result = this.ParseObject(rule);\n      if (result !== null) {\n        results.push(result);\n      }\n    } while (result !== null);\n\n    if (results.length > 0) {\n      return results;\n    }\n\n    return null;\n  };\n\n  public readonly Optional =\n    (rule: ParseRule): ParseRule =>\n    () => {\n      const result = this.ParseObject(rule);\n      if (result === null) return StringParser.ParseSuccess;\n      return result;\n    };\n\n  // Return ParseSuccess instead the real result so that it gets excluded\n  // from result arrays (e.g. Interleave)\n  public readonly Exclude =\n    (rule: ParseRule): ParseRule =>\n    () =>\n      this.ParseObject(rule) && StringParser.ParseSuccess;\n\n  // Combination of both of the above\n  public readonly OptionalExclude =\n    (rule: ParseRule): ParseRule =>\n    () => {\n      this.ParseObject(rule);\n      return StringParser.ParseSuccess;\n    };\n\n  // Convenience method for creating more readable ParseString rules that can be combined\n  // in other structuring rules (like OneOf etc)\n  // e.g. OneOf(String(\"one\"), String(\"two\"))\n  public readonly String =\n    (str: string): ParseRule =>\n    () =>\n      this.ParseString(str);\n\n  private readonly TryAddResultToList = <T>(\n    result: ParseRuleReturn,\n    list: T[],\n    flatten: boolean = true\n  ): void => {\n    if (result === StringParser.ParseSuccess) {\n      return;\n    }\n\n    if (flatten && Array.isArray(result)) {\n      const resultCollection = result as ParseRuleReturn[];\n      if (resultCollection !== null) {\n        for (const obj of resultCollection) {\n          list.push(obj as any);\n        }\n\n        return;\n      }\n    }\n\n    list.push(result as any);\n  };\n\n  public readonly Interleave = <T>(\n    ruleA: ParseRule,\n    ruleB: ParseRule,\n    untilTerminator: ParseRule | null = null,\n    flatten: boolean = true\n  ): T[] => {\n    const ruleId: number = this.BeginRule();\n    const results: T[] = [];\n\n    // First outer padding\n    const firstA = this.ParseObject(ruleA);\n    if (firstA === null) {\n      return this.FailRule(ruleId) as any;\n    } else {\n      this.TryAddResultToList(firstA, results, flatten);\n    }\n\n    let lastMainResult: ParseRuleReturn | null = null;\n    let outerResult: ParseRuleReturn | null = null;\n    do {\n      // \"until\" condition hit?\n      if (untilTerminator !== null && this.Peek(untilTerminator) !== null) {\n        break;\n      }\n\n      // Main inner\n      lastMainResult = this.ParseObject(ruleB);\n      if (lastMainResult === null) {\n        break;\n      } else {\n        this.TryAddResultToList(lastMainResult, results, flatten);\n      }\n\n      // Outer result (i.e. last A in ABA)\n      outerResult = null;\n      if (lastMainResult !== null) {\n        outerResult = this.ParseObject(ruleA);\n\n        if (outerResult === null) {\n          break;\n        } else {\n          this.TryAddResultToList(outerResult, results, flatten);\n        }\n      }\n\n      // Stop if there are no results, or if both are the placeholder \"ParseSuccess\" (i.e. Optional success rather than a true value)\n    } while (\n      (lastMainResult !== null || outerResult !== null) &&\n      !(\n        (lastMainResult as any) === StringParser.ParseSuccess &&\n        outerResult == StringParser.ParseSuccess\n      ) &&\n      this.remainingLength > 0\n    );\n\n    if (results.length === 0) {\n      return this.FailRule(ruleId) as T[];\n    }\n\n    return this.SucceedRule(ruleId, results) as T[];\n  };\n\n  //--------------------------------\n  // Basic string parsing\n  //--------------------------------\n\n  public readonly ParseString = (str: string): string | null => {\n    if (str.length > this.remainingLength) {\n      return null;\n    }\n\n    const ruleId: number = this.BeginRule();\n\n    // Optimisation from profiling:\n    // Store in temporary local variables\n    // since they're properties that would have to access\n    // the rule stack every time otherwise.\n    let i: number = this.index;\n    let cli: number = this.characterInLineIndex;\n    let li: number = this.lineIndex;\n\n    let success: boolean = true;\n    for (let tempIdx = 0; tempIdx < str.length; tempIdx += 1) {\n      const c = str[tempIdx];\n\n      if (this._chars[i] !== c) {\n        success = false;\n        break;\n      }\n      if (c === \"\\n\") {\n        li++;\n        cli = -1;\n      }\n\n      i++;\n      cli++;\n    }\n\n    this.index = i;\n    this.characterInLineIndex = cli;\n    this.lineIndex = li;\n\n    if (success) {\n      return this.SucceedRule(ruleId, str) as any;\n    }\n\n    return this.FailRule(ruleId) as any;\n  };\n\n  public readonly ParseSingleCharacter = (): string => {\n    if (this.remainingLength > 0) {\n      const c = this._chars[this.index];\n      if (c === \"\\n\") {\n        this.lineIndex += 1;\n        this.characterInLineIndex = -1;\n      }\n\n      this.index += 1;\n      this.characterInLineIndex += 1;\n\n      return c;\n    }\n\n    return \"0\";\n  };\n\n  public readonly ParseUntilCharactersFromString = (\n    str: string,\n    maxCount: number = -1\n  ): string | null => this.ParseCharactersFromString(str, false, maxCount);\n\n  public readonly ParseUntilCharactersFromCharSet = (\n    charSet: CharacterSet,\n    maxCount: number = -1\n  ): string | null => this.ParseCharactersFromCharSet(charSet, false, maxCount);\n\n  public readonly ParseCharactersFromString = (\n    str: string,\n    maxCountOrShouldIncludeStrChars: boolean | number = -1,\n    maxCount: number = -1\n  ): string | null => {\n    const charSet = new CharacterSet(str);\n    if (typeof maxCountOrShouldIncludeStrChars === \"number\") {\n      return this.ParseCharactersFromCharSet(\n        charSet,\n        true,\n        maxCountOrShouldIncludeStrChars\n      );\n    }\n\n    return this.ParseCharactersFromCharSet(\n      charSet,\n      maxCountOrShouldIncludeStrChars,\n      maxCount\n    );\n  };\n\n  public readonly ParseCharactersFromCharSet = (\n    charSet: CharacterSet,\n    shouldIncludeChars: boolean = true,\n    maxCount: number = -1\n  ): string | null => {\n    if (maxCount === -1) {\n      maxCount = Number.MAX_SAFE_INTEGER;\n    }\n\n    const startIndex: number = this.index;\n\n    // Optimisation from profiling:\n    // Store in temporary local variables\n    // since they're properties that would have to access\n    // the rule stack every time otherwise.\n    let ii: number = this.index;\n    let cli: number = this.characterInLineIndex;\n    let li: number = this.lineIndex;\n    let count: number = 0;\n    while (\n      ii < this._chars.length &&\n      charSet.set.has(this._chars[ii]) === shouldIncludeChars &&\n      count < maxCount\n    ) {\n      if (this._chars[ii] === \"\\n\") {\n        li += 1;\n        cli = -1;\n      }\n\n      ii += 1;\n      cli += 1;\n      count += 1;\n    }\n\n    this.index = ii;\n    this.characterInLineIndex = cli;\n    this.lineIndex = li;\n\n    const lastCharIndex: number = this.index;\n    if (lastCharIndex > startIndex) {\n      return this._chars.slice(startIndex, this.index).join(\"\");\n    }\n\n    return null;\n  };\n\n  public readonly Peek = (rule: ParseRule): ParseRuleReturn => {\n    const ruleId: number = this.BeginRule();\n    const result: ParseRuleReturn = rule();\n    this.CancelRule(ruleId);\n\n    return result;\n  };\n\n  public ParseUntil(\n    stopRule: ParseRule,\n    pauseCharacters: CharacterSet | null = null,\n    endCharacters: CharacterSet | null = null\n  ): string {\n    const ruleId: number = this.BeginRule();\n    const pauseAndEnd: CharacterSet = new CharacterSet();\n    if (pauseCharacters !== null) {\n      pauseAndEnd.set = new Set([\n        ...pauseAndEnd.set.values(),\n        ...pauseCharacters.set.values(),\n      ]);\n    }\n\n    if (endCharacters !== null) {\n      pauseAndEnd.set = new Set([\n        ...pauseAndEnd.set.values(),\n        ...endCharacters.set.values(),\n      ]);\n    }\n\n    let parsedString = \"\";\n    let ruleResultAtPause: ParseRuleReturn | null = null;\n\n    // Keep attempting to parse strings up to the pause (and end) points.\n    //  - At each of the pause points, attempt to parse according to the rule\n    //  - When the end point is reached (or EOF), we're done\n    do {\n      // TODO: Perhaps if no pause or end characters are passed, we should check *every* character for stopRule?\n      const partialParsedString: string | null =\n        this.ParseUntilCharactersFromCharSet(pauseAndEnd);\n\n      if (partialParsedString) {\n        parsedString += partialParsedString;\n      }\n\n      // Attempt to run the parse rule at this pause point\n      ruleResultAtPause = this.Peek(stopRule);\n\n      // Rule completed - we're done\n      if (ruleResultAtPause !== null) {\n        break;\n      } else {\n        if (this.endOfInput) {\n          break;\n        }\n\n        // Reached a pause point, but rule failed. Step past and continue parsing string\n        const pauseCharacter: string = this.currentCharacter;\n        if (\n          pauseCharacters !== null &&\n          pauseCharacters.set.has(pauseCharacter)\n        ) {\n          parsedString += pauseCharacter;\n          if (pauseCharacter === \"\\n\") {\n            this.lineIndex += 1;\n            this.characterInLineIndex = -1;\n          }\n\n          this.index += 1;\n          this.characterInLineIndex += 1;\n\n          continue;\n        } else {\n          break;\n        }\n      }\n    } while (true);\n\n    if (parsedString.length > 0) {\n      return this.SucceedRule(ruleId, String(parsedString)) as string;\n    }\n\n    return this.FailRule(ruleId) as string;\n  }\n\n  // No need to Begin/End rule since we never parse a newline, so keeping oldIndex is good enough\n  public readonly ParseInt = (): number | null => {\n    const oldIndex: number = this.index;\n    const oldCharacterInLineIndex: number = this.characterInLineIndex;\n    const negative: boolean = this.ParseString(\"-\") !== null;\n\n    // Optional whitespace\n    this.ParseCharactersFromString(\" \\t\");\n\n    const parsedString = this.ParseCharactersFromCharSet(\n      StringParser.numbersCharacterSet\n    );\n    if (parsedString === null) {\n      // Roll back and fail\n      this.index = oldIndex;\n      this.characterInLineIndex = oldCharacterInLineIndex;\n\n      return null;\n    }\n\n    let parsedInt: number;\n    if (!Number.isNaN(Number(parsedString))) {\n      parsedInt = Number(parsedString);\n      return negative ? -parsedInt : parsedInt;\n    }\n\n    this.Error(\n      \"Failed to read integer value: \" +\n        parsedString +\n        \". Perhaps it's out of the range of acceptable numbers ink supports? (\" +\n        Number.MIN_SAFE_INTEGER +\n        \" to \" +\n        Number.MAX_SAFE_INTEGER +\n        \")\"\n    );\n\n    return null;\n  };\n\n  // No need to Begin/End rule since we never parse a newline, so keeping oldIndex is good enough\n  public readonly ParseFloat = (): number | null => {\n    const oldIndex: number = this.index;\n    const oldCharacterInLineIndex: number = this.characterInLineIndex;\n\n    const leadingInt: number | null = this.ParseInt();\n    if (leadingInt !== null) {\n      if (this.ParseString(\".\") !== null) {\n        const afterDecimalPointStr = this.ParseCharactersFromCharSet(\n          StringParser.numbersCharacterSet\n        );\n\n        return Number(`${leadingInt}.${afterDecimalPointStr}`);\n      }\n    }\n\n    // Roll back and fail\n    this.index = oldIndex;\n    this.characterInLineIndex = oldCharacterInLineIndex;\n\n    return null;\n  };\n\n  public readonly ParseNewline = (): string => {\n    const ruleId: number = this.BeginRule();\n\n    // Optional \\r, definite \\n to support Windows (\\r\\n) and Mac/Unix (\\n)\n    // 2nd May 2016: Always collapse \\r\\n to just \\n\n    this.ParseString(\"\\r\");\n\n    if (this.ParseString(\"\\n\") === null) {\n      return this.FailRule(ruleId) as string;\n    }\n\n    return this.SucceedRule(ruleId, \"\\n\") as string;\n  };\n}\n","import { CharacterSet } from \"./CharacterSet\";\nimport { StringParser } from \"./StringParser/StringParser\";\n\n/// <summary>\n/// Pre-pass before main ink parser runs. It actually performs two main tasks:\n///  - comment elimination to simplify the parse rules in the main parser\n///  - Conversion of Windows line endings (\\r\\n) to the simpler Unix style (\\n), so\n///    we don't have to worry about them later.\n/// </summary>\nexport class CommentEliminator extends StringParser {\n  public _commentOrNewlineStartCharacter = new CharacterSet(\"/\\r\\n\");\n  public _commentBlockEndCharacter = new CharacterSet(\"*\");\n  public _newlineCharacters = new CharacterSet(\"\\n\\r\");\n\n  public readonly Process = (): string => {\n    // Make both comments and non-comments optional to handle trivial empty file case (or *only* comments)\n    const stringList: string[] = this.Interleave<string>(\n      this.Optional(this.CommentsAndNewlines),\n      this.Optional(this.MainInk)\n    );\n\n    if (stringList !== null) {\n      return stringList.join(\"\");\n    } else {\n      return \"\";\n    }\n  };\n\n  public readonly MainInk = () =>\n    this.ParseUntil(\n      this.CommentsAndNewlines,\n      this._commentOrNewlineStartCharacter,\n      null\n    );\n\n  public readonly CommentsAndNewlines = () => {\n    let newLines: string[] = this.Interleave<string>(\n      this.Optional(this.ParseNewline),\n      this.Optional(this.ParseSingleComment)\n    );\n\n    if (newLines !== null) {\n      return newLines.join(\"\");\n    }\n\n    return null;\n  };\n\n  // Valid comments always return either an empty string or pure newlines,\n  // which we want to keep so that line numbers stay the same\n  public readonly ParseSingleComment = () =>\n    this.OneOf([this.EndOfLineComment, this.BlockComment]);\n\n  public readonly EndOfLineComment = () => {\n    if (this.ParseString(\"//\") === null) {\n      return null;\n    }\n\n    this.ParseUntilCharactersFromCharSet(this._newlineCharacters);\n\n    return \"\";\n  };\n\n  public readonly BlockComment = () => {\n    if (this.ParseString(\"/*\") === null) {\n      return null;\n    }\n\n    const startLineIndex: number = this.lineIndex;\n    const commentResult = this.ParseUntil(\n      this.String(\"*/\"),\n      this._commentBlockEndCharacter,\n      null\n    );\n\n    if (!this.endOfInput) {\n      this.ParseString(\"*/\");\n    }\n\n    // Count the number of lines that were inside the block, and replicate them as newlines\n    // so that the line indexing still works from the original source\n    if (commentResult != null) {\n      return \"\\n\".repeat(this.lineIndex - startLineIndex);\n    }\n\n    // No comment at all\n    return null;\n  };\n\n  public PreProcessInputString(str: string): string {\n    return str;\n  }\n}\n","export enum FlowLevel {\n  Story, // 0\n  Knot, // 1\n  Stitch, // 2\n  // not actually a FlowBase, but used for diverts\n  WeavePoint, // 3\n}\n","import { ConditionalSingleBranch } from \"./ConditionalSingleBranch\";\nimport { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../../engine/ControlCommand\";\nimport { Expression } from \"../Expression/Expression\";\nimport { ParsedObject } from \"../Object\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\nimport { Story } from \"../Story\";\n\nexport class Conditional extends ParsedObject {\n  private _reJoinTarget: RuntimeControlCommand | null = null;\n\n  constructor(\n    public initialCondition: Expression,\n    public branches: ConditionalSingleBranch[]\n  ) {\n    super();\n\n    if (this.initialCondition) {\n      this.AddContent(this.initialCondition);\n    }\n\n    if (this.branches !== null) {\n      this.AddContent(this.branches);\n    }\n  }\n\n  get typeName(): string {\n    return \"Conditional\";\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    const container = new RuntimeContainer();\n\n    // Initial condition\n    if (this.initialCondition) {\n      container.AddContent(this.initialCondition.runtimeObject);\n    }\n\n    // Individual branches\n    for (const branch of this.branches) {\n      const branchContainer = branch.runtimeObject;\n      container.AddContent(branchContainer);\n    }\n\n    // If it's a switch-like conditional, each branch\n    // will have a \"duplicate\" operation for the original\n    // switched value. If there's no final else clause\n    // and we fall all the way through, we need to clean up.\n    // (An else clause doesn't dup but it *does* pop)\n    if (\n      this.initialCondition !== null &&\n      this.branches[0].ownExpression !== null &&\n      !this.branches[this.branches.length - 1].isElse\n    ) {\n      container.AddContent(RuntimeControlCommand.PopEvaluatedValue());\n    }\n\n    // Target for branches to rejoin to\n    this._reJoinTarget = RuntimeControlCommand.NoOp();\n    container.AddContent(this._reJoinTarget);\n\n    return container;\n  };\n\n  public ResolveReferences(context: Story): void {\n    const pathToReJoin = this._reJoinTarget!.path;\n\n    for (const branch of this.branches) {\n      if (!branch.returnDivert) {\n        throw new Error();\n      }\n\n      branch.returnDivert.targetPath = pathToReJoin;\n    }\n\n    super.ResolveReferences(context);\n  }\n}\n","﻿import { ParsedObject } from \"./Object\";\nimport { InkObject as RuntimeObject } from \"../../../engine/Object\";\nimport { StringValue } from \"../../../engine/Value\";\n\nexport class Text extends ParsedObject {\n  constructor(public text: string) {\n    super();\n  }\n  get typeName(): string {\n    return \"Text\";\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject =>\n    new StringValue(this.text);\n\n  public readonly toString = (): string => this.text;\n}\n","import { Expression } from \"../Expression/Expression\";\nimport { ParsedObject } from \"../Object\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\nimport { Story } from \"../Story\";\nimport { SymbolType } from \"../SymbolType\";\nimport { Identifier } from \"../Identifier\";\n\nexport class ConstantDeclaration extends ParsedObject {\n  get constantName(): string | undefined {\n    return this.constantIdentifier?.name;\n  }\n  public constantIdentifier: Identifier;\n\n  private _expression: Expression | null = null;\n\n  get expression(): Expression {\n    if (!this._expression) {\n      throw new Error();\n    }\n\n    return this._expression;\n  }\n\n  constructor(name: Identifier, assignedExpression: Expression) {\n    super();\n\n    this.constantIdentifier = name;\n\n    // Defensive programming in case parsing of assignedExpression failed\n    if (assignedExpression) {\n      this._expression = this.AddContent(assignedExpression) as Expression;\n    }\n  }\n\n  get typeName(): string {\n    return \"CONST\";\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject | null => {\n    // Global declarations don't generate actual procedural\n    // runtime objects, but instead add a global variable to the story itself.\n    // The story then initialises them all in one go at the start of the game.\n    return null;\n  };\n\n  public ResolveReferences(context: Story) {\n    super.ResolveReferences(context);\n    context.CheckForNamingCollisions(\n      this,\n      this.constantIdentifier,\n      SymbolType.Var\n    );\n  }\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { INamedContent } from \"../../../../engine/INamedContent\";\nimport { IWeavePoint } from \"../IWeavePoint\";\nimport { ParsedObject } from \"../Object\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\nimport { Story } from \"../Story\";\nimport { SymbolType } from \"../SymbolType\";\nimport { Identifier } from \"../Identifier\";\n\nexport class Gather extends ParsedObject implements INamedContent, IWeavePoint {\n  get name(): string | null {\n    return this.identifier?.name || null;\n  }\n  public identifier?: Identifier;\n\n  get runtimeContainer(): RuntimeContainer {\n    return this.runtimeObject as RuntimeContainer;\n  }\n\n  constructor(\n    identifier: Identifier | null,\n    public readonly indentationDepth: number\n  ) {\n    super();\n\n    if (identifier) this.identifier = identifier;\n  }\n\n  get typeName(): string {\n    return \"Gather\";\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    const container = new RuntimeContainer();\n    container.name = this.name;\n\n    if (this.story.countAllVisits) {\n      container.visitsShouldBeCounted = true;\n    }\n\n    container.countingAtStartOnly = true;\n\n    // A gather can have null content, e.g. it's just purely a line with \"-\"\n    if (this.content) {\n      for (const c of this.content) {\n        container.AddContent(c.runtimeObject);\n      }\n    }\n\n    return container;\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    if (this.identifier && (this.identifier.name || \"\").length > 0) {\n      context.CheckForNamingCollisions(\n        this,\n        this.identifier,\n        SymbolType.SubFlowAndWeave\n      );\n    }\n  }\n\n  public readonly toString = (): string =>\n    `- ${this.identifier?.name ? \"(\" + this.identifier?.name + \")\" : \"gather\"}`;\n}\n","import { asOrNull, filterUndef } from \"../../../engine/TypeAssertion\";\nimport { FlowBase } from \"./Flow/FlowBase\";\nimport { FlowLevel } from \"./Flow/FlowLevel\";\nimport { Identifier } from \"./Identifier\";\nimport { ParsedObject } from \"./Object\";\nimport { Weave } from \"./Weave\";\n\nexport class Path {\n  private _baseTargetLevel: FlowLevel | null;\n  private components: Identifier[] | null;\n\n  get baseTargetLevel() {\n    if (this.baseLevelIsAmbiguous) {\n      return FlowLevel.Story;\n    }\n\n    return this._baseTargetLevel;\n  }\n\n  get baseLevelIsAmbiguous(): boolean {\n    return !this._baseTargetLevel;\n  }\n\n  get firstComponent(): string | null {\n    if (this.components == null || !this.components.length) {\n      return null;\n    }\n\n    return this.components[0].name;\n  }\n\n  get numberOfComponents(): number {\n    return this.components ? this.components.length : 0;\n  }\n\n  private _dotSeparatedComponents: string | null = null;\n\n  get dotSeparatedComponents(): string {\n    if (this._dotSeparatedComponents == null) {\n      this._dotSeparatedComponents = (this.components ? this.components : [])\n        .map((c) => c.name)\n        .filter(filterUndef)\n        .join(\".\");\n    }\n    return this._dotSeparatedComponents;\n  }\n\n  constructor(\n    argOne: FlowLevel | Identifier[] | Identifier,\n    argTwo?: Identifier[]\n  ) {\n    if (Object.values(FlowLevel).includes(argOne as FlowLevel)) {\n      this._baseTargetLevel = argOne as FlowLevel;\n      this.components = argTwo || [];\n    } else if (Array.isArray(argOne)) {\n      this._baseTargetLevel = null;\n      this.components = argOne || [];\n    } else {\n      this._baseTargetLevel = null;\n      this.components = [argOne as Identifier];\n    }\n  }\n\n  get typeName(): string {\n    return \"Path\";\n  }\n\n  public readonly toString = (): string => {\n    if (this.components === null || this.components.length === 0) {\n      if (this.baseTargetLevel === FlowLevel.WeavePoint) {\n        return \"-> <next gather point>\";\n      }\n\n      return \"<invalid Path>\";\n    }\n\n    return `-> ${this.dotSeparatedComponents}`;\n  };\n\n  public readonly ResolveFromContext = (\n    context: ParsedObject\n  ): ParsedObject | null => {\n    if (this.components == null || this.components.length == 0) {\n      return null;\n    }\n\n    // Find base target of path from current context. e.g.\n    //   ==> BASE.sub.sub\n    let baseTargetObject = this.ResolveBaseTarget(context);\n    if (baseTargetObject === null) {\n      return null;\n    }\n\n    // Given base of path, resolve final target by working deeper into hierarchy\n    //  e.g. ==> base.mid.FINAL\n    if (this.components.length > 1) {\n      return this.ResolveTailComponents(baseTargetObject);\n    }\n\n    return baseTargetObject;\n  };\n\n  // Find the root object from the base, i.e. root from:\n  //    root.sub1.sub2\n  public readonly ResolveBaseTarget = (\n    originalContext: ParsedObject\n  ): ParsedObject | null => {\n    const firstComp = this.firstComponent;\n\n    // Work up the ancestry to find the node that has the named object\n    let ancestorContext: ParsedObject | null = originalContext;\n    while (ancestorContext) {\n      // Only allow deep search when searching deeper from original context.\n      // Don't allow search upward *then* downward, since that's searching *everywhere*!\n      // Allowed examples:\n      //  - From an inner gather of a stitch, you should search up to find a knot called 'x'\n      //    at the root of a story, but not a stitch called 'x' in that knot.\n      //  - However, from within a knot, you should be able to find a gather/choice\n      //    anywhere called 'x'\n      // (that latter example is quite loose, but we allow it)\n      const deepSearch: boolean = ancestorContext === originalContext;\n\n      const foundBase = this.GetChildFromContext(\n        ancestorContext,\n        firstComp,\n        null,\n        deepSearch\n      );\n\n      if (foundBase) {\n        return foundBase;\n      }\n\n      ancestorContext = ancestorContext.parent;\n    }\n\n    return null;\n  };\n\n  // Find the final child from path given root, i.e.:\n  //   root.sub.finalChild\n  public readonly ResolveTailComponents = (\n    rootTarget: ParsedObject\n  ): ParsedObject | null => {\n    let foundComponent: ParsedObject | null = rootTarget;\n\n    if (!this.components) return null;\n\n    for (let ii = 1; ii < this.components.length; ++ii) {\n      const compName = this.components[ii].name;\n\n      let minimumExpectedLevel: FlowLevel;\n      let foundFlow = asOrNull(foundComponent, FlowBase);\n      if (foundFlow !== null) {\n        minimumExpectedLevel = (foundFlow.flowLevel + 1) as FlowLevel;\n      } else {\n        minimumExpectedLevel = FlowLevel.WeavePoint;\n      }\n\n      foundComponent = this.GetChildFromContext(\n        foundComponent,\n        compName,\n        minimumExpectedLevel\n      );\n\n      if (foundComponent === null) {\n        break;\n      }\n    }\n\n    return foundComponent;\n  };\n\n  // See whether \"context\" contains a child with a given name at a given flow level\n  // Can either be a named knot/stitch (a FlowBase) or a weave point within a Weave (Choice or Gather)\n  // This function also ignores any other object types that are neither FlowBase nor Weave.\n  // Called from both ResolveBase (force deep) and ResolveTail for the individual components.\n  public readonly GetChildFromContext = (\n    context: ParsedObject,\n    childName: string | null,\n    minimumLevel: FlowLevel | null,\n    forceDeepSearch: boolean = false\n  ): ParsedObject | null => {\n    // null childLevel means that we don't know where to find it\n    const ambiguousChildLevel: boolean = minimumLevel === null;\n\n    // Search for WeavePoint within Weave\n    const weaveContext = asOrNull(context, Weave);\n    if (\n      childName &&\n      weaveContext !== null &&\n      (ambiguousChildLevel || minimumLevel === FlowLevel.WeavePoint)\n    ) {\n      return weaveContext.WeavePointNamed(childName) as ParsedObject;\n    }\n\n    // Search for content within Flow (either a sub-Flow or a WeavePoint)\n    let flowContext = asOrNull(context, FlowBase);\n    if (childName && flowContext !== null) {\n      // When searching within a Knot, allow a deep searches so that\n      // named weave points (choices and gathers) can be found within any stitch\n      // Otherwise, we just search within the immediate object.\n      const shouldDeepSearch =\n        forceDeepSearch || flowContext.flowLevel === FlowLevel.Knot;\n\n      return flowContext.ContentWithNameAtLevel(\n        childName,\n        minimumLevel,\n        shouldDeepSearch\n      );\n    }\n\n    return null;\n  };\n}\n","import { Expression } from \"./Expression/Expression\";\nimport { ParsedObject } from \"./Object\";\nimport { Container as RuntimeContainer } from \"../../../engine/Container\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../engine/ControlCommand\";\nimport { InkObject as RuntimeObject } from \"../../../engine/Object\";\nimport { Void } from \"../../../engine/Void\";\n\nexport class ReturnType extends ParsedObject {\n  public returnedExpression: Expression | null = null;\n\n  constructor(returnedExpression: Expression | null = null) {\n    super();\n\n    if (returnedExpression) {\n      this.returnedExpression = this.AddContent(\n        returnedExpression\n      ) as Expression;\n    }\n  }\n\n  get typeName(): string {\n    return \"ReturnType\";\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    const container = new RuntimeContainer();\n\n    if (this.returnedExpression) {\n      // Evaluate expression\n      container.AddContent(this.returnedExpression.runtimeObject);\n    } else {\n      // Return Runtime.Void when there's no expression to evaluate\n      // (This evaluation will just add the Void object to the evaluation stack)\n      container.AddContent(RuntimeControlCommand.EvalStart());\n      container.AddContent(new Void());\n      container.AddContent(RuntimeControlCommand.EvalEnd());\n    }\n\n    // Then pop the call stack\n    // (the evaluated expression will leave the return value on the evaluation stack)\n    container.AddContent(RuntimeControlCommand.PopFunction());\n\n    return container;\n  };\n}\n","// import { FlowBase } from './FlowBase';\n\nexport function ClosestFlowBase(obj: any): any | null {\n  let ancestor = obj.parent;\n  while (ancestor) {\n    if (ancestor.hasOwnProperty(\"iamFlowbase\") && ancestor.iamFlowbase()) {\n      return ancestor as any;\n    }\n\n    ancestor = ancestor.parent;\n  }\n\n  return null;\n}\n","import { DebugMetadata } from \"../../../engine/DebugMetadata\";\n\nexport class Identifier {\n  public name: string;\n  public debugMetadata: DebugMetadata | null = null;\n\n  constructor(name: string) {\n    this.name = name;\n  }\n\n  get typeName(): string {\n    return \"Identifier\";\n  }\n\n  public static Done(): Identifier {\n    return new Identifier(\"DONE\");\n  }\n\n  public readonly toString = (): string => this.name || \"undefined identifer\";\n}\n","import { Argument } from \"../Argument\";\nimport { Choice } from \"../Choice\";\nimport { Divert } from \"../Divert/Divert\";\nimport { DivertTarget } from \"../Divert/DivertTarget\";\nimport { FlowLevel } from \"./FlowLevel\";\nimport { Gather } from \"../Gather/Gather\";\nimport { INamedContent } from \"../../../../engine/INamedContent\";\n// import { Knot } from '../Knot';\nimport { ParsedObject } from \"../Object\";\nimport { Path } from \"../Path\";\nimport { ReturnType } from \"../ReturnType\";\nimport { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { Divert as RuntimeDivert } from \"../../../../engine/Divert\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\nimport { VariableAssignment as RuntimeVariableAssignment } from \"../../../../engine/VariableAssignment\";\n//import { Story } from '../Story';\nimport { SymbolType } from \"../SymbolType\";\nimport { VariableAssignment } from \"../Variable/VariableAssignment\";\nimport { Weave } from \"../Weave\";\nimport { ClosestFlowBase } from \"./ClosestFlowBase\";\nimport { Identifier } from \"../Identifier\";\nimport { asOrNull } from \"../../../../engine/TypeAssertion\";\n\ntype VariableResolveResult = {\n  found: boolean;\n  isGlobal: boolean;\n  isArgument: boolean;\n  isTemporary: boolean;\n  ownerFlow: FlowBase;\n};\n\n// Base class for Knots and Stitches\nexport abstract class FlowBase extends ParsedObject implements INamedContent {\n  public abstract readonly flowLevel: FlowLevel;\n\n  public _rootWeave: Weave | null = null;\n  public _subFlowsByName: Map<string, FlowBase> = new Map();\n  public _startingSubFlowDivert: RuntimeDivert | null = null;\n  public _startingSubFlowRuntime: RuntimeObject | null = null;\n  public _firstChildFlow: FlowBase | null = null;\n  public variableDeclarations: Map<string, VariableAssignment> = new Map();\n\n  get hasParameters() {\n    return this.args !== null && this.args.length > 0;\n  }\n\n  get subFlowsByName() {\n    return this._subFlowsByName;\n  }\n\n  get typeName(): string {\n    if (this.isFunction) {\n      return \"Function\";\n    }\n\n    return String(this.flowLevel);\n  }\n\n  get name(): string | null {\n    return this.identifier?.name || null;\n  }\n\n  public identifier: Identifier | null = null;\n  public args: Argument[] | null = null;\n\n  constructor(\n    identifier: Identifier | null,\n    topLevelObjects: ParsedObject[] | null = null,\n    args: Argument[] | null = null,\n    public readonly isFunction: boolean = false,\n    isIncludedStory: boolean = false\n  ) {\n    super();\n\n    this.identifier = identifier;\n    this.args = args;\n\n    if (topLevelObjects === null) {\n      topLevelObjects = [];\n    }\n\n    // Used by story to add includes\n    this.PreProcessTopLevelObjects(topLevelObjects);\n\n    topLevelObjects = this.SplitWeaveAndSubFlowContent(\n      topLevelObjects,\n      this.GetType() == \"Story\" && !isIncludedStory\n    );\n\n    this.AddContent(topLevelObjects);\n  }\n\n  public iamFlowbase = () => true;\n\n  public readonly SplitWeaveAndSubFlowContent = (\n    contentObjs: ParsedObject[],\n    isRootStory: boolean\n  ): ParsedObject[] => {\n    const weaveObjs: ParsedObject[] = [];\n    const subFlowObjs: ParsedObject[] = [];\n\n    this._subFlowsByName = new Map();\n\n    for (const obj of contentObjs) {\n      const subFlow = asOrNull(obj, FlowBase);\n      if (subFlow) {\n        if (this._firstChildFlow === null) {\n          this._firstChildFlow = subFlow;\n        }\n\n        subFlowObjs.push(obj);\n        if (subFlow.identifier?.name) {\n          this._subFlowsByName.set(subFlow.identifier?.name, subFlow);\n        }\n      } else {\n        weaveObjs.push(obj);\n      }\n    }\n\n    // Implicit final gather in top level story for ending without warning that you run out of content\n    if (isRootStory) {\n      weaveObjs.push(\n        new Gather(null, 1),\n        new Divert(new Path(Identifier.Done()))\n      );\n    }\n\n    const finalContent: ParsedObject[] = [];\n\n    if (weaveObjs.length > 0) {\n      this._rootWeave = new Weave(weaveObjs, 0);\n      finalContent.push(this._rootWeave);\n    }\n\n    if (subFlowObjs.length > 0) {\n      finalContent.push(...subFlowObjs);\n    }\n    return finalContent;\n  };\n\n  public PreProcessTopLevelObjects(_: ParsedObject[]): void {\n    // empty by default, used by Story to process included file references\n  }\n\n  public VariableResolveResult?: VariableResolveResult | null | undefined;\n\n  public ResolveVariableWithName = (\n    varName: string,\n    fromNode: ParsedObject\n  ): VariableResolveResult => {\n    const result: VariableResolveResult = {} as any;\n\n    // Search in the stitch / knot that owns the node first\n    const ownerFlow = fromNode === null ? this : ClosestFlowBase(fromNode);\n\n    if (ownerFlow) {\n      // Argument\n      if (ownerFlow.args !== null) {\n        for (const arg of ownerFlow.args) {\n          if (arg.identifier?.name === varName) {\n            result.found = true;\n            result.isArgument = true;\n            result.ownerFlow = ownerFlow;\n            return result;\n          }\n        }\n      }\n\n      // Temp\n      if (\n        ownerFlow !== this.story &&\n        ownerFlow.variableDeclarations.has(varName)\n      ) {\n        result.found = true;\n        result.ownerFlow = ownerFlow;\n        result.isTemporary = true;\n\n        return result;\n      }\n    }\n\n    // Global\n    if (this.story.variableDeclarations.has(varName)) {\n      result.found = true;\n      result.ownerFlow = this.story;\n      result.isGlobal = true;\n\n      return result;\n    }\n\n    result.found = false;\n\n    return result;\n  };\n\n  public AddNewVariableDeclaration = (varDecl: VariableAssignment): void => {\n    const varName = varDecl.variableName;\n    if (this.variableDeclarations.has(varName)) {\n      const varab = this.variableDeclarations.get(varName)!;\n      let prevDeclError = \"\";\n      const debugMetadata = varab.debugMetadata;\n      if (debugMetadata) {\n        prevDeclError = ` (${varab.debugMetadata})`;\n      }\n\n      this.Error(\n        `found declaration variable '${varName}' that was already declared${prevDeclError}`,\n        varDecl,\n        false\n      );\n\n      return;\n    }\n\n    this.variableDeclarations.set(varDecl.variableName, varDecl);\n  };\n\n  public ResolveWeavePointNaming = (): void => {\n    // Find all weave points and organise them by name ready for\n    // diverting. Also detect naming collisions.\n    if (this._rootWeave) {\n      this._rootWeave.ResolveWeavePointNaming();\n    }\n\n    for (const [, value] of this._subFlowsByName) {\n      if (value.hasOwnProperty(\"ResolveWeavePointNaming\")) {\n        value.ResolveWeavePointNaming();\n      }\n    }\n  };\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    let foundReturn: ReturnType | null = null;\n    if (this.isFunction) {\n      this.CheckForDisallowedFunctionFlowControl();\n    } else if (\n      this.flowLevel === FlowLevel.Knot ||\n      this.flowLevel === FlowLevel.Stitch\n    ) {\n      // Non-functon: Make sure knots and stitches don't attempt to use Return statement\n      foundReturn = this.Find(ReturnType)();\n\n      if (foundReturn !== null) {\n        this.Error(\n          `Return statements can only be used in knots that are declared as functions: == function ${this.identifier} ==`,\n          foundReturn\n        );\n      }\n    }\n\n    const container = new RuntimeContainer();\n    container.name = this.identifier?.name as string;\n\n    if (this.story.countAllVisits) {\n      container.visitsShouldBeCounted = true;\n    }\n\n    this.GenerateArgumentVariableAssignments(container);\n\n    // Run through content defined for this knot/stitch:\n    //  - First of all, any initial content before a sub-stitch\n    //    or any weave content is added to the main content container\n    //  - The first inner knot/stitch is automatically entered, while\n    //    the others are only accessible by an explicit divert\n    //       - The exception to this rule is if the knot/stitch takes\n    //         parameters, in which case it can't be auto-entered.\n    //  - Any Choices and Gathers (i.e. IWeavePoint) found are\n    //    processsed by GenerateFlowContent.\n    let contentIdx: number = 0;\n    while (this.content !== null && contentIdx < this.content.length) {\n      const obj: ParsedObject = this.content[contentIdx];\n\n      // Inner knots and stitches\n      if (obj instanceof FlowBase) {\n        const childFlow: FlowBase = obj;\n        const childFlowRuntime = childFlow.runtimeObject;\n\n        // First inner stitch - automatically step into it\n        // 20/09/2016 - let's not auto step into knots\n        if (\n          contentIdx === 0 &&\n          !childFlow.hasParameters &&\n          this.flowLevel === FlowLevel.Knot\n        ) {\n          this._startingSubFlowDivert = new RuntimeDivert();\n          container.AddContent(this._startingSubFlowDivert);\n          this._startingSubFlowRuntime = childFlowRuntime;\n        }\n\n        // Check for duplicate knots/stitches with same name\n        const namedChild = childFlowRuntime as RuntimeObject & INamedContent;\n        const existingChild: INamedContent | null =\n          container.namedContent.get(namedChild.name!) || null;\n\n        if (existingChild) {\n          const errorMsg = `${this.GetType()} already contains flow named '${\n            namedChild.name\n          }' (at ${(existingChild as any as RuntimeObject).debugMetadata})`;\n          this.Error(errorMsg, childFlow);\n        }\n\n        container.AddToNamedContentOnly(namedChild);\n      } else if (obj) {\n        // Other content (including entire Weaves that were grouped in the constructor)\n        // At the time of writing, all FlowBases have a maximum of one piece of \"other content\"\n        // and it's always the root Weave\n        container.AddContent(obj.runtimeObject);\n      }\n\n      contentIdx += 1;\n    }\n\n    // CHECK FOR FINAL LOOSE ENDS!\n    // Notes:\n    //  - Functions don't need to terminate - they just implicitly return\n    //  - If return statement was found, don't continue finding warnings for missing control flow,\n    // since it's likely that a return statement has been used instead of a ->-> or something,\n    // or the writer failed to mark the knot as a function.\n    //  - _rootWeave may be null if it's a knot that only has stitches\n    if (\n      this.flowLevel !== FlowLevel.Story &&\n      !this.isFunction &&\n      this._rootWeave !== null &&\n      foundReturn === null\n    ) {\n      this._rootWeave.ValidateTermination(this.WarningInTermination);\n    }\n\n    return container;\n  };\n\n  public readonly GenerateArgumentVariableAssignments = (\n    container: RuntimeContainer\n  ): void => {\n    if (this.args === null || this.args.length === 0) {\n      return;\n    }\n\n    // Assign parameters in reverse since they'll be popped off the evaluation stack\n    // No need to generate EvalStart and EvalEnd since there's nothing being pushed\n    // back onto the evaluation stack.\n    for (let ii = this.args.length - 1; ii >= 0; --ii) {\n      const paramName = this.args[ii].identifier?.name || null;\n      const assign = new RuntimeVariableAssignment(paramName, true);\n      container.AddContent(assign);\n    }\n  };\n\n  public readonly ContentWithNameAtLevel = (\n    name: string,\n    level: FlowLevel | null = null,\n    deepSearch: boolean = false\n  ): ParsedObject | null => {\n    // Referencing self?\n    if (level === this.flowLevel || level === null) {\n      if (name === this.identifier?.name) {\n        return this;\n      }\n    }\n\n    if (level === FlowLevel.WeavePoint || level === null) {\n      let weavePointResult: ParsedObject | null = null;\n\n      if (this._rootWeave) {\n        weavePointResult = this._rootWeave.WeavePointNamed(\n          name\n        ) as ParsedObject;\n        if (weavePointResult) {\n          return weavePointResult;\n        }\n      }\n\n      // Stop now if we only wanted a result if it's a weave point?\n      if (level === FlowLevel.WeavePoint) {\n        return deepSearch ? this.DeepSearchForAnyLevelContent(name) : null;\n      }\n    }\n\n    // If this flow would be incapable of containing the requested level, early out\n    // (e.g. asking for a Knot from a Stitch)\n    if (level !== null && level < this.flowLevel) {\n      return null;\n    }\n\n    let subFlow: FlowBase | null = this._subFlowsByName.get(name) || null;\n\n    if (subFlow && (level === null || level === subFlow.flowLevel)) {\n      return subFlow;\n    }\n\n    return deepSearch ? this.DeepSearchForAnyLevelContent(name) : null;\n  };\n\n  public readonly DeepSearchForAnyLevelContent = (name: string) => {\n    const weaveResultSelf = this.ContentWithNameAtLevel(\n      name,\n      FlowLevel.WeavePoint,\n      false\n    );\n\n    if (weaveResultSelf) {\n      return weaveResultSelf;\n    }\n\n    for (const [, value] of this._subFlowsByName) {\n      const deepResult = value.ContentWithNameAtLevel(name, null, true);\n\n      if (deepResult) {\n        return deepResult;\n      }\n    }\n\n    return null;\n  };\n\n  public ResolveReferences(context: any): void {\n    if (this._startingSubFlowDivert) {\n      if (!this._startingSubFlowRuntime) {\n        throw new Error();\n      }\n\n      this._startingSubFlowDivert.targetPath =\n        this._startingSubFlowRuntime.path;\n    }\n\n    super.ResolveReferences(context);\n\n    // Check validity of parameter names\n    if (this.args !== null) {\n      for (const arg of this.args) {\n        context.CheckForNamingCollisions(\n          this,\n          arg.identifier,\n          SymbolType.Arg,\n          \"argument\"\n        );\n      }\n\n      // Separately, check for duplicate arugment names, since they aren't Parsed.Objects,\n      // so have to be checked independently.\n      for (let ii = 0; ii < this.args.length; ii += 1) {\n        for (let jj = ii + 1; jj < this.args.length; jj += 1) {\n          if (\n            this.args[ii].identifier?.name == this.args[jj].identifier?.name\n          ) {\n            this.Error(\n              `Multiple arguments with the same name: '${this.args[ii].identifier}'`\n            );\n          }\n        }\n      }\n    }\n\n    // Check naming collisions for knots and stitches\n    if (this.flowLevel !== FlowLevel.Story) {\n      // Weave points aren't FlowBases, so this will only be knot or stitch\n      const symbolType =\n        this.flowLevel === FlowLevel.Knot\n          ? SymbolType.Knot\n          : SymbolType.SubFlowAndWeave;\n\n      context.CheckForNamingCollisions(this, this.identifier, symbolType);\n    }\n  }\n\n  public readonly CheckForDisallowedFunctionFlowControl = (): void => {\n    // if (!(this instanceof Knot)) { // cannont use Knot here because of circular dependancy\n    if (this.flowLevel !== FlowLevel.Knot) {\n      this.Error(\n        \"Functions cannot be stitches - i.e. they should be defined as '== function myFunc ==' rather than internal to another knot.\"\n      );\n    }\n\n    // Not allowed sub-flows\n    for (const [key, value] of this._subFlowsByName) {\n      this.Error(\n        `Functions may not contain stitches, but saw '${key}' within the function '${this.identifier}'`,\n        value\n      );\n    }\n\n    if (!this._rootWeave) {\n      throw new Error();\n    }\n\n    const allDiverts = this._rootWeave.FindAll<Divert>(Divert)();\n    for (const divert of allDiverts) {\n      if (!divert.isFunctionCall && !(divert.parent instanceof DivertTarget)) {\n        this.Error(\n          `Functions may not contain diverts, but saw '${divert}'`,\n          divert\n        );\n      }\n    }\n\n    const allChoices = this._rootWeave.FindAll<Choice>(Choice)();\n    for (const choice of allChoices) {\n      this.Error(\n        `Functions may not contain choices, but saw '${choice}'`,\n        choice\n      );\n    }\n  };\n\n  public readonly WarningInTermination = (terminatingObject: ParsedObject) => {\n    let message: string =\n      \"Apparent loose end exists where the flow runs out. Do you need a '-> DONE' statement, choice or divert?\";\n    if (terminatingObject.parent === this._rootWeave && this._firstChildFlow) {\n      message = `${message} Note that if you intend to enter '${this._firstChildFlow.identifier}' next, you need to divert to it explicitly.`;\n    }\n\n    const terminatingDivert = asOrNull(terminatingObject, Divert);\n    if (terminatingDivert && terminatingDivert.isTunnel) {\n      message += ` When final tunnel to '${terminatingDivert.target} ->' returns it won't have anywhere to go.`;\n    }\n\n    this.Warning(message, terminatingObject);\n  };\n\n  public readonly toString = (): string =>\n    `${this.typeName} '${this.identifier}'`;\n}\n","import { Container as RuntimeContainer } from \"../../../engine/Container\";\nimport { ParsedObject } from \"./Object\";\nimport { InkObject as RuntimeObject } from \"../../../engine/Object\";\nimport { Text } from \"./Text\";\nimport { asOrNull } from \"../../../engine/TypeAssertion\";\n\nexport class ContentList extends ParsedObject {\n  public dontFlatten: boolean = false;\n\n  get runtimeContainer(): RuntimeContainer {\n    return this.runtimeObject as RuntimeContainer;\n  }\n\n  constructor(objects?: ParsedObject[], ...moreObjects: ParsedObject[]) {\n    super();\n\n    if (objects) {\n      this.AddContent(objects);\n    }\n\n    if (moreObjects) {\n      this.AddContent(moreObjects);\n    }\n  }\n\n  get typeName(): string {\n    return \"ContentList\";\n  }\n\n  public readonly TrimTrailingWhitespace = (): void => {\n    for (let ii = this.content.length - 1; ii >= 0; --ii) {\n      const text = asOrNull(this.content[ii], Text);\n      if (text === null) {\n        break;\n      }\n\n      text.text = text.text.replace(new RegExp(/[ \\t]/g), \"\");\n      if (text.text.length === 0) {\n        this.content.splice(ii, 1);\n      } else {\n        break;\n      }\n    }\n  };\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    const container = new RuntimeContainer();\n    if (this.content !== null) {\n      for (const obj of this.content) {\n        const contentObjRuntime = obj.runtimeObject;\n\n        // Some objects (e.g. author warnings) don't generate runtime objects\n        if (contentObjRuntime) {\n          container.AddContent(contentObjRuntime);\n        }\n      }\n    }\n\n    if (this.dontFlatten) {\n      this.story.DontFlattenContainer(container);\n    }\n\n    return container;\n  };\n\n  public toString = (): string => `ContentList(${this.content.join(\", \")})`;\n}\n","import { InkObject } from \"./Object\";\nimport { Path } from \"./Path\";\n\nexport class VariableReference extends InkObject {\n  public name: string | null;\n  public pathForCount: Path | null = null;\n\n  get containerForCount() {\n    if (this.pathForCount === null) return null;\n    return this.ResolvePath(this.pathForCount).container;\n  }\n  get pathStringForCount() {\n    if (this.pathForCount === null) return null;\n\n    return this.CompactPathString(this.pathForCount);\n  }\n  set pathStringForCount(value: string | null) {\n    if (value === null) this.pathForCount = null;\n    else this.pathForCount = new Path(value);\n  }\n\n  constructor(name: string | null = null) {\n    super();\n    this.name = name;\n  }\n\n  public toString() {\n    if (this.name != null) {\n      return \"var(\" + this.name + \")\";\n    } else {\n      let pathStr = this.pathStringForCount;\n      return \"read_count(\" + pathStr + \")\";\n    }\n  }\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { ContentList } from \"../ContentList\";\nimport { Expression } from \"../Expression/Expression\";\nimport { FlowBase } from \"../Flow/FlowBase\";\nimport { ParsedObject } from \"../Object\";\nimport { Path } from \"../Path\";\nimport { Story } from \"../Story\";\nimport { VariableReference as RuntimeVariableReference } from \"../../../../engine/VariableReference\";\nimport { Weave } from \"../Weave\";\nimport { Identifier } from \"../Identifier\";\nimport { asOrNull, filterUndef } from \"../../../../engine/TypeAssertion\";\n\nexport class VariableReference extends Expression {\n  private _runtimeVarRef: RuntimeVariableReference | null = null;\n\n  // - Normal variables have a single item in their \"path\"\n  // - Knot/stitch names for read counts are actual dot-separated paths\n  //   (though this isn't actually used at time of writing)\n  // - List names are dot separated: listName.itemName (or just itemName)\n  get name() {\n    return this.path.join(\".\");\n  }\n\n  get path(): string[] {\n    return this.pathIdentifiers.map((id) => id.name!).filter(filterUndef);\n  }\n\n  get identifier(): Identifier | null {\n    if (!this.pathIdentifiers || this.pathIdentifiers.length == 0) {\n      return null;\n    }\n    const name = this.path.join(\".\");\n    const id = new Identifier(name);\n\n    return id;\n  }\n\n  // Only known after GenerateIntoContainer has run\n  public isConstantReference: boolean = false;\n  public isListItemReference: boolean = false;\n\n  get runtimeVarRef() {\n    return this._runtimeVarRef;\n  }\n\n  constructor(public readonly pathIdentifiers: Identifier[]) {\n    super();\n  }\n\n  get typeName(): string {\n    return \"ref\";\n  }\n\n  public readonly GenerateIntoContainer = (\n    container: RuntimeContainer\n  ): void => {\n    let constantValue: Expression | null | undefined = this.story.constants.get(\n      this.name\n    );\n\n    // If it's a constant reference, just generate the literal expression value\n    // It's okay to access the constants at code generation time, since the\n    // first thing the ExportRuntime function does it search for all the constants\n    // in the story hierarchy, so they're all available.\n    if (constantValue) {\n      constantValue.GenerateConstantIntoContainer(container);\n      this.isConstantReference = true;\n\n      return;\n    }\n\n    this._runtimeVarRef = new RuntimeVariableReference(this.name);\n\n    // List item reference?\n    // Path might be to a list (listName.listItemName or just listItemName)\n    if (this.path.length === 1 || this.path.length === 2) {\n      let listItemName: string = \"\";\n      let listName: string = \"\";\n\n      if (this.path.length === 1) {\n        listItemName = this.path[0];\n      } else {\n        listName = this.path[0];\n        listItemName = this.path[1];\n      }\n\n      const listItem = this.story.ResolveListItem(listName, listItemName, this);\n\n      if (listItem) {\n        this.isListItemReference = true;\n      }\n    }\n\n    container.AddContent(this._runtimeVarRef);\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    // Work is already done if it's a constant or list item reference\n    if (this.isConstantReference || this.isListItemReference) {\n      return;\n    }\n\n    // Is it a read count?\n    const parsedPath = new Path(this.pathIdentifiers);\n    const targetForCount: ParsedObject | null =\n      parsedPath.ResolveFromContext(this);\n    if (targetForCount) {\n      if (!targetForCount.containerForCounting) {\n        throw new Error();\n      }\n\n      targetForCount.containerForCounting.visitsShouldBeCounted = true;\n\n      // If this is an argument to a function that wants a variable to be\n      // passed by reference, then the Parsed.Divert will have generated a\n      // Runtime.VariablePointerValue instead of allowing this object\n      // to generate its RuntimeVariableReference. This only happens under\n      // error condition since we shouldn't be passing a read count by\n      // reference, but we don't want it to crash!\n      if (this._runtimeVarRef === null) {\n        return;\n      }\n\n      this._runtimeVarRef.pathForCount = targetForCount.runtimePath;\n      this._runtimeVarRef.name = null;\n\n      // Check for very specific writer error: getting read count and\n      // printing it as content rather than as a piece of logic\n      // e.g. Writing {myFunc} instead of {myFunc()}\n      let targetFlow = asOrNull(targetForCount, FlowBase);\n      if (targetFlow && targetFlow.isFunction) {\n        // Is parent context content rather than logic?\n        if (\n          this.parent instanceof Weave ||\n          this.parent instanceof ContentList ||\n          this.parent instanceof FlowBase\n        ) {\n          this.Warning(\n            `'${targetFlow.identifier}' being used as read count rather than being called as function. Perhaps you intended to write ${targetFlow.identifier}()`\n          );\n        }\n      }\n\n      return;\n    }\n\n    // Couldn't find this multi-part path at all, whether as a divert\n    // target or as a list item reference.\n    if (this.path.length > 1) {\n      let errorMsg = `Could not find target for read count: ${parsedPath}`;\n      if (this.path.length <= 2) {\n        errorMsg += `, or couldn't find list item with the name ${this.path.join(\n          \",\"\n        )}`;\n      }\n\n      this.Error(errorMsg);\n\n      return;\n    }\n\n    if (!context.ResolveVariableWithName(this.name, this).found) {\n      this.Error(`Unresolved variable: ${this.name}`, this);\n    }\n  }\n\n  public readonly toString = (): string => `{${this.path.join(\".\")}}`;\n}\n","﻿import { Container as RuntimeContainer } from \"../../../engine/Container\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../engine/ControlCommand\";\nimport { Divert } from \"./Divert/Divert\";\nimport { Divert as RuntimeDivert } from \"../../../engine/Divert\";\nimport { DivertTarget } from \"./Divert/DivertTarget\";\nimport { Expression } from \"./Expression/Expression\";\nimport { InkList as RuntimeInkList } from \"../../../engine/InkList\";\nimport { ListValue } from \"../../../engine/Value\";\nimport { NativeFunctionCall } from \"../../../engine/NativeFunctionCall\";\nimport { NumberExpression } from \"./Expression/NumberExpression\";\nimport { Path } from \"./Path\";\nimport { Story } from \"./Story\";\nimport { StringValue } from \"../../../engine/Value\";\nimport { VariableReference } from \"./Variable/VariableReference\";\nimport { Identifier } from \"./Identifier\";\nimport { asOrNull } from \"../../../engine/TypeAssertion\";\n\nexport class FunctionCall extends Expression {\n  public static readonly IsBuiltIn = (name: string): boolean => {\n    if (NativeFunctionCall.CallExistsWithName(name)) {\n      return true;\n    }\n\n    return (\n      name === \"CHOICE_COUNT\" ||\n      name === \"TURNS_SINCE\" ||\n      name === \"TURNS\" ||\n      name === \"RANDOM\" ||\n      name === \"SEED_RANDOM\" ||\n      name === \"LIST_VALUE\" ||\n      name === \"LIST_RANDOM\" ||\n      name === \"READ_COUNT\"\n    );\n  };\n\n  private _proxyDivert: Divert;\n  get proxyDivert(): Divert {\n    return this._proxyDivert;\n  }\n  private _divertTargetToCount: DivertTarget | null = null;\n  private _variableReferenceToCount: VariableReference | null = null;\n\n  get name(): string {\n    return (this._proxyDivert.target as Path).firstComponent || \"\";\n  }\n\n  get args(): Expression[] {\n    return this._proxyDivert.args;\n  }\n\n  get runtimeDivert(): RuntimeDivert {\n    return this._proxyDivert.runtimeDivert;\n  }\n\n  get isChoiceCount(): boolean {\n    return this.name === \"CHOICE_COUNT\";\n  }\n\n  get isTurns(): boolean {\n    return this.name === \"TURNS\";\n  }\n\n  get isTurnsSince(): boolean {\n    return this.name === \"TURNS_SINCE\";\n  }\n\n  get isRandom(): boolean {\n    return this.name === \"RANDOM\";\n  }\n\n  get isSeedRandom(): boolean {\n    return this.name === \"SEED_RANDOM\";\n  }\n\n  get isListRange(): boolean {\n    return this.name === \"LIST_RANGE\";\n  }\n\n  get isListRandom(): boolean {\n    return this.name === \"LIST_RANDOM\";\n  }\n\n  get isReadCount(): boolean {\n    return this.name === \"READ_COUNT\";\n  }\n\n  public shouldPopReturnedValue: boolean = false;\n\n  constructor(functionName: Identifier, args: Expression[]) {\n    super();\n\n    this._proxyDivert = new Divert(new Path(functionName), args);\n    this._proxyDivert.isFunctionCall = true;\n    this.AddContent(this._proxyDivert);\n  }\n\n  get typeName(): string {\n    return \"FunctionCall\";\n  }\n\n  public readonly GenerateIntoContainer = (\n    container: RuntimeContainer\n  ): void => {\n    const foundList = this.story.ResolveList(this.name);\n\n    let usingProxyDivert: boolean = false;\n\n    if (this.isChoiceCount) {\n      if (this.args.length > 0) {\n        this.Error(\"The CHOICE_COUNT() function shouldn't take any arguments\");\n      }\n\n      container.AddContent(RuntimeControlCommand.ChoiceCount());\n    } else if (this.isTurns) {\n      if (this.args.length > 0) {\n        this.Error(\"The TURNS() function shouldn't take any arguments\");\n      }\n\n      container.AddContent(RuntimeControlCommand.Turns());\n    } else if (this.isTurnsSince || this.isReadCount) {\n      const divertTarget = asOrNull(this.args[0], DivertTarget);\n      const variableDivertTarget = asOrNull(this.args[0], VariableReference);\n\n      if (\n        this.args.length !== 1 ||\n        (divertTarget === null && variableDivertTarget === null)\n      ) {\n        this.Error(\n          `The ${this.name}() function should take one argument: a divert target to the target knot, stitch, gather or choice you want to check. e.g. TURNS_SINCE(-> myKnot)`\n        );\n        return;\n      }\n\n      if (divertTarget) {\n        this._divertTargetToCount = divertTarget;\n        this.AddContent(this._divertTargetToCount);\n\n        this._divertTargetToCount.GenerateIntoContainer(container);\n      } else if (variableDivertTarget) {\n        this._variableReferenceToCount = variableDivertTarget;\n        this.AddContent(this._variableReferenceToCount);\n\n        this._variableReferenceToCount.GenerateIntoContainer(container);\n      }\n\n      if (this.isTurnsSince) {\n        container.AddContent(RuntimeControlCommand.TurnsSince());\n      } else {\n        container.AddContent(RuntimeControlCommand.ReadCount());\n      }\n    } else if (this.isRandom) {\n      if (this.args.length !== 2) {\n        this.Error(\n          \"RANDOM should take 2 parameters: a minimum and a maximum integer\"\n        );\n      }\n\n      // We can type check single values, but not complex expressions\n      for (let ii = 0; ii < this.args.length; ii += 1) {\n        const num = asOrNull(this.args[ii], NumberExpression);\n        if (num && !num.isInt()) {\n          const paramName: string = ii === 0 ? \"minimum\" : \"maximum\";\n          this.Error(`RANDOM's ${paramName} parameter should be an integer`);\n        }\n\n        this.args[ii].GenerateIntoContainer(container);\n      }\n\n      container.AddContent(RuntimeControlCommand.Random());\n    } else if (this.isSeedRandom) {\n      if (this.args.length !== 1) {\n        this.Error(\"SEED_RANDOM should take 1 parameter - an integer seed\");\n      }\n\n      const num = asOrNull(this.args[0], NumberExpression);\n      if (num && !num.isInt()) {\n        this.Error(\"SEED_RANDOM's parameter should be an integer seed\");\n      }\n\n      this.args[0].GenerateIntoContainer(container);\n\n      container.AddContent(RuntimeControlCommand.SeedRandom());\n    } else if (this.isListRange) {\n      if (this.args.length !== 3) {\n        this.Error(\n          \"LIST_RANGE should take 3 parameters - a list, a min and a max\"\n        );\n      }\n\n      for (let ii = 0; ii < this.args.length; ii += 1) {\n        this.args[ii].GenerateIntoContainer(container);\n      }\n\n      container.AddContent(RuntimeControlCommand.ListRange());\n    } else if (this.isListRandom) {\n      if (this.args.length !== 1) {\n        this.Error(\"LIST_RANDOM should take 1 parameter - a list\");\n      }\n\n      this.args[0].GenerateIntoContainer(container);\n\n      container.AddContent(RuntimeControlCommand.ListRandom());\n    } else if (NativeFunctionCall.CallExistsWithName(this.name)) {\n      const nativeCall = NativeFunctionCall.CallWithName(this.name);\n      if (nativeCall.numberOfParameters !== this.args.length) {\n        let msg = `${name} should take ${nativeCall.numberOfParameters} parameter`;\n        if (nativeCall.numberOfParameters > 1) {\n          msg += \"s\";\n        }\n\n        this.Error(msg);\n      }\n\n      for (let ii = 0; ii < this.args.length; ii += 1) {\n        this.args[ii].GenerateIntoContainer(container);\n      }\n\n      container.AddContent(NativeFunctionCall.CallWithName(this.name));\n    } else if (foundList !== null) {\n      if (this.args.length > 1) {\n        this.Error(\n          \"Can currently only construct a list from one integer (or an empty list from a given list definition)\"\n        );\n      }\n\n      // List item from given int\n      if (this.args.length === 1) {\n        container.AddContent(new StringValue(this.name));\n        this.args[0].GenerateIntoContainer(container);\n        container.AddContent(RuntimeControlCommand.ListFromInt());\n      } else {\n        // Empty list with given origin.\n        const list = new RuntimeInkList();\n        list.SetInitialOriginName(this.name);\n        container.AddContent(new ListValue(list));\n      }\n    } else {\n      // Normal function call\n      container.AddContent(this._proxyDivert.runtimeObject);\n      usingProxyDivert = true;\n    }\n\n    // Don't attempt to resolve as a divert if we're not doing a normal function call\n    if (!usingProxyDivert) {\n      this.content.splice(this.content.indexOf(this._proxyDivert), 1);\n    }\n\n    // Function calls that are used alone on a tilda-based line:\n    //  ~ func()\n    // Should tidy up any returned value from the evaluation stack,\n    // since it's unused.\n    if (this.shouldPopReturnedValue) {\n      container.AddContent(RuntimeControlCommand.PopEvaluatedValue());\n    }\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    // If we aren't using the proxy divert after all (e.g. if\n    // it's a native function call), but we still have arguments,\n    // we need to make sure they get resolved since the proxy divert\n    // is no longer in the content array.\n    if (!this.content.includes(this._proxyDivert) && this.args !== null) {\n      for (const arg of this.args) {\n        arg.ResolveReferences(context);\n      }\n    }\n\n    if (this._divertTargetToCount) {\n      const divert = this._divertTargetToCount.divert;\n      const attemptingTurnCountOfVariableTarget =\n        divert.runtimeDivert.variableDivertName != null;\n\n      if (attemptingTurnCountOfVariableTarget) {\n        this.Error(\n          `When getting the TURNS_SINCE() of a variable target, remove the '->' - i.e. it should just be TURNS_SINCE(${divert.runtimeDivert.variableDivertName})`\n        );\n\n        return;\n      }\n\n      const targetObject = divert.targetContent;\n      if (targetObject === null) {\n        if (!attemptingTurnCountOfVariableTarget) {\n          this.Error(\n            `Failed to find target for TURNS_SINCE: '${divert.target}'`\n          );\n        }\n      } else {\n        if (!targetObject.containerForCounting) {\n          throw new Error();\n        }\n\n        targetObject.containerForCounting.turnIndexShouldBeCounted = true;\n      }\n    } else if (this._variableReferenceToCount) {\n      const runtimeVarRef = this._variableReferenceToCount.runtimeVarRef;\n      if (!runtimeVarRef) {\n        throw new Error();\n      }\n\n      if (runtimeVarRef.pathForCount !== null) {\n        this.Error(\n          `Should be '${name}'(-> '${this._variableReferenceToCount.name}). Usage without the '->' only makes sense for variable targets.`\n        );\n      }\n    }\n  }\n\n  public readonly toString = (): string => {\n    const strArgs = this.args.join(\", \");\n    return `${this.name}(${strArgs})`;\n  };\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { Expression } from \"./Expression\";\nimport { NativeFunctionCall } from \"../../../../engine/NativeFunctionCall\";\n\nexport class MultipleConditionExpression extends Expression {\n  get subExpressions(): Expression[] {\n    return this.content as Expression[];\n  }\n\n  constructor(conditionExpressions: Expression[]) {\n    super();\n\n    this.AddContent(conditionExpressions);\n  }\n\n  get typeName(): string {\n    return \"MultipleConditionExpression\";\n  }\n\n  public readonly GenerateIntoContainer = (\n    container: RuntimeContainer\n  ): void => {\n    //    A && B && C && D\n    // => (((A B &&) C &&) D &&) etc\n    let isFirst: boolean = true;\n    for (const conditionExpr of this.subExpressions) {\n      conditionExpr.GenerateIntoContainer(container);\n\n      if (!isFirst) {\n        container.AddContent(NativeFunctionCall.CallWithName(\"&&\"));\n      }\n\n      isFirst = false;\n    }\n  };\n}\n","export enum SequenceType {\n  Stopping = 1, // default\n  Cycle = 2,\n  Shuffle = 4,\n  Once = 8,\n}\n","﻿import { BinaryExpression } from \"../Expression/BinaryExpression\";\nimport { Choice } from \"../Choice\";\nimport { Conditional } from \"../Conditional/Conditional\";\nimport { ConditionalSingleBranch } from \"../Conditional/ConditionalSingleBranch\";\nimport { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { ParsedObject } from \"../Object\";\nimport { Divert } from \"./Divert\";\nimport { Divert as RuntimeDivert } from \"../../../../engine/Divert\";\nimport { DivertTargetValue } from \"../../../../engine/Value\";\nimport { Expression } from \"../Expression/Expression\";\nimport { FlowBase } from \"../Flow/FlowBase\";\nimport { FunctionCall } from \"../FunctionCall\";\nimport { MultipleConditionExpression } from \"../Expression/MultipleConditionExpression\";\nimport { Story } from \"../Story\";\nimport { VariableReference } from \"../Variable/VariableReference\";\nimport { asOrNull } from \"../../../../engine/TypeAssertion\";\n\nexport class DivertTarget extends Expression {\n  private _runtimeDivert: RuntimeDivert | null = null;\n  get runtimeDivert(): RuntimeDivert {\n    if (!this._runtimeDivert) {\n      throw new Error();\n    }\n\n    return this._runtimeDivert;\n  }\n\n  private _runtimeDivertTargetValue: DivertTargetValue | null = null;\n  get runtimeDivertTargetValue(): DivertTargetValue {\n    if (!this._runtimeDivertTargetValue) {\n      throw new Error();\n    }\n\n    return this._runtimeDivertTargetValue;\n  }\n\n  public divert: Divert;\n\n  constructor(divert: Divert) {\n    super();\n\n    this.divert = this.AddContent(divert) as Divert;\n  }\n\n  get typeName(): string {\n    return \"DivertTarget\";\n  }\n\n  public readonly GenerateIntoContainer = (\n    container: RuntimeContainer\n  ): void => {\n    this.divert.GenerateRuntimeObject();\n\n    this._runtimeDivert = this.divert.runtimeDivert as RuntimeDivert;\n    this._runtimeDivertTargetValue = new DivertTargetValue();\n\n    container.AddContent(this.runtimeDivertTargetValue);\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    if (this.divert.isDone || this.divert.isEnd) {\n      this.Error(\n        `Can't use -> DONE or -> END as variable divert targets`,\n        this\n      );\n\n      return;\n    }\n\n    let usageContext: ParsedObject | null = this;\n    while (usageContext && usageContext instanceof Expression) {\n      let badUsage: boolean = false;\n      let foundUsage: boolean = false;\n\n      const usageParent: any = (usageContext as Expression).parent;\n      if (usageParent instanceof BinaryExpression) {\n        // Only allowed to compare for equality\n\n        const binaryExprParent = usageParent;\n        if (\n          binaryExprParent.opName !== \"==\" &&\n          binaryExprParent.opName !== \"!=\"\n        ) {\n          badUsage = true;\n        } else {\n          if (\n            !(\n              binaryExprParent.leftExpression instanceof DivertTarget ||\n              binaryExprParent.leftExpression instanceof VariableReference\n            )\n          ) {\n            badUsage = true;\n          } else if (\n            !(\n              binaryExprParent.rightExpression instanceof DivertTarget ||\n              binaryExprParent.rightExpression instanceof VariableReference\n            )\n          ) {\n            badUsage = true;\n          }\n        }\n\n        foundUsage = true;\n      } else if (usageParent instanceof FunctionCall) {\n        const funcCall = usageParent;\n        if (!funcCall.isTurnsSince && !funcCall.isReadCount) {\n          badUsage = true;\n        }\n\n        foundUsage = true;\n      } else if (usageParent instanceof Expression) {\n        badUsage = true;\n        foundUsage = true;\n      } else if (usageParent instanceof MultipleConditionExpression) {\n        badUsage = true;\n        foundUsage = true;\n      } else if (\n        usageParent instanceof Choice &&\n        (usageParent as Choice).condition === usageContext\n      ) {\n        badUsage = true;\n        foundUsage = true;\n      } else if (\n        usageParent instanceof Conditional ||\n        usageParent instanceof ConditionalSingleBranch\n      ) {\n        badUsage = true;\n        foundUsage = true;\n      }\n\n      if (badUsage) {\n        this.Error(\n          `Can't use a divert target like that. Did you intend to call '${this.divert.target}' as a function: likeThis(), or check the read count: likeThis, with no arrows?`,\n          this\n        );\n      }\n\n      if (foundUsage) {\n        break;\n      }\n\n      usageContext = usageParent;\n    }\n\n    // Example ink for this case:\n    //\n    //     VAR x = -> blah\n    //\n    // ...which means that \"blah\" is expected to be a literal stitch target rather\n    // than a variable name. We can't really intelligently recover from this (e.g. if blah happens to\n    // contain a divert target itself) since really we should be generating a variable reference\n    // rather than a concrete DivertTarget, so we list it as an error.\n    if (this.runtimeDivert.hasVariableTarget) {\n      if (!this.divert.target) {\n        throw new Error();\n      }\n\n      this.Error(\n        `Since '${this.divert.target.dotSeparatedComponents}' is a variable, it shouldn't be preceded by '->' here.`\n      );\n    }\n\n    // Main resolve\n    this.runtimeDivert.targetPath &&\n      (this.runtimeDivertTargetValue.targetPath =\n        this.runtimeDivert.targetPath);\n\n    // Tell hard coded (yet variable) divert targets that they also need to be counted\n    // TODO: Only detect DivertTargets that are values rather than being used directly for\n    // read or turn counts. Should be able to detect this by looking for other uses of containerForCounting\n    let targetContent = this.divert.targetContent;\n    if (targetContent !== null) {\n      let target = targetContent.containerForCounting;\n      if (target !== null) {\n        // Purpose is known: used directly in TURNS_SINCE(-> divTarg)\n        const parentFunc = asOrNull(this.parent, FunctionCall);\n        if (parentFunc && parentFunc.isTurnsSince) {\n          target.turnIndexShouldBeCounted = true;\n        } else {\n          // Unknown purpose, count everything\n          target.visitsShouldBeCounted = true;\n          target.turnIndexShouldBeCounted = true;\n        }\n      }\n\n      // Unfortunately not possible:\n      // https://github.com/inkle/ink/issues/538\n      //\n      // VAR func = -> double\n      //\n      // === function double(ref x)\n      //    ~ x = x * 2\n      //\n      // Because when generating the parameters for a function\n      // to be called, it needs to know ahead of time when\n      // compiling whether to pass a variable reference or value.\n      //\n      let targetFlow = asOrNull(targetContent, FlowBase);\n      if (targetFlow != null && targetFlow.args !== null) {\n        for (const arg of targetFlow.args) {\n          if (arg.isByReference) {\n            this.Error(\n              `Can't store a divert target to a knot or function that has by-reference arguments ('${targetFlow.identifier}' has 'ref ${arg.identifier}').`\n            );\n          }\n        }\n      }\n    }\n  }\n\n  // Equals override necessary in order to check for CONST multiple definition equality\n  public readonly Equals = (obj: ParsedObject): boolean => {\n    const otherDivTarget = asOrNull(obj, DivertTarget);\n    if (\n      !otherDivTarget ||\n      !this.divert.target ||\n      !otherDivTarget.divert.target\n    ) {\n      return false;\n    }\n\n    const targetStr = this.divert.target.dotSeparatedComponents;\n    const otherTargetStr = otherDivTarget.divert.target.dotSeparatedComponents;\n\n    return targetStr === otherTargetStr;\n  };\n}\n","import { Argument } from \"../Argument\";\nimport { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../../engine/ControlCommand\";\nimport { Divert as RuntimeDivert } from \"../../../../engine/Divert\";\nimport { DivertTarget } from \"./DivertTarget\";\nimport { Expression } from \"../Expression/Expression\";\nimport { FlowBase } from \"../Flow/FlowBase\";\nimport { FunctionCall } from \"../FunctionCall\";\nimport { ParsedObject } from \"../Object\";\nimport { Path } from \"../Path\";\nimport { Path as RuntimePath } from \"../../../../engine/Path\";\nimport { PushPopType } from \"../../../../engine/PushPop\";\nimport { Story } from \"../Story\";\nimport { VariablePointerValue } from \"../../../../engine/Value\";\nimport { VariableReference } from \"../Variable/VariableReference\";\nimport { ClosestFlowBase } from \"../Flow/ClosestFlowBase\";\nimport { asOrNull } from \"../../../../engine/TypeAssertion\";\n\nexport class Divert extends ParsedObject {\n  public readonly args: Expression[] = [];\n\n  public readonly target: Path | null = null;\n  public targetContent: ParsedObject | null = null;\n  private _runtimeDivert: RuntimeDivert | null = null;\n  get runtimeDivert(): RuntimeDivert {\n    if (!this._runtimeDivert) {\n      throw new Error();\n    }\n\n    return this._runtimeDivert;\n  }\n\n  set runtimeDivert(value: RuntimeDivert) {\n    this._runtimeDivert = value;\n  }\n\n  public isFunctionCall: boolean = false;\n  public isEmpty: boolean = false;\n  public isTunnel: boolean = false;\n  public isThread: boolean = false;\n\n  get isEnd(): boolean {\n    return Boolean(this.target && this.target.dotSeparatedComponents === \"END\");\n  }\n\n  get isDone(): boolean {\n    return Boolean(\n      this.target && this.target.dotSeparatedComponents === \"DONE\"\n    );\n  }\n\n  constructor(target?: Path | null | undefined, args?: Expression[]) {\n    super();\n\n    if (target) {\n      this.target = target;\n    }\n\n    if (args) {\n      this.args = args;\n      this.AddContent(args);\n    }\n  }\n\n  get typeName(): string {\n    return \"Divert\";\n  }\n\n  public readonly GenerateRuntimeObject = () => {\n    // End = end flow immediately\n    // Done = return from thread or instruct the flow that it's safe to exit\n    if (this.isEnd) {\n      return RuntimeControlCommand.End();\n    } else if (this.isDone) {\n      return RuntimeControlCommand.Done();\n    }\n\n    this.runtimeDivert = new RuntimeDivert();\n\n    // Normally we resolve the target content during the\n    // Resolve phase, since we expect all runtime objects to\n    // be available in order to find the final runtime path for\n    // the destination. However, we need to resolve the target\n    // (albeit without the runtime target) early so that\n    // we can get information about the arguments - whether\n    // they're by reference - since it affects the code we\n    // generate here.\n    this.ResolveTargetContent();\n\n    this.CheckArgumentValidity();\n\n    // Passing arguments to the knot\n    const requiresArgCodeGen = this.args !== null && this.args.length > 0;\n    if (\n      requiresArgCodeGen ||\n      this.isFunctionCall ||\n      this.isTunnel ||\n      this.isThread\n    ) {\n      const container = new RuntimeContainer();\n\n      // Generate code for argument evaluation\n      // This argument generation is coded defensively - it should\n      // attempt to generate the code for all the parameters, even if\n      // they don't match the expected arguments. This is so that the\n      // parameter objects themselves are generated correctly and don't\n      // get into a state of attempting to resolve references etc\n      // without being generated.\n      if (requiresArgCodeGen) {\n        // Function calls already in an evaluation context\n        if (!this.isFunctionCall) {\n          container.AddContent(RuntimeControlCommand.EvalStart());\n        }\n\n        let targetArguments: Argument[] | null = null;\n        if (this.targetContent) {\n          targetArguments = (this.targetContent as FlowBase).args;\n        }\n\n        for (let ii = 0; ii < this.args.length; ++ii) {\n          const argToPass: Expression = this.args[ii];\n          let argExpected: Argument | null = null;\n          if (targetArguments && ii < targetArguments.length) {\n            argExpected = targetArguments[ii];\n          }\n\n          // Pass by reference: argument needs to be a variable reference\n          if (argExpected && argExpected.isByReference) {\n            const varRef = asOrNull(argToPass, VariableReference);\n            if (!varRef) {\n              this.Error(\n                `Expected variable name to pass by reference to 'ref ${argExpected.identifier}' but saw ${argToPass}`\n              );\n\n              break;\n            }\n\n            // Check that we're not attempting to pass a read count by reference\n            const targetPath = new Path(varRef.pathIdentifiers);\n            const targetForCount: ParsedObject | null =\n              targetPath.ResolveFromContext(this);\n            if (targetForCount) {\n              this.Error(\n                `can't pass a read count by reference. '${\n                  targetPath.dotSeparatedComponents\n                }' is a knot/stitch/label, but '${\n                  this.target!.dotSeparatedComponents\n                }' requires the name of a VAR to be passed.`\n              );\n\n              break;\n            }\n\n            const varPointer = new VariablePointerValue(varRef.name);\n            container.AddContent(varPointer);\n          } else {\n            // Normal value being passed: evaluate it as normal\n            argToPass.GenerateIntoContainer(container);\n          }\n        }\n\n        // Function calls were already in an evaluation context\n        if (!this.isFunctionCall) {\n          container.AddContent(RuntimeControlCommand.EvalEnd());\n        }\n      }\n\n      // Starting a thread? A bit like a push to the call stack below... but not.\n      // It sort of puts the call stack on a thread stack (argh!) - forks the full flow.\n      if (this.isThread) {\n        container.AddContent(RuntimeControlCommand.StartThread());\n      } else if (this.isFunctionCall || this.isTunnel) {\n        // If this divert is a function call, tunnel, we push to the call stack\n        // so we can return again\n        this.runtimeDivert.pushesToStack = true;\n        this.runtimeDivert.stackPushType = this.isFunctionCall\n          ? PushPopType.Function\n          : PushPopType.Tunnel;\n      }\n\n      // Jump into the \"function\" (knot/stitch)\n      container.AddContent(this.runtimeDivert);\n\n      return container;\n    }\n\n    // Simple divert\n    return this.runtimeDivert;\n  };\n\n  // When the divert is to a target that's actually a variable name\n  // rather than an explicit knot/stitch name, try interpretting it\n  // as such by getting the variable name.\n  public readonly PathAsVariableName = () =>\n    this.target ? this.target.firstComponent : null;\n\n  public readonly ResolveTargetContent = (): void => {\n    if (this.isEmpty || this.isEnd) {\n      return;\n    }\n\n    if (this.targetContent === null) {\n      // Is target of this divert a variable name that will be de-referenced\n      // at runtime? If so, there won't be any further reference resolution\n      // we can do at this point.\n      let variableTargetName = this.PathAsVariableName();\n      if (variableTargetName !== null) {\n        const flowBaseScope = asOrNull(ClosestFlowBase(this), FlowBase);\n        if (flowBaseScope) {\n          const resolveResult = flowBaseScope.ResolveVariableWithName(\n            variableTargetName,\n            this\n          );\n\n          if (resolveResult.found) {\n            // Make sure that the flow was typed correctly, given that we know that this\n            // is meant to be a divert target\n            if (\n              resolveResult.isArgument &&\n              resolveResult.ownerFlow &&\n              resolveResult.ownerFlow.args\n            ) {\n              let argument = resolveResult.ownerFlow.args.find(\n                (a) => a.identifier?.name == variableTargetName\n              );\n\n              if (argument && !argument.isDivertTarget) {\n                this.Error(\n                  `Since '${argument.identifier}' is used as a variable divert target (on ${this.debugMetadata}), it should be marked as: -> ${argument.identifier}`,\n                  resolveResult.ownerFlow\n                );\n              }\n            }\n\n            this.runtimeDivert.variableDivertName = variableTargetName;\n            return;\n          }\n        }\n      }\n\n      if (!this.target) {\n        throw new Error();\n      }\n\n      this.targetContent = this.target.ResolveFromContext(this);\n    }\n  };\n\n  public ResolveReferences(context: Story): void {\n    if (this.isEmpty || this.isEnd || this.isDone) {\n      return;\n    } else if (!this.runtimeDivert) {\n      throw new Error();\n    }\n\n    if (this.targetContent) {\n      this.runtimeDivert.targetPath = this.targetContent.runtimePath;\n    }\n\n    // Resolve children (the arguments)\n    super.ResolveReferences(context);\n\n    // May be null if it's a built in function (e.g. TURNS_SINCE)\n    // or if it's a variable target.\n    let targetFlow = asOrNull(this.targetContent, FlowBase);\n    if (targetFlow) {\n      if (!targetFlow.isFunction && this.isFunctionCall) {\n        super.Error(\n          `${targetFlow.identifier} hasn't been marked as a function, but it's being called as one. Do you need to delcare the knot as '== function ${targetFlow.identifier} =='?`\n        );\n      } else if (\n        targetFlow.isFunction &&\n        !this.isFunctionCall &&\n        !(this.parent instanceof DivertTarget)\n      ) {\n        super.Error(\n          targetFlow.identifier +\n            \" can't be diverted to. It can only be called as a function since it's been marked as such: '\" +\n            targetFlow.identifier +\n            \"(...)'\"\n        );\n      }\n    }\n\n    // Check validity of target content\n    const targetWasFound = this.targetContent !== null;\n    let isBuiltIn: boolean = false;\n    let isExternal: boolean = false;\n\n    if (!this.target) {\n      throw new Error();\n    } else if (this.target.numberOfComponents === 1) {\n      if (!this.target.firstComponent) {\n        throw new Error();\n      }\n\n      // BuiltIn means TURNS_SINCE, CHOICE_COUNT, RANDOM or SEED_RANDOM\n      isBuiltIn = FunctionCall.IsBuiltIn(this.target.firstComponent);\n\n      // Client-bound function?\n      isExternal = context.IsExternal(this.target.firstComponent);\n\n      if (isBuiltIn || isExternal) {\n        if (!this.isFunctionCall) {\n          super.Error(\n            `${this.target.firstComponent} must be called as a function: ~ ${this.target.firstComponent}()`\n          );\n        }\n\n        if (isExternal) {\n          this.runtimeDivert.isExternal = true;\n          if (this.args !== null) {\n            this.runtimeDivert.externalArgs = this.args.length;\n          }\n\n          this.runtimeDivert.pushesToStack = false;\n          this.runtimeDivert.targetPath = new RuntimePath(\n            this.target.firstComponent\n          );\n\n          this.CheckExternalArgumentValidity(context);\n        }\n\n        return;\n      }\n    }\n\n    // Variable target?\n    if (this.runtimeDivert.variableDivertName != null) {\n      return;\n    }\n\n    if (!targetWasFound && !isBuiltIn && !isExternal) {\n      this.Error(`target not found: '${this.target}'`);\n    }\n  }\n\n  // Returns false if there's an error\n  public readonly CheckArgumentValidity = (): void => {\n    if (this.isEmpty) {\n      return;\n    }\n\n    // Argument passing: Check for errors in number of arguments\n    let numArgs = 0;\n    if (this.args !== null && this.args.length > 0) {\n      numArgs = this.args.length;\n    }\n\n    // Missing content?\n    // Can't check arguments properly. It'll be due to some\n    // other error though, so although there's a problem and\n    // we report false, we don't need to report a specific error.\n    // It may also be because it's a valid call to an external\n    // function, that we check at the resolve stage.\n    if (this.targetContent === null) {\n      return;\n    }\n\n    const targetFlow = asOrNull(this.targetContent, FlowBase);\n\n    // No error, crikey!\n    if (numArgs === 0 && (targetFlow === null || !targetFlow.hasParameters)) {\n      return;\n    } else if (targetFlow === null && numArgs > 0) {\n      this.Error(\n        \"target needs to be a knot or stitch in order to pass arguments\"\n      );\n      return;\n    } else if (\n      targetFlow !== null &&\n      (targetFlow.args === null || (!targetFlow.args && numArgs > 0))\n    ) {\n      this.Error(`target (${targetFlow.name}) doesn't take parameters`);\n      return;\n    } else if (this.parent instanceof DivertTarget) {\n      if (numArgs > 0) {\n        this.Error(`can't store arguments in a divert target variable`);\n      }\n\n      return;\n    }\n\n    const paramCount = targetFlow!.args!.length;\n    if (paramCount !== numArgs) {\n      let butClause: string;\n      if (numArgs === 0) {\n        butClause = \"but there weren't any passed to it\";\n      } else if (numArgs < paramCount) {\n        butClause = `but only got ${numArgs}`;\n      } else {\n        butClause = `but got ${numArgs}`;\n      }\n\n      this.Error(\n        `to '${\n          targetFlow!.identifier\n        }' requires ${paramCount} arguments, ${butClause}`\n      );\n\n      return;\n    }\n\n    // Light type-checking for divert target arguments\n    for (let ii = 0; ii < paramCount; ++ii) {\n      const flowArg: Argument = targetFlow!.args![ii];\n      const divArgExpr: Expression = this.args[ii];\n\n      // Expecting a divert target as an argument, let's do some basic type checking\n      if (flowArg.isDivertTarget) {\n        // Not passing a divert target or any kind of variable reference?\n        let varRef = asOrNull(divArgExpr, VariableReference);\n        if (!(divArgExpr instanceof DivertTarget) && varRef === null) {\n          this.Error(\n            `Target '${\n              targetFlow!.identifier\n            }' expects a divert target for the parameter named -> ${\n              flowArg.identifier\n            } but saw ${divArgExpr}`,\n            divArgExpr\n          );\n        } else if (varRef) {\n          // Passing 'a' instead of '-> a'?\n          // i.e. read count instead of divert target\n          // Unfortunately have to manually resolve here since we're still in code gen\n          const knotCountPath = new Path(varRef.pathIdentifiers);\n          const targetForCount: ParsedObject | null =\n            knotCountPath.ResolveFromContext(varRef);\n          if (targetForCount) {\n            this.Error(\n              `Passing read count of '${knotCountPath.dotSeparatedComponents}' instead of a divert target. You probably meant '${knotCountPath}'`\n            );\n          }\n        }\n      }\n    }\n\n    if (targetFlow === null) {\n      this.Error(\n        \"Can't call as a function or with arguments unless it's a knot or stitch\"\n      );\n      return;\n    }\n\n    return;\n  };\n\n  public readonly CheckExternalArgumentValidity = (context: Story): void => {\n    const externalName: string | null = this.target\n      ? this.target.firstComponent\n      : null;\n    const external = context.externals.get(externalName as any);\n    if (!external) {\n      throw new Error(\"external not found\");\n    }\n\n    const externalArgCount: number = external.argumentNames.length;\n    let ownArgCount = 0;\n    if (this.args) {\n      ownArgCount = this.args.length;\n    }\n\n    if (ownArgCount !== externalArgCount) {\n      this.Error(\n        `incorrect number of arguments sent to external function '${externalName}'. Expected ${externalArgCount} but got ${ownArgCount}`\n      );\n    }\n  };\n\n  public Error(\n    message: string,\n    source: ParsedObject | null = null,\n    isWarning: boolean = false\n  ): void {\n    // Could be getting an error from a nested Divert\n    if (source !== this && source) {\n      super.Error(message, source);\n      return;\n    }\n\n    if (this.isFunctionCall) {\n      super.Error(`Function call ${message}`, source, isWarning);\n    } else {\n      super.Error(`Divert ${message}`, source, isWarning);\n    }\n  }\n\n  public toString = (): string => {\n    let returnString = \"\";\n    if (this.target !== null) {\n      returnString += this.target.toString();\n    } else {\n      return \"-> <empty divert>\";\n    }\n\n    if (this.isTunnel) {\n      returnString += \" ->\";\n    }\n    if (this.isFunctionCall) {\n      returnString += \" ()\";\n    }\n\n    return returnString;\n  };\n}\n","import { Divert as RuntimeDivert } from \"../../../../engine/Divert\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\n\nexport class GatherPointToResolve {\n  constructor(\n    public divert: RuntimeDivert,\n    public targetRuntimeObj: RuntimeObject\n  ) {}\n}\n","import { Divert as RuntimeDivert } from \"../../../../engine/Divert\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\n\nexport class SequenceDivertToResolve {\n  constructor(\n    public divert: RuntimeDivert,\n    public targetContent: RuntimeObject\n  ) {}\n}\n","import { ContentList } from \"../ContentList\";\nimport { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../../engine/ControlCommand\";\nimport { Divert as RuntimeDivert } from \"../../../../engine/Divert\";\nimport { IntValue } from \"../../../../engine/Value\";\nimport { NativeFunctionCall } from \"../../../../engine/NativeFunctionCall\";\nimport { ParsedObject } from \"../Object\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\nimport { SequenceDivertToResolve } from \"./SequenceDivertToResolve\";\nimport { SequenceType } from \"./SequenceType\";\nimport { Story } from \"../Story\";\nimport { Weave } from \"../Weave\";\n\nexport class Sequence extends ParsedObject {\n  private _sequenceDivertsToResolve: SequenceDivertToResolve[] = [];\n\n  public sequenceElements: ParsedObject[];\n\n  constructor(\n    elementContentLists: ContentList[],\n    public readonly sequenceType: SequenceType\n  ) {\n    super();\n\n    this.sequenceType = sequenceType;\n    this.sequenceElements = [];\n\n    for (const elementContentList of elementContentLists) {\n      const contentObjs = elementContentList.content;\n      let seqElObject: ParsedObject | null = null;\n\n      // Don't attempt to create a weave for the sequence element\n      // if the content list is empty. Weaves don't like it!\n      if (contentObjs === null || contentObjs.length === 0) {\n        seqElObject = elementContentList;\n      } else {\n        seqElObject = new Weave(contentObjs);\n      }\n\n      this.sequenceElements.push(seqElObject);\n      this.AddContent(seqElObject);\n    }\n  }\n\n  get typeName(): string {\n    return \"Sequence\";\n  }\n\n  // Generate runtime code that looks like:\n  //\n  //   chosenIndex = MIN(sequence counter, num elements) e.g. for \"Stopping\"\n  //   if chosenIndex == 0, divert to s0\n  //   if chosenIndex == 1, divert to s1  [etc]\n  //\n  //   - s0:\n  //      <content for sequence element>\n  //      divert to no-op\n  //   - s1:\n  //      <content for sequence element>\n  //      divert to no-op\n  //   - s2:\n  //      empty branch if using \"once\"\n  //      divert to no-op\n  //\n  //    no-op\n  //\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    const container = new RuntimeContainer();\n    container.visitsShouldBeCounted = true;\n    container.countingAtStartOnly = true;\n\n    this._sequenceDivertsToResolve = [];\n\n    // Get sequence read count\n    container.AddContent(RuntimeControlCommand.EvalStart());\n    container.AddContent(RuntimeControlCommand.VisitIndex());\n\n    const once: boolean = (this.sequenceType & SequenceType.Once) > 0;\n    const cycle: boolean = (this.sequenceType & SequenceType.Cycle) > 0;\n    const stopping: boolean = (this.sequenceType & SequenceType.Stopping) > 0;\n    const shuffle: boolean = (this.sequenceType & SequenceType.Shuffle) > 0;\n\n    let seqBranchCount = this.sequenceElements.length;\n    if (once) {\n      seqBranchCount += 1;\n    }\n\n    // Chosen sequence index:\n    //  - Stopping: take the MIN(read count, num elements - 1)\n    //  - Once: take the MIN(read count, num elements)\n    //    (the last one being empty)\n    if (stopping || once) {\n      //var limit = stopping ? seqBranchCount-1 : seqBranchCount;\n      container.AddContent(new IntValue(seqBranchCount - 1));\n      container.AddContent(NativeFunctionCall.CallWithName(\"MIN\"));\n    } else if (cycle) {\n      // - Cycle: take (read count % num elements)\n      container.AddContent(new IntValue(this.sequenceElements.length));\n      container.AddContent(NativeFunctionCall.CallWithName(\"%\"));\n    }\n\n    // Shuffle\n    if (shuffle) {\n      // Create point to return to when sequence is complete\n      const postShuffleNoOp = RuntimeControlCommand.NoOp();\n\n      // When visitIndex == lastIdx, we skip the shuffle\n      if (once || stopping) {\n        // if( visitIndex == lastIdx ) -> skipShuffle\n        const lastIdx = stopping\n          ? this.sequenceElements.length - 1\n          : this.sequenceElements.length;\n\n        container.AddContent(RuntimeControlCommand.Duplicate());\n        container.AddContent(new IntValue(lastIdx));\n        container.AddContent(NativeFunctionCall.CallWithName(\"==\"));\n\n        const skipShuffleDivert = new RuntimeDivert();\n        skipShuffleDivert.isConditional = true;\n        container.AddContent(skipShuffleDivert);\n\n        this.AddDivertToResolve(skipShuffleDivert, postShuffleNoOp);\n      }\n\n      // This one's a bit more complex! Choose the index at runtime.\n      let elementCountToShuffle = this.sequenceElements.length;\n      if (stopping) {\n        elementCountToShuffle -= 1;\n      }\n\n      container.AddContent(new IntValue(elementCountToShuffle));\n      container.AddContent(RuntimeControlCommand.SequenceShuffleIndex());\n      if (once || stopping) {\n        container.AddContent(postShuffleNoOp);\n      }\n    }\n\n    container.AddContent(RuntimeControlCommand.EvalEnd());\n\n    // Create point to return to when sequence is complete\n    const postSequenceNoOp = RuntimeControlCommand.NoOp();\n\n    // Each of the main sequence branches, and one extra empty branch if\n    // we have a \"once\" sequence.\n    for (let elIndex = 0; elIndex < seqBranchCount; elIndex += 1) {\n      // This sequence element:\n      //  if( chosenIndex == this index ) divert to this sequence element\n      // duplicate chosen sequence index, since it'll be consumed by \"==\"\n      container.AddContent(RuntimeControlCommand.EvalStart());\n      container.AddContent(RuntimeControlCommand.Duplicate());\n      container.AddContent(new IntValue(elIndex));\n      container.AddContent(NativeFunctionCall.CallWithName(\"==\"));\n      container.AddContent(RuntimeControlCommand.EvalEnd());\n\n      // Divert branch for this sequence element\n      const sequenceDivert = new RuntimeDivert();\n      sequenceDivert.isConditional = true;\n      container.AddContent(sequenceDivert);\n\n      let contentContainerForSequenceBranch: RuntimeContainer;\n\n      // Generate content for this sequence element\n      if (elIndex < this.sequenceElements.length) {\n        const el = this.sequenceElements[elIndex];\n        contentContainerForSequenceBranch =\n          el.runtimeObject as RuntimeContainer;\n      } else {\n        // Final empty branch for \"once\" sequences\n        contentContainerForSequenceBranch = new RuntimeContainer();\n      }\n\n      contentContainerForSequenceBranch.name = `s${elIndex}`;\n      contentContainerForSequenceBranch.InsertContent(\n        RuntimeControlCommand.PopEvaluatedValue(),\n        0\n      );\n\n      // When sequence element is complete, divert back to end of sequence\n      const seqBranchCompleteDivert = new RuntimeDivert();\n      contentContainerForSequenceBranch.AddContent(seqBranchCompleteDivert);\n      container.AddToNamedContentOnly(contentContainerForSequenceBranch);\n\n      // Save the diverts for reference resolution later (in ResolveReferences)\n      this.AddDivertToResolve(\n        sequenceDivert,\n        contentContainerForSequenceBranch\n      );\n      this.AddDivertToResolve(seqBranchCompleteDivert, postSequenceNoOp);\n    }\n\n    container.AddContent(postSequenceNoOp);\n\n    return container;\n  };\n\n  public readonly AddDivertToResolve = (\n    divert: RuntimeDivert,\n    targetContent: RuntimeObject\n  ) => {\n    this._sequenceDivertsToResolve.push(\n      new SequenceDivertToResolve(divert, targetContent)\n    );\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    for (const toResolve of this._sequenceDivertsToResolve) {\n      toResolve.divert.targetPath = toResolve.targetContent.path;\n    }\n  }\n}\n","export enum CustomFlags {\n  ParsingString = 0x1,\n  TagActive = 0x2,\n}\n","import { Container as RuntimeContainer } from \"../../../engine/Container\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../engine/ControlCommand\";\nimport { Divert } from \"./Divert/Divert\";\nimport { Divert as RuntimeDivert } from \"../../../engine/Divert\";\nimport { DivertTargetValue } from \"../../../engine/Value\";\nimport { ParsedObject } from \"./Object\";\nimport { InkObject as RuntimeObject } from \"../../../engine/Object\";\nimport { Story } from \"./Story\";\nimport { Void } from \"../../../engine/Void\";\nimport { asOrNull } from \"../../../engine/TypeAssertion\";\nimport { VariableReference } from \"../../../engine/VariableReference\";\n\nexport class TunnelOnwards extends ParsedObject {\n  private _overrideDivertTarget: DivertTargetValue | null = null;\n\n  private _divertAfter: Divert | null = null;\n  get divertAfter() {\n    return this._divertAfter;\n  }\n\n  set divertAfter(value) {\n    this._divertAfter = value;\n    if (this._divertAfter) {\n      this.AddContent(this._divertAfter);\n    }\n  }\n\n  get typeName(): string {\n    return \"TunnelOnwards\";\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    const container = new RuntimeContainer();\n\n    // Set override path for tunnel onwards (or nothing)\n    container.AddContent(RuntimeControlCommand.EvalStart());\n\n    if (this.divertAfter) {\n      // Generate runtime object's generated code and steal the arguments runtime code\n      const returnRuntimeObj = this.divertAfter.GenerateRuntimeObject();\n      const returnRuntimeContainer = returnRuntimeObj as RuntimeContainer;\n      if (returnRuntimeContainer) {\n        // Steal all code for generating arguments from the divert\n        const args = this.divertAfter.args;\n        if (args !== null && args.length > 0) {\n          // Steal everything betwen eval start and eval end\n          let evalStart = -1;\n          let evalEnd = -1;\n          for (\n            let ii = 0;\n            ii < returnRuntimeContainer.content.length;\n            ii += 1\n          ) {\n            const cmd = returnRuntimeContainer.content[\n              ii\n            ] as RuntimeControlCommand;\n            if (cmd) {\n              if (\n                evalStart == -1 &&\n                cmd.commandType === RuntimeControlCommand.CommandType.EvalStart\n              ) {\n                evalStart = ii;\n              } else if (\n                cmd.commandType === RuntimeControlCommand.CommandType.EvalEnd\n              ) {\n                evalEnd = ii;\n              }\n            }\n          }\n\n          for (let ii = evalStart + 1; ii < evalEnd; ii += 1) {\n            const obj = returnRuntimeContainer.content[ii];\n            obj.parent = null; // prevent error of being moved between owners\n            container.AddContent(returnRuntimeContainer.content[ii]);\n          }\n        }\n      }\n      // Supply the divert target for the tunnel onwards target, either variable or more commonly, the explicit name\n      // var returnDivertObj = returnRuntimeObj as Runtime.Divert;\n      let returnDivertObj = asOrNull(returnRuntimeObj, RuntimeDivert);\n      if (returnDivertObj != null && returnDivertObj.hasVariableTarget) {\n        let runtimeVarRef = new VariableReference(\n          returnDivertObj.variableDivertName\n        );\n        container.AddContent(runtimeVarRef);\n      } else {\n        this._overrideDivertTarget = new DivertTargetValue();\n        container.AddContent(this._overrideDivertTarget);\n      }\n    } else {\n      // No divert after tunnel onwards\n      container.AddContent(new Void());\n    }\n\n    container.AddContent(RuntimeControlCommand.EvalEnd());\n    container.AddContent(RuntimeControlCommand.PopTunnel());\n\n    return container;\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    if (this.divertAfter && this.divertAfter.targetContent) {\n      this._overrideDivertTarget!.targetPath =\n        this.divertAfter.targetContent.runtimePath;\n    }\n  }\n\n  public toString = (): string => {\n    return ` -> ${this._divertAfter}`;\n  };\n}\n","import { InkListItem, SerializedInkListItem } from \"./InkList\";\nimport { TryGetResult } from \"./TryGetResult\";\n\nexport class ListDefinition {\n  public _name: string;\n  public _items: Map<SerializedInkListItem, number> | null;\n  public _itemNameToValues: Map<string, number>;\n\n  constructor(name: string, items: Map<string, number> | null) {\n    this._name = name || \"\";\n    this._items = null;\n    this._itemNameToValues = items || new Map();\n  }\n  get name() {\n    return this._name;\n  }\n  get items() {\n    if (this._items == null) {\n      this._items = new Map();\n      for (let [key, value] of this._itemNameToValues) {\n        let item = new InkListItem(this.name, key);\n        this._items.set(item.serialized(), value);\n      }\n    }\n\n    return this._items;\n  }\n\n  public ValueForItem(item: InkListItem) {\n    if (!item.itemName) return 0;\n\n    let intVal = this._itemNameToValues.get(item.itemName);\n    if (typeof intVal !== \"undefined\") return intVal;\n    else return 0;\n  }\n  public ContainsItem(item: InkListItem) {\n    if (!item.itemName) return false;\n    if (item.originName != this.name) return false;\n\n    return this._itemNameToValues.has(item.itemName);\n  }\n  public ContainsItemWithName(itemName: string) {\n    return this._itemNameToValues.has(itemName);\n  }\n  public TryGetItemWithValue(\n    val: number,\n    /* out */ item: InkListItem\n  ): TryGetResult<InkListItem> {\n    for (let [key, value] of this._itemNameToValues) {\n      if (value == val) {\n        item = new InkListItem(this.name, key);\n        return { result: item, exists: true };\n      }\n    }\n\n    item = InkListItem.Null;\n    return { result: item, exists: false };\n  }\n  public TryGetValueForItem(\n    item: InkListItem,\n    /* out */ intVal: number\n  ): TryGetResult<number> {\n    if (!item.itemName) return { result: 0, exists: false };\n    let value = this._itemNameToValues.get(item.itemName);\n\n    if (!value) return { result: 0, exists: false };\n    return { result: value, exists: true };\n  }\n}\n","import { InkList as RuntimeInkList } from \"../../../../engine/InkList\";\nimport { InkListItem as RuntimeInkListItem } from \"../../../../engine/InkList\";\nimport { ListDefinition as RuntimeListDefinition } from \"../../../../engine/ListDefinition\";\nimport { ListElementDefinition } from \"./ListElementDefinition\";\nimport { ListValue } from \"../../../../engine/Value\";\nimport { ParsedObject } from \"../Object\";\nimport { Story } from \"../Story\";\nimport { SymbolType } from \"../SymbolType\";\nimport { VariableAssignment } from \"../Variable/VariableAssignment\";\nimport { Identifier } from \"../Identifier\";\n\nexport class ListDefinition extends ParsedObject {\n  public identifier: Identifier | null = null;\n  public variableAssignment: VariableAssignment | null = null;\n\n  get typeName() {\n    return \"ListDefinition\";\n  }\n\n  private _elementsByName: Map<string, ListElementDefinition> | null = null;\n\n  get runtimeListDefinition(): RuntimeListDefinition {\n    const allItems: Map<string, number> = new Map();\n    for (const e of this.itemDefinitions) {\n      if (!allItems.has(e.name!)) {\n        allItems.set(e.name!, e.seriesValue);\n      } else {\n        this.Error(\n          `List '${this.identifier}' contains duplicate items called '${e.name}'`\n        );\n      }\n    }\n\n    return new RuntimeListDefinition(this.identifier?.name || \"\", allItems);\n  }\n\n  public readonly ItemNamed = (\n    itemName: string\n  ): ListElementDefinition | null => {\n    if (this._elementsByName === null) {\n      this._elementsByName = new Map();\n\n      for (const el of this.itemDefinitions) {\n        this._elementsByName.set(el.name!, el);\n      }\n    }\n\n    const foundElement = this._elementsByName.get(itemName) || null;\n\n    return foundElement;\n  };\n\n  constructor(public itemDefinitions: ListElementDefinition[]) {\n    super();\n\n    let currentValue = 1;\n    for (const e of this.itemDefinitions) {\n      if (e.explicitValue !== null) {\n        currentValue = e.explicitValue;\n      }\n\n      e.seriesValue = currentValue;\n\n      currentValue += 1;\n    }\n\n    this.AddContent(itemDefinitions as any);\n  }\n\n  public readonly GenerateRuntimeObject = (): ListValue => {\n    const initialValues = new RuntimeInkList();\n    for (const itemDef of this.itemDefinitions) {\n      if (itemDef.inInitialList) {\n        const item = new RuntimeInkListItem(\n          this.identifier?.name || null,\n          itemDef.name || null\n        );\n        initialValues.Add(item, itemDef.seriesValue);\n      }\n    }\n\n    // Set origin name, so\n    initialValues.SetInitialOriginName(this.identifier?.name || \"\");\n\n    return new ListValue(initialValues);\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n    context.CheckForNamingCollisions(this, this.identifier!, SymbolType.List);\n  }\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { Expression } from \"../Expression/Expression\";\nimport { FlowBase } from \"../Flow/FlowBase\";\nimport { ClosestFlowBase } from \"../Flow/ClosestFlowBase\";\nimport { ListDefinition } from \"../List/ListDefinition\";\nimport { ParsedObject } from \"../Object\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\nimport { Story } from \"../Story\";\nimport { SymbolType } from \"../SymbolType\";\nimport { VariableAssignment as RuntimeVariableAssignment } from \"../../../../engine/VariableAssignment\";\nimport { VariableReference } from \"./VariableReference\";\nimport { Identifier } from \"../Identifier\";\nimport { asOrNull } from \"../../../../engine/TypeAssertion\";\n\nexport class VariableAssignment extends ParsedObject {\n  private _runtimeAssignment: RuntimeVariableAssignment | null = null;\n\n  get variableName(): string {\n    return this.variableIdentifier.name!;\n  }\n  public readonly variableIdentifier: Identifier;\n  public readonly expression: Expression | null = null;\n  public readonly listDefinition: ListDefinition | null = null;\n  public readonly isGlobalDeclaration: boolean;\n  public readonly isNewTemporaryDeclaration: boolean;\n\n  get typeName() {\n    if (this.isNewTemporaryDeclaration) {\n      return \"temp\";\n    } else if (this.isGlobalDeclaration) {\n      if (this.listDefinition !== null) {\n        return \"LIST\";\n      }\n      return \"VAR\";\n    }\n\n    return \"variable assignment\";\n  }\n\n  get isDeclaration(): boolean {\n    return this.isGlobalDeclaration || this.isNewTemporaryDeclaration;\n  }\n\n  constructor({\n    assignedExpression,\n    isGlobalDeclaration,\n    isTemporaryNewDeclaration,\n    listDef,\n    variableIdentifier,\n  }: {\n    readonly assignedExpression?: Expression;\n    readonly isGlobalDeclaration?: boolean;\n    readonly isTemporaryNewDeclaration?: boolean;\n    readonly listDef?: ListDefinition;\n    readonly variableIdentifier: Identifier;\n  }) {\n    super();\n\n    this.variableIdentifier = variableIdentifier;\n    this.isGlobalDeclaration = Boolean(isGlobalDeclaration);\n    this.isNewTemporaryDeclaration = Boolean(isTemporaryNewDeclaration);\n\n    // Defensive programming in case parsing of assignedExpression failed\n    if (listDef instanceof ListDefinition) {\n      this.listDefinition = this.AddContent(listDef) as ListDefinition;\n      this.listDefinition.variableAssignment = this;\n\n      // List definitions are always global\n      this.isGlobalDeclaration = true;\n    } else if (assignedExpression) {\n      this.expression = this.AddContent(assignedExpression) as Expression;\n    }\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject | null => {\n    let newDeclScope: FlowBase | null | undefined = null;\n    if (this.isGlobalDeclaration) {\n      newDeclScope = this.story;\n    } else if (this.isNewTemporaryDeclaration) {\n      newDeclScope = ClosestFlowBase(this);\n    }\n\n    if (newDeclScope) {\n      newDeclScope.AddNewVariableDeclaration(this);\n    }\n\n    // Global declarations don't generate actual procedural\n    // runtime objects, but instead add a global variable to the story itself.\n    // The story then initialises them all in one go at the start of the game.\n    if (this.isGlobalDeclaration) {\n      return null;\n    }\n\n    const container = new RuntimeContainer();\n\n    // The expression's runtimeObject is actually another nested container\n    if (this.expression) {\n      container.AddContent(this.expression.runtimeObject);\n    } else if (this.listDefinition) {\n      container.AddContent(this.listDefinition.runtimeObject);\n    }\n\n    this._runtimeAssignment = new RuntimeVariableAssignment(\n      this.variableName,\n      this.isNewTemporaryDeclaration\n    );\n\n    container.AddContent(this._runtimeAssignment);\n\n    return container;\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    // List definitions are checked for conflicts separately\n    if (this.isDeclaration && this.listDefinition === null) {\n      context.CheckForNamingCollisions(\n        this,\n        this.variableIdentifier,\n        this.isGlobalDeclaration ? SymbolType.Var : SymbolType.Temp\n      );\n    }\n\n    // Initial VAR x = [intialValue] declaration, not re-assignment\n    if (this.isGlobalDeclaration) {\n      const variableReference = asOrNull(this.expression, VariableReference);\n      if (\n        variableReference &&\n        !variableReference.isConstantReference &&\n        !variableReference.isListItemReference\n      ) {\n        this.Error(\n          \"global variable assignments cannot refer to other variables, only literal values, constants and list items\"\n        );\n      }\n    }\n\n    if (!this.isNewTemporaryDeclaration) {\n      const resolvedVarAssignment = context.ResolveVariableWithName(\n        this.variableName,\n        this\n      );\n\n      if (!resolvedVarAssignment.found) {\n        if (this.variableName in this.story.constants) {\n          this.Error(\n            `Can't re-assign to a constant (do you need to use VAR when declaring '${this.variableName}'?)`,\n            this\n          );\n        } else {\n          this.Error(\n            `Variable could not be found to assign to: '${this.variableName}'`,\n            this\n          );\n        }\n      }\n\n      // A runtime assignment may not have been generated if it's the initial global declaration,\n      // since these are hoisted out and handled specially in Story.ExportRuntime.\n      if (this._runtimeAssignment) {\n        this._runtimeAssignment.isGlobal = resolvedVarAssignment.isGlobal;\n      }\n    }\n  }\n\n  public readonly toString = (): string =>\n    `${\n      this.isGlobalDeclaration\n        ? \"VAR\"\n        : this.isNewTemporaryDeclaration\n        ? \"~ temp\"\n        : \"\"\n    } ${this.variableName}`;\n}\n","import { AuthorWarning } from \"./AuthorWarning\";\nimport { Choice } from \"./Choice\";\nimport { Conditional } from \"./Conditional/Conditional\";\nimport { ConstantDeclaration } from \"./Declaration/ConstantDeclaration\";\nimport { Container as RuntimeContainer } from \"../../../engine/Container\";\nimport { Divert } from \"./Divert/Divert\";\nimport { Divert as RuntimeDivert } from \"../../../engine/Divert\";\nimport { DivertTarget } from \"./Divert/DivertTarget\";\nimport { FlowBase } from \"./Flow/FlowBase\";\nimport { Gather } from \"./Gather/Gather\";\nimport { GatherPointToResolve } from \"./Gather/GatherPointToResolve\";\nimport { IWeavePoint } from \"./IWeavePoint\";\nimport { ParsedObject } from \"./Object\";\nimport { InkObject as RuntimeObject } from \"../../../engine/Object\";\nimport { Sequence } from \"./Sequence/Sequence\";\nimport { Story } from \"./Story\";\nimport { Text } from \"./Text\";\nimport { TunnelOnwards } from \"./TunnelOnwards\";\nimport { VariableAssignment } from \"./Variable/VariableAssignment\";\nimport { asOrNull } from \"../../../engine/TypeAssertion\";\n\ntype BadTerminationHandler = (terminatingObj: ParsedObject) => void;\n\n// Used by the FlowBase when constructing the weave flow from\n// a flat list of content objects.\nexport class Weave extends ParsedObject {\n  // Containers can be chained as multiple gather points\n  // get created as the same indentation level.\n  // rootContainer is always the first in the chain, while\n  // currentContainer is the latest.\n  get rootContainer(): RuntimeContainer {\n    if (!this._rootContainer) {\n      this._rootContainer = this.GenerateRuntimeObject();\n    }\n\n    return this._rootContainer;\n  }\n\n  // Keep track of previous weave point (Choice or Gather)\n  // at the current indentation level:\n  //  - to add ordinary content to be nested under it\n  //  - to add nested content under it when it's indented\n  //  - to remove it from the list of loose ends when\n  //     - it has indented content since it's no longer a loose end\n  //     - it's a gather and it has a choice added to it\n  public previousWeavePoint: IWeavePoint | null = null;\n  public addContentToPreviousWeavePoint: boolean = false;\n\n  // Used for determining whether the next Gather should auto-enter\n  public hasSeenChoiceInSection: boolean = false;\n\n  public currentContainer: RuntimeContainer | null = null;\n  public baseIndentIndex: number;\n\n  private _unnamedGatherCount: number = 0;\n  private _choiceCount: number = 0;\n  private _rootContainer: RuntimeContainer | null = null;\n  private _namedWeavePoints: Map<string, IWeavePoint> = new Map();\n  get namedWeavePoints() {\n    return this._namedWeavePoints;\n  }\n\n  // Loose ends are:\n  //  - Choices or Gathers that need to be joined up\n  //  - Explicit Divert to gather points (i.e. \"->\" without a target)\n  public looseEnds: IWeavePoint[] = [];\n\n  public gatherPointsToResolve: GatherPointToResolve[] = [];\n\n  get lastParsedSignificantObject(): ParsedObject | null {\n    if (this.content.length === 0) {\n      return null;\n    }\n\n    // Don't count extraneous newlines or VAR/CONST declarations,\n    // since they're \"empty\" statements outside of the main flow.\n    let lastObject: ParsedObject | null = null;\n    for (let ii = this.content.length - 1; ii >= 0; --ii) {\n      lastObject = this.content[ii];\n\n      let lastText = asOrNull(lastObject, Text);\n      if (lastText && lastText.text === \"\\n\") {\n        continue;\n      }\n\n      if (this.IsGlobalDeclaration(lastObject)) {\n        continue;\n      }\n\n      break;\n    }\n\n    const lastWeave = asOrNull(lastObject, Weave);\n    if (lastWeave) {\n      lastObject = lastWeave.lastParsedSignificantObject;\n    }\n\n    return lastObject;\n  }\n\n  constructor(cont: ParsedObject[], indentIndex: number = -1) {\n    super();\n\n    if (indentIndex == -1) {\n      this.baseIndentIndex = this.DetermineBaseIndentationFromContent(cont);\n    } else {\n      this.baseIndentIndex = indentIndex;\n    }\n\n    this.AddContent(cont);\n\n    this.ConstructWeaveHierarchyFromIndentation();\n  }\n\n  get typeName(): string {\n    return \"Weave\";\n  }\n\n  public readonly ResolveWeavePointNaming = (): void => {\n    const namedWeavePoints = [\n      ...this.FindAll<IWeavePoint>(Gather)(\n        (w) => !(w.name === null || w.name === undefined)\n      ),\n      ...this.FindAll<IWeavePoint>(Choice)(\n        (w) => !(w.name === null || w.name === undefined)\n      ),\n    ];\n    this._namedWeavePoints = new Map();\n\n    for (const weavePoint of namedWeavePoints) {\n      // Check for weave point naming collisions\n      const existingWeavePoint: IWeavePoint | null | undefined =\n        this.namedWeavePoints.get(weavePoint.identifier?.name || \"\");\n\n      if (existingWeavePoint) {\n        const typeName =\n          existingWeavePoint instanceof Gather ? \"gather\" : \"choice\";\n        const existingObj: ParsedObject = existingWeavePoint;\n\n        this.Error(\n          `A ${typeName} with the same label name '${\n            weavePoint.name\n          }' already exists in this context on line ${\n            existingObj.debugMetadata\n              ? existingObj.debugMetadata.startLineNumber\n              : \"NO DEBUG METADATA AVAILABLE\"\n          }`,\n          weavePoint as ParsedObject\n        );\n      }\n      if (weavePoint.identifier?.name) {\n        this.namedWeavePoints.set(weavePoint.identifier?.name, weavePoint);\n      }\n    }\n  };\n\n  public readonly ConstructWeaveHierarchyFromIndentation = (): void => {\n    // Find nested indentation and convert to a proper object hierarchy\n    // (i.e. indented content is replaced with a Weave object that contains\n    // that nested content)\n    let contentIdx = 0;\n    while (contentIdx < this.content.length) {\n      const obj: ParsedObject = this.content[contentIdx];\n\n      // Choice or Gather\n      if (obj instanceof Choice || obj instanceof Gather) {\n        const weavePoint: IWeavePoint = obj;\n        const weaveIndentIdx = weavePoint.indentationDepth - 1;\n\n        // Inner level indentation - recurse\n        if (weaveIndentIdx > this.baseIndentIndex) {\n          // Step through content until indent jumps out again\n          let innerWeaveStartIdx = contentIdx;\n          while (contentIdx < this.content.length) {\n            const innerWeaveObj =\n              asOrNull(this.content[contentIdx], Choice) ||\n              asOrNull(this.content[contentIdx], Gather);\n            if (innerWeaveObj !== null) {\n              const innerIndentIdx = innerWeaveObj.indentationDepth - 1;\n              if (innerIndentIdx <= this.baseIndentIndex) {\n                break;\n              }\n            }\n\n            contentIdx += 1;\n          }\n\n          const weaveContentCount = contentIdx - innerWeaveStartIdx;\n          const weaveContent = this.content.slice(\n            innerWeaveStartIdx,\n            innerWeaveStartIdx + weaveContentCount\n          );\n\n          this.content.splice(innerWeaveStartIdx, weaveContentCount);\n\n          const weave = new Weave(weaveContent, weaveIndentIdx);\n          this.InsertContent(innerWeaveStartIdx, weave);\n\n          // Continue iteration from this point\n          contentIdx = innerWeaveStartIdx;\n        }\n      }\n\n      contentIdx += 1;\n    }\n  };\n\n  // When the indentation wasn't told to us at construction time using\n  // a choice point with a known indentation level, we may be told to\n  // determine the indentation level by incrementing from our closest ancestor.\n  public readonly DetermineBaseIndentationFromContent = (\n    contentList: ParsedObject[]\n  ): number => {\n    for (const obj of contentList) {\n      if (obj instanceof Choice || obj instanceof Gather) {\n        return obj.indentationDepth - 1;\n      }\n    }\n\n    // No weave points, so it doesn't matter\n    return 0;\n  };\n\n  public readonly GenerateRuntimeObject = (): RuntimeContainer => {\n    this._rootContainer = new RuntimeContainer();\n    this.currentContainer = this._rootContainer;\n    this.looseEnds = [];\n    this.gatherPointsToResolve = [];\n\n    // Iterate through content for the block at this level of indentation\n    //  - Normal content is nested under Choices and Gathers\n    //  - Blocks that are further indented cause recursion\n    //  - Keep track of loose ends so that they can be diverted to Gathers\n    for (const obj of this.content) {\n      // Choice or Gather\n      if (obj instanceof Choice || obj instanceof Gather) {\n        this.AddRuntimeForWeavePoint(obj as IWeavePoint);\n      } else {\n        // Non-weave point\n        if (obj instanceof Weave) {\n          // Nested weave\n          const weave = obj;\n          this.AddRuntimeForNestedWeave(weave);\n          this.gatherPointsToResolve.splice(\n            0,\n            0,\n            ...weave.gatherPointsToResolve\n          );\n        } else {\n          // Other object\n          // May be complex object that contains statements - e.g. a multi-line conditional\n          this.AddGeneralRuntimeContent(obj.runtimeObject);\n        }\n      }\n    }\n\n    // Pass any loose ends up the hierarhcy\n    this.PassLooseEndsToAncestors();\n\n    return this._rootContainer;\n  };\n\n  // Found gather point:\n  //  - gather any loose ends\n  //  - set the gather as the main container to dump new content in\n  public readonly AddRuntimeForGather = (gather: Gather): void => {\n    // Determine whether this Gather should be auto-entered:\n    //  - It is auto-entered if there were no choices in the last section\n    //  - A section is \"since the previous gather\" - so reset now\n    const autoEnter = !this.hasSeenChoiceInSection;\n    this.hasSeenChoiceInSection = false;\n\n    const gatherContainer = gather.runtimeContainer;\n\n    if (!gather.name) {\n      // Use disallowed character so it's impossible to have a name collision\n      gatherContainer.name = `g-${this._unnamedGatherCount}`;\n      this._unnamedGatherCount += 1;\n    }\n\n    if (autoEnter) {\n      if (!this.currentContainer) {\n        throw new Error();\n      }\n\n      // Auto-enter: include in main content\n      this.currentContainer.AddContent(gatherContainer);\n    } else {\n      // Don't auto-enter:\n      // Add this gather to the main content, but only accessible\n      // by name so that it isn't stepped into automatically, but only via\n      // a divert from a loose end.\n      this.rootContainer.AddToNamedContentOnly(gatherContainer);\n    }\n\n    // Consume loose ends: divert them to this gather\n    for (const looseEndWeavePoint of this.looseEnds) {\n      const looseEnd = looseEndWeavePoint as ParsedObject;\n\n      // Skip gather loose ends that are at the same level\n      // since they'll be handled by the auto-enter code below\n      // that only jumps into the gather if (current runtime choices == 0)\n      if (looseEnd instanceof Gather) {\n        const prevGather = looseEnd;\n        if (prevGather.indentationDepth == gather.indentationDepth) {\n          continue;\n        }\n      }\n\n      let divert: RuntimeDivert | null = null;\n      if (looseEnd instanceof Divert) {\n        divert = looseEnd.runtimeObject as RuntimeDivert;\n      } else {\n        divert = new RuntimeDivert();\n        const looseWeavePoint = looseEnd as IWeavePoint;\n        if (!looseWeavePoint.runtimeContainer) {\n          throw new Error();\n        }\n\n        looseWeavePoint.runtimeContainer.AddContent(divert);\n      }\n\n      // Pass back knowledge of this loose end being diverted\n      // to the FlowBase so that it can maintain a list of them,\n      // and resolve the divert references later\n      this.gatherPointsToResolve.push(\n        new GatherPointToResolve(divert, gatherContainer)\n      );\n    }\n\n    this.looseEnds = [];\n\n    // Replace the current container itself\n    this.currentContainer = gatherContainer;\n  };\n\n  public readonly AddRuntimeForWeavePoint = (weavePoint: IWeavePoint): void => {\n    // Current level Gather\n    if (weavePoint instanceof Gather) {\n      this.AddRuntimeForGather(weavePoint);\n    }\n\n    // Current level choice\n    else if (weavePoint instanceof Choice) {\n      if (!this.currentContainer) {\n        throw new Error();\n      }\n\n      // Gathers that contain choices are no longer loose ends\n      // (same as when weave points get nested content)\n      if (this.previousWeavePoint instanceof Gather) {\n        this.looseEnds.splice(\n          this.looseEnds.indexOf(this.previousWeavePoint),\n          1\n        );\n      }\n\n      // Add choice point content\n      const choice = weavePoint; //, Choice);\n\n      this.currentContainer.AddContent(choice.runtimeObject);\n      if (!choice.innerContentContainer) {\n        throw new Error();\n      } //guaranteed not to happen\n\n      // Add choice's inner content to self\n      choice.innerContentContainer.name = `c-${this._choiceCount}`;\n      this.currentContainer.AddToNamedContentOnly(choice.innerContentContainer);\n      this._choiceCount += 1;\n\n      this.hasSeenChoiceInSection = true;\n    }\n\n    // Keep track of loose ends\n    this.addContentToPreviousWeavePoint = false; // default\n    if (this.WeavePointHasLooseEnd(weavePoint)) {\n      this.looseEnds.push(weavePoint);\n\n      const looseChoice = asOrNull(weavePoint, Choice);\n      if (looseChoice) {\n        this.addContentToPreviousWeavePoint = true;\n      }\n    }\n\n    this.previousWeavePoint = weavePoint;\n  };\n\n  // Add nested block at a greater indentation level\n  public readonly AddRuntimeForNestedWeave = (nestedResult: Weave): void => {\n    // Add this inner block to current container\n    // (i.e. within the main container, or within the last defined Choice/Gather)\n    this.AddGeneralRuntimeContent(nestedResult.rootContainer);\n\n    // Now there's a deeper indentation level, the previous weave point doesn't\n    // count as a loose end (since it will have content to go to)\n    if (this.previousWeavePoint !== null) {\n      this.looseEnds.splice(this.looseEnds.indexOf(this.previousWeavePoint), 1);\n\n      this.addContentToPreviousWeavePoint = false;\n    }\n  };\n\n  // Normal content gets added into the latest Choice or Gather by default,\n  // unless there hasn't been one yet.\n  public readonly AddGeneralRuntimeContent = (content: RuntimeObject): void => {\n    // Content is allowed to evaluate runtimeObject to null\n    // (e.g. AuthorWarning, which doesn't make it into the runtime)\n    if (content === null) {\n      return;\n    }\n\n    if (this.addContentToPreviousWeavePoint) {\n      if (\n        !this.previousWeavePoint ||\n        !this.previousWeavePoint.runtimeContainer\n      ) {\n        throw new Error();\n      }\n\n      this.previousWeavePoint.runtimeContainer.AddContent(content);\n    } else {\n      if (!this.currentContainer) {\n        throw new Error();\n      }\n\n      this.currentContainer.AddContent(content);\n    }\n  };\n\n  public readonly PassLooseEndsToAncestors = () => {\n    if (this.looseEnds.length === 0) {\n      return;\n    }\n\n    // Search for Weave ancestor to pass loose ends to for gathering.\n    // There are two types depending on whether the current weave\n    // is separated by a conditional or sequence.\n    //  - An \"inner\" weave is one that is directly connected to the current\n    //    weave - i.e. you don't have to pass through a conditional or\n    //    sequence to get to it. We're allowed to pass all loose ends to\n    //    one of these.\n    //  - An \"outer\" weave is one that is outside of a conditional/sequence\n    //    that the current weave is nested within. We're only allowed to\n    //    pass gathers (i.e. 'normal flow') loose ends up there, not normal\n    //    choices. The rule is that choices have to be diverted explicitly\n    //    by the author since it's ambiguous where flow should go otherwise.\n    //\n    // e.g.:\n    //\n    //   - top                       <- e.g. outer weave\n    //   {true:\n    //       * choice                <- e.g. inner weave\n    //         * * choice 2\n    //             more content      <- e.g. current weave\n    //       * choice 2\n    //   }\n    //   - more of outer weave\n    //\n    let closestInnerWeaveAncestor: Weave | null = null;\n    let closestOuterWeaveAncestor: Weave | null = null;\n\n    // Find inner and outer ancestor weaves as defined above.\n    let nested = false;\n    for (\n      let ancestor = this.parent;\n      ancestor !== null;\n      ancestor = ancestor.parent\n    ) {\n      // Found ancestor?\n      const weaveAncestor = asOrNull(ancestor, Weave);\n      if (weaveAncestor) {\n        if (!nested && closestInnerWeaveAncestor === null) {\n          closestInnerWeaveAncestor = weaveAncestor;\n        }\n\n        if (nested && closestOuterWeaveAncestor === null) {\n          closestOuterWeaveAncestor = weaveAncestor;\n        }\n      }\n\n      // Weaves nested within Sequences or Conditionals are\n      // \"sealed\" - any loose ends require explicit diverts.\n      if (ancestor instanceof Sequence || ancestor instanceof Conditional) {\n        nested = true;\n      }\n    }\n\n    // No weave to pass loose ends to at all?\n    if (\n      closestInnerWeaveAncestor === null &&\n      closestOuterWeaveAncestor === null\n    ) {\n      return;\n    }\n\n    // Follow loose end passing logic as defined above\n    for (let ii = this.looseEnds.length - 1; ii >= 0; ii -= 1) {\n      const looseEnd = this.looseEnds[ii];\n      let received = false;\n\n      if (nested) {\n        // This weave is nested within a conditional or sequence:\n        //  - choices can only be passed up to direct ancestor (\"inner\") weaves\n        //  - gathers can be passed up to either, but favour the closer (inner) weave\n        //    if there is one\n        if (looseEnd instanceof Choice && closestInnerWeaveAncestor !== null) {\n          closestInnerWeaveAncestor.ReceiveLooseEnd(looseEnd);\n          received = true;\n        } else if (!(looseEnd instanceof Choice)) {\n          const receivingWeave =\n            closestInnerWeaveAncestor || closestOuterWeaveAncestor;\n          if (receivingWeave !== null) {\n            receivingWeave.ReceiveLooseEnd(looseEnd);\n            received = true;\n          }\n        }\n      } else {\n        // No nesting, all loose ends can be safely passed up\n        if (closestInnerWeaveAncestor?.hasOwnProperty(\"ReceiveLooseEnd\")) {\n          closestInnerWeaveAncestor!.ReceiveLooseEnd(looseEnd);\n        }\n        received = true;\n      }\n\n      if (received) {\n        this.looseEnds.splice(ii, 1);\n      }\n    }\n  };\n\n  public readonly ReceiveLooseEnd = (childWeaveLooseEnd: IWeavePoint): void => {\n    this.looseEnds.push(childWeaveLooseEnd);\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    // Check that choices nested within conditionals and sequences are terminated\n    if (this.looseEnds !== null && this.looseEnds.length > 0) {\n      let isNestedWeave = false;\n      for (\n        let ancestor = this.parent;\n        ancestor !== null;\n        ancestor = ancestor.parent\n      ) {\n        if (ancestor instanceof Sequence || ancestor instanceof Conditional) {\n          isNestedWeave = true;\n          break;\n        }\n      }\n\n      if (isNestedWeave) {\n        this.ValidateTermination(this.BadNestedTerminationHandler);\n      }\n    }\n\n    for (const gatherPoint of this.gatherPointsToResolve) {\n      gatherPoint.divert.targetPath = gatherPoint.targetRuntimeObj.path;\n    }\n\n    this.CheckForWeavePointNamingCollisions();\n  }\n\n  public readonly WeavePointNamed = (name: string): IWeavePoint | null => {\n    if (!this.namedWeavePoints) {\n      return null;\n    }\n\n    let weavePointResult: IWeavePoint | null | undefined =\n      this.namedWeavePoints.get(name);\n    if (weavePointResult) {\n      return weavePointResult;\n    }\n\n    return null;\n  };\n\n  // Global VARs and CONSTs are treated as \"outside of the flow\"\n  // when iterating over content that follows loose ends\n  public readonly IsGlobalDeclaration = (obj: ParsedObject) => {\n    const varAss = asOrNull(obj, VariableAssignment);\n    if (varAss && varAss.isGlobalDeclaration && varAss.isDeclaration) {\n      return true;\n    }\n\n    const constDecl = asOrNull(obj, ConstantDeclaration);\n    if (constDecl) {\n      return true;\n    }\n\n    return false;\n  };\n\n  // While analysing final loose ends, we look to see whether there\n  // are any diverts etc which choices etc divert from\n  public readonly ContentThatFollowsWeavePoint = (\n    weavePoint: IWeavePoint\n  ): ParsedObject[] => {\n    const returned = [];\n    const obj = weavePoint as ParsedObject;\n\n    // Inner content first (e.g. for a choice)\n    if (obj.content !== null) {\n      for (const contentObj of obj.content) {\n        // Global VARs and CONSTs are treated as \"outside of the flow\"\n        if (this.IsGlobalDeclaration(contentObj)) {\n          continue;\n        }\n\n        returned.push(contentObj);\n      }\n    }\n\n    const parentWeave = asOrNull(obj.parent, Weave);\n    if (parentWeave === null) {\n      throw new Error(\"Expected weave point parent to be weave?\");\n    }\n\n    const weavePointIdx = parentWeave.content.indexOf(obj);\n    for (let ii = weavePointIdx + 1; ii < parentWeave.content.length; ii += 1) {\n      const laterObj = parentWeave.content[ii];\n\n      // Global VARs and CONSTs are treated as \"outside of the flow\"\n      if (this.IsGlobalDeclaration(laterObj)) {\n        continue;\n      }\n\n      // End of the current flow\n      // if (laterObj instanceof IWeavePoint) // cannot test on interface in ts\n      if (laterObj instanceof Choice || laterObj instanceof Gather) {\n        break;\n      }\n\n      // Other weaves will be have their own loose ends\n      if (laterObj instanceof Weave) {\n        break;\n      }\n\n      returned.push(laterObj);\n    }\n\n    return returned;\n  };\n\n  public readonly ValidateTermination = (\n    badTerminationHandler: BadTerminationHandler\n  ): void => {\n    // Don't worry if the last object in the flow is a \"TODO\",\n    // even if there are other loose ends in other places\n    if (this.lastParsedSignificantObject instanceof AuthorWarning) {\n      return;\n    }\n\n    // By now, any sub-weaves will have passed loose ends up to the root weave (this).\n    // So there are 2 possible situations:\n    //  - There are loose ends from somewhere in the flow.\n    //    These aren't necessarily \"real\" loose ends - they're weave points\n    //    that don't connect to any lower weave points, so we just\n    //    have to check that they terminate properly.\n    //  - This weave is just a list of content with no actual weave points,\n    //    so we just need to check that the list of content terminates.\n\n    const hasLooseEnds: boolean =\n      this.looseEnds !== null && this.looseEnds.length > 0;\n\n    if (hasLooseEnds) {\n      for (const looseEnd of this.looseEnds) {\n        const looseEndFlow = this.ContentThatFollowsWeavePoint(looseEnd);\n        this.ValidateFlowOfObjectsTerminates(\n          looseEndFlow,\n          looseEnd as ParsedObject,\n          badTerminationHandler\n        );\n      }\n    } else {\n      // No loose ends... is there any inner weaving at all?\n      // If not, make sure the single content stream is terminated correctly\n      //\n      // If there's any actual weaving, assume that content is\n      // terminated correctly since we would've had a loose end otherwise\n      for (const obj of this.content) {\n        if (obj instanceof Choice || obj instanceof Divert) {\n          return;\n        }\n      }\n\n      // Straight linear flow? Check it terminates\n      this.ValidateFlowOfObjectsTerminates(\n        this.content,\n        this,\n        badTerminationHandler\n      );\n    }\n  };\n\n  readonly BadNestedTerminationHandler: BadTerminationHandler = (\n    terminatingObj\n  ) => {\n    let conditional: Conditional | null = null;\n    for (\n      let ancestor = terminatingObj.parent;\n      ancestor !== null;\n      ancestor = ancestor.parent\n    ) {\n      if (ancestor instanceof Sequence || ancestor instanceof Conditional) {\n        conditional = asOrNull(ancestor, Conditional);\n        break;\n      }\n    }\n\n    let errorMsg =\n      \"Choices nested in conditionals or sequences need to explicitly divert afterwards.\";\n\n    // Tutorialise proper choice syntax if this looks like a single choice within a condition, e.g.\n    // { condition:\n    //      * choice\n    // }\n    if (conditional !== null) {\n      let numChoices = conditional.FindAll<Choice>(Choice)().length;\n      if (numChoices === 1) {\n        errorMsg = `Choices with conditions should be written: '* {condition} choice'. Otherwise, ${errorMsg.toLowerCase()}`;\n      }\n    }\n\n    this.Error(errorMsg, terminatingObj);\n  };\n\n  public readonly ValidateFlowOfObjectsTerminates = (\n    objFlow: ParsedObject[],\n    defaultObj: ParsedObject,\n    badTerminationHandler: BadTerminationHandler\n  ) => {\n    let terminated = false;\n    let terminatingObj: ParsedObject = defaultObj;\n    for (const flowObj of objFlow) {\n      const divert = flowObj.Find(Divert)(\n        (d) =>\n          !d.isThread &&\n          !d.isTunnel &&\n          !d.isFunctionCall &&\n          !(d.parent instanceof DivertTarget)\n      );\n\n      if (divert !== null) {\n        terminated = true;\n      }\n\n      if (flowObj.Find(TunnelOnwards)() != null) {\n        terminated = true;\n        break;\n      }\n\n      terminatingObj = flowObj;\n    }\n\n    if (!terminated) {\n      // Author has left a note to self here - clearly we don't need\n      // to leave them with another warning since they know what they're doing.\n      if (terminatingObj instanceof AuthorWarning) {\n        return;\n      }\n\n      badTerminationHandler(terminatingObj);\n    }\n  };\n\n  public readonly WeavePointHasLooseEnd = (\n    weavePoint: IWeavePoint\n  ): boolean => {\n    // No content, must be a loose end.\n    if (weavePoint.content === null) {\n      return true;\n    }\n\n    // If a weave point is diverted from, it doesn't have a loose end.\n    // Detect a divert object within a weavePoint's main content\n    // Work backwards since we're really interested in the end,\n    // although it doesn't actually make a difference!\n    // (content after a divert will simply be inaccessible)\n    for (let ii = weavePoint.content.length - 1; ii >= 0; --ii) {\n      let innerDivert = asOrNull(weavePoint.content[ii], Divert);\n      if (innerDivert) {\n        const willReturn =\n          innerDivert.isThread ||\n          innerDivert.isTunnel ||\n          innerDivert.isFunctionCall;\n        if (!willReturn) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  };\n\n  // Enforce rule that weave points must not have the same\n  // name as any stitches or knots upwards in the hierarchy\n  public readonly CheckForWeavePointNamingCollisions = (): void => {\n    if (!this.namedWeavePoints) {\n      return;\n    }\n\n    const ancestorFlows = [];\n    for (const obj of this.ancestry) {\n      const flow = asOrNull(obj, FlowBase);\n      if (flow) {\n        ancestorFlows.push(flow);\n      } else {\n        break;\n      }\n    }\n\n    for (const [weavePointName, weavePoint] of this.namedWeavePoints) {\n      for (const flow of ancestorFlows) {\n        // Shallow search\n        const otherContentWithName =\n          flow.ContentWithNameAtLevel(weavePointName);\n        if (otherContentWithName && otherContentWithName !== weavePoint) {\n          const errorMsg = `${weavePoint.GetType()} '${weavePointName}' has the same label name as a ${otherContentWithName.GetType()} (on ${\n            otherContentWithName.debugMetadata\n          })`;\n          this.Error(errorMsg, weavePoint);\n        }\n      }\n    }\n  };\n}\n","﻿import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../../engine/ControlCommand\";\nimport { Divert as RuntimeDivert } from \"../../../../engine/Divert\";\nimport { Expression } from \"../Expression/Expression\";\nimport { ParsedObject } from \"../Object\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\nimport { NativeFunctionCall } from \"../../../../engine/NativeFunctionCall\";\nimport { StringValue } from \"../../../../engine/Value\";\nimport { Story } from \"../Story\";\nimport { Text } from \"../Text\";\nimport { Weave } from \"../Weave\";\nimport { asOrNull } from \"../../../../engine/TypeAssertion\";\n\nexport class ConditionalSingleBranch extends ParsedObject {\n  public _contentContainer: RuntimeContainer | null = null;\n  public _conditionalDivert: RuntimeDivert | null = null;\n  public _ownExpression: Expression | null = null;\n  public _innerWeave: Weave | null = null;\n  // bool condition, e.g.:\n  // { 5 == 4:\n  //   - the true branch\n  //   - the false branch\n  // }\n  public isTrueBranch: boolean = false;\n\n  // When each branch has its own expression like a switch statement,\n  // this is non-null. e.g.\n  // { x:\n  //    - 4: the value of x is four (ownExpression is the value 4)\n  //    - 3: the value of x is three\n  // }\n  get ownExpression() {\n    return this._ownExpression;\n  }\n\n  set ownExpression(value) {\n    this._ownExpression = value;\n    if (this._ownExpression) {\n      this.AddContent(this._ownExpression);\n    }\n  }\n\n  // In the above example, match equality of x with 4 for the first branch.\n  // This is as opposed to simply evaluating boolean equality for each branch,\n  // example when shouldMatchEquality is FALSE:\n  // {\n  //    3 > 2:  This will happen\n  //    2 > 3:  This won't happen\n  // }\n  public matchingEquality: boolean = false;\n\n  public isElse: boolean = false;\n  public isInline: boolean = false;\n\n  public returnDivert: RuntimeDivert | null = null;\n\n  constructor(content?: ParsedObject[] | null | undefined) {\n    super();\n\n    // Branches are allowed to be empty\n    if (content) {\n      this._innerWeave = new Weave(content);\n      this.AddContent(this._innerWeave);\n    }\n  }\n\n  get typeName(): string {\n    return \"ConditionalSingleBranch\";\n  }\n\n  // Runtime content can be summarised as follows:\n  //  - Evaluate an expression if necessary to branch on\n  //  - Branch to a named container if true\n  //       - Divert back to main flow\n  //         (owner Conditional is in control of this target point)\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    // Check for common mistake, of putting \"else:\" instead of \"- else:\"\n    if (this._innerWeave) {\n      for (const c of this._innerWeave.content) {\n        const text = asOrNull(c, Text);\n        if (text) {\n          // Don't need to trim at the start since the parser handles that already\n          if (text.text.startsWith(\"else:\")) {\n            this.Warning(\n              \"Saw the text 'else:' which is being treated as content. Did you mean '- else:'?\",\n              text\n            );\n          }\n        }\n      }\n    }\n\n    const container = new RuntimeContainer();\n\n    // Are we testing against a condition that's used for more than just this\n    // branch? If so, the first thing we need to do is replicate the value that's\n    // on the evaluation stack so that we don't fully consume it, in case other\n    // branches need to use it.\n    const duplicatesStackValue: boolean = this.matchingEquality && !this.isElse;\n\n    if (duplicatesStackValue) {\n      container.AddContent(RuntimeControlCommand.Duplicate());\n    }\n\n    this._conditionalDivert = new RuntimeDivert();\n\n    // else clause is unconditional catch-all, otherwise the divert is conditional\n    this._conditionalDivert.isConditional = !this.isElse;\n\n    // Need extra evaluation?\n    if (!this.isTrueBranch && !this.isElse) {\n      const needsEval: boolean = this.ownExpression !== null;\n      if (needsEval) {\n        container.AddContent(RuntimeControlCommand.EvalStart());\n      }\n\n      if (this.ownExpression) {\n        this.ownExpression.GenerateIntoContainer(container);\n      }\n\n      // Uses existing duplicated value\n      if (this.matchingEquality) {\n        container.AddContent(NativeFunctionCall.CallWithName(\"==\"));\n      }\n\n      if (needsEval) {\n        container.AddContent(RuntimeControlCommand.EvalEnd());\n      }\n    }\n\n    // Will pop from stack if conditional\n    container.AddContent(this._conditionalDivert);\n\n    this._contentContainer = this.GenerateRuntimeForContent();\n    this._contentContainer.name = \"b\";\n\n    // Multi-line conditionals get a newline at the start of each branch\n    // (as opposed to the start of the multi-line conditional since the condition\n    //  may evaluate to false.)\n    if (!this.isInline) {\n      this._contentContainer.InsertContent(new StringValue(\"\\n\"), 0);\n    }\n\n    if (duplicatesStackValue || (this.isElse && this.matchingEquality)) {\n      this._contentContainer.InsertContent(\n        RuntimeControlCommand.PopEvaluatedValue(),\n        0\n      );\n    }\n\n    container.AddToNamedContentOnly(this._contentContainer);\n\n    this.returnDivert = new RuntimeDivert();\n    this._contentContainer.AddContent(this.returnDivert);\n\n    return container;\n  };\n\n  public readonly GenerateRuntimeForContent = (): RuntimeContainer => {\n    // Empty branch - create empty container\n    if (this._innerWeave === null) {\n      return new RuntimeContainer();\n    }\n\n    return this._innerWeave.rootContainer;\n  };\n\n  public ResolveReferences(context: Story): void {\n    if (!this._conditionalDivert || !this._contentContainer) {\n      throw new Error();\n    }\n\n    this._conditionalDivert.targetPath = this._contentContainer.path;\n    super.ResolveReferences(context);\n  }\n}\n","export class DebugMetadata {\n  public startLineNumber: number = 0;\n  public endLineNumber: number = 0;\n  public startCharacterNumber: number = 0;\n  public endCharacterNumber: number = 0;\n  public fileName: string | null = null;\n  public sourceName: string | null = null;\n\n  public Merge(dm: DebugMetadata) {\n    let newDebugMetadata = new DebugMetadata();\n\n    newDebugMetadata.fileName = this.fileName;\n    newDebugMetadata.sourceName = this.sourceName;\n\n    if (this.startLineNumber < dm.startLineNumber) {\n      newDebugMetadata.startLineNumber = this.startLineNumber;\n      newDebugMetadata.startCharacterNumber = this.startCharacterNumber;\n    } else if (this.startLineNumber > dm.startLineNumber) {\n      newDebugMetadata.startLineNumber = dm.startLineNumber;\n      newDebugMetadata.startCharacterNumber = dm.startCharacterNumber;\n    } else {\n      newDebugMetadata.startLineNumber = this.startLineNumber;\n      newDebugMetadata.startCharacterNumber = Math.min(\n        this.startCharacterNumber,\n        dm.startCharacterNumber\n      );\n    }\n\n    if (this.endLineNumber > dm.endLineNumber) {\n      newDebugMetadata.endLineNumber = this.endLineNumber;\n      newDebugMetadata.endCharacterNumber = this.endCharacterNumber;\n    } else if (this.endLineNumber < dm.endLineNumber) {\n      newDebugMetadata.endLineNumber = dm.endLineNumber;\n      newDebugMetadata.endCharacterNumber = dm.endCharacterNumber;\n    } else {\n      newDebugMetadata.endLineNumber = this.endLineNumber;\n      newDebugMetadata.endCharacterNumber = Math.max(\n        this.endCharacterNumber,\n        dm.endCharacterNumber\n      );\n    }\n\n    return newDebugMetadata;\n  }\n\n  public toString() {\n    if (this.fileName !== null) {\n      return `line ${this.startLineNumber} of ${this.fileName}\"`;\n    } else {\n      return \"line \" + this.startLineNumber;\n    }\n  }\n}\n","export enum StatementLevel {\n  InnerBlock,\n  Stitch,\n  Knot,\n  Top,\n}\n","import { INamedContent } from \"../../../../engine/INamedContent\";\nimport { ParsedObject } from \"../Object\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\nimport { Identifier } from \"../Identifier\";\n\nexport class ExternalDeclaration extends ParsedObject implements INamedContent {\n  public get name(): string | null {\n    return this.identifier?.name || null;\n  }\n\n  constructor(\n    public readonly identifier: Identifier,\n    public readonly argumentNames: string[]\n  ) {\n    super();\n  }\n\n  get typeName(): string {\n    return \"EXTERNAL\";\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject | null => {\n    this.story.AddExternal(this);\n\n    // No runtime code exists for an external, only metadata\n    return null;\n  };\n\n  public toString(): string {\n    return `EXTERNAL ${this.identifier?.name}`;\n  }\n}\n","import { Argument } from \"./ParsedHierarchy/Argument\";\nimport { Identifier } from \"./ParsedHierarchy/Identifier\";\n\nexport class FlowDecl {\n  constructor(\n    public readonly name: Identifier,\n    public readonly args: Argument[],\n    public readonly isFunction: boolean\n  ) {}\n}\n","import { Glue as RuntimeGlue } from \"../../../engine/Glue\";\nimport { Wrap } from \"./Wrap\";\n\nexport class Glue extends Wrap<RuntimeGlue> {\n  constructor(glue: RuntimeGlue) {\n    super(glue);\n  }\n\n  get typeName(): string {\n    return \"Glue\";\n  }\n}\n","import { ParsedObject } from \"./Object\";\nimport { InkObject as RuntimeObject } from \"../../../engine/Object\";\n\nexport class Wrap<T extends RuntimeObject> extends ParsedObject {\n  constructor(private _objToWrap: T) {\n    super();\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject => this._objToWrap;\n}\n","import { InkObject } from \"./Object\";\n\nexport class Glue extends InkObject {\n  public toString() {\n    return \"Glue\";\n  }\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { ContentList } from \"../ContentList\";\nimport { Expression } from \"./Expression\";\nimport { FlowBase } from \"../Flow/FlowBase\";\nimport { NativeFunctionCall } from \"../../../../engine/NativeFunctionCall\";\nimport { IntValue } from \"../../../../engine/Value\";\nimport { Story } from \"../Story\";\nimport { VariableAssignment as RuntimeVariableAssignment } from \"../../../../engine/VariableAssignment\";\nimport { VariableReference as RuntimeVariableReference } from \"../../../../engine/VariableReference\";\nimport { Weave } from \"../Weave\";\nimport { Identifier } from \"../Identifier\";\n\nexport class IncDecExpression extends Expression {\n  private _runtimeAssignment: RuntimeVariableAssignment | null = null;\n\n  public isInc: boolean;\n  public expression: Expression | null = null;\n\n  constructor(\n    public readonly varIdentifier: Identifier | null,\n    isIncOrExpression: boolean | Expression,\n    isInc?: boolean\n  ) {\n    super();\n\n    if (isIncOrExpression instanceof Expression) {\n      this.expression = isIncOrExpression;\n      this.AddContent(this.expression);\n      this.isInc = Boolean(isInc);\n    } else {\n      this.isInc = isIncOrExpression as boolean;\n    }\n  }\n\n  get typeName(): string {\n    return \"IncDecExpression\";\n  }\n\n  public readonly GenerateIntoContainer = (\n    container: RuntimeContainer\n  ): void => {\n    // x = x + y\n    // ^^^ ^ ^ ^\n    //  4  1 3 2\n    // Reverse polish notation: (x 1 +) (assign to x)\n\n    // 1.\n    container.AddContent(\n      new RuntimeVariableReference(this.varIdentifier?.name || null)\n    );\n\n    // 2.\n    // - Expression used in the form ~ x += y\n    // - Simple version: ~ x++\n    if (this.expression) {\n      this.expression.GenerateIntoContainer(container);\n    } else {\n      container.AddContent(new IntValue(1));\n    }\n\n    // 3.\n    container.AddContent(\n      NativeFunctionCall.CallWithName(this.isInc ? \"+\" : \"-\")\n    );\n\n    // 4.\n    this._runtimeAssignment = new RuntimeVariableAssignment(\n      this.varIdentifier?.name || null,\n      false\n    );\n    container.AddContent(this._runtimeAssignment);\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    const varResolveResult = context.ResolveVariableWithName(\n      this.varIdentifier?.name || \"\",\n      this\n    );\n\n    if (!varResolveResult.found) {\n      this.Error(\n        `variable for ${this.incrementDecrementWord} could not be found: '${this.varIdentifier}' after searching: {this.descriptionOfScope}`\n      );\n    }\n\n    if (!this._runtimeAssignment) {\n      throw new Error();\n    }\n\n    this._runtimeAssignment.isGlobal = varResolveResult.isGlobal;\n\n    if (\n      !(this.parent instanceof Weave) &&\n      !(this.parent instanceof FlowBase) &&\n      !(this.parent instanceof ContentList)\n    ) {\n      this.Error(`Can't use ${this.incrementDecrementWord} as sub-expression`);\n    }\n  }\n\n  get incrementDecrementWord(): \"increment\" | \"decrement\" {\n    if (this.isInc) {\n      return \"increment\";\n    }\n\n    return \"decrement\";\n  }\n\n  public readonly toString = (): string => {\n    if (this.expression) {\n      return `${this.varIdentifier?.name}${this.isInc ? \" += \" : \" -= \"}${\n        this.expression\n      }`;\n    }\n\n    return `${this.varIdentifier?.name}` + (this.isInc ? \"++\" : \"--\");\n  };\n}\n","import { ParsedObject } from \"./Object\";\nimport { InkObject as RuntimeObject } from \"../../../engine/Object\";\nimport { Story } from \"./Story\";\n\nexport class IncludedFile extends ParsedObject {\n  constructor(public readonly includedStory: Story | null) {\n    super();\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject | null => {\n    // Left to the main story to process\n    return null;\n  };\n\n  get typeName(): string {\n    return \"IncludedFile\";\n  }\n}\n","export class InfixOperator {\n  constructor(\n    public readonly type: string,\n    public readonly precedence: number,\n    public readonly requireWhitespace: boolean\n  ) {}\n\n  public readonly toString = (): string => this.type;\n}\n","import { Argument } from \"./Argument\";\nimport { FlowBase } from \"./Flow/FlowBase\";\nimport { FlowLevel } from \"./Flow/FlowLevel\";\nimport { Identifier } from \"./Identifier\";\nimport { ParsedObject } from \"./Object\";\nimport { Story } from \"./Story\";\n\nexport class Knot extends FlowBase {\n  get flowLevel(): FlowLevel {\n    return FlowLevel.Knot;\n  }\n\n  constructor(\n    name: Identifier,\n    topLevelObjects: ParsedObject[],\n    args: Argument[],\n    isFunction: boolean\n  ) {\n    super(name, topLevelObjects, args, isFunction);\n  }\n\n  get typeName(): string {\n    return this.isFunction ? \"Function\" : \"Knot\";\n  }\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    let parentStory = this.story;\n\n    // Enforce rule that stitches must not have the same\n    // name as any knots that exist in the story\n    for (const stitchName in this.subFlowsByName) {\n      const knotWithStitchName = parentStory.ContentWithNameAtLevel(\n        stitchName,\n        FlowLevel.Knot,\n        false\n      );\n\n      if (knotWithStitchName) {\n        const stitch = this.subFlowsByName.get(stitchName);\n        const errorMsg = `Stitch '${\n          stitch ? stitch.name : \"NO STITCH FOUND\"\n        }' has the same name as a knot (on ${\n          knotWithStitchName.debugMetadata\n        })`;\n        this.Error(errorMsg, stitch);\n      }\n    }\n  }\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { Expression } from \"../Expression/Expression\";\nimport { InkList as RuntimeInkList } from \"../../../../engine/InkList\";\nimport { InkListItem as RuntimeInkListItem } from \"../../../../engine/InkList\";\nimport { ListElementDefinition } from \"./ListElementDefinition\";\nimport { ListValue } from \"../../../../engine/Value\";\nimport { Identifier } from \"../Identifier\";\n\nexport class List extends Expression {\n  constructor(public readonly itemIdentifierList: Identifier[]) {\n    super();\n  }\n\n  get typeName(): string {\n    return \"List\";\n  }\n\n  public readonly GenerateIntoContainer = (\n    container: RuntimeContainer\n  ): void => {\n    const runtimeRawList = new RuntimeInkList();\n\n    if (this.itemIdentifierList != null) {\n      for (const itemIdentifier of this.itemIdentifierList) {\n        const nameParts = itemIdentifier?.name?.split(\".\") || [];\n\n        let listName: string | null = null;\n        let listItemName: string = \"\";\n        if (nameParts.length > 1) {\n          listName = nameParts[0];\n          listItemName = nameParts[1];\n        } else {\n          listItemName = nameParts[0];\n        }\n\n        const listItem = this.story.ResolveListItem(\n          listName,\n          listItemName,\n          this\n        ) as ListElementDefinition;\n\n        if (listItem === null) {\n          if (listName === null) {\n            this.Error(\n              `Could not find list definition that contains item '${itemIdentifier}'`\n            );\n          } else {\n            this.Error(`Could not find list item ${itemIdentifier}`);\n          }\n        } else {\n          if (listItem.parent == null) {\n            this.Error(\n              `Could not find list definition for item ${itemIdentifier}`\n            );\n            return;\n          }\n          if (!listName) {\n            listName = listItem.parent.identifier?.name || null;\n          }\n\n          const item = new RuntimeInkListItem(listName, listItem.name || null);\n\n          if (runtimeRawList.has(item.serialized())) {\n            this.Warning(`Duplicate of item '${itemIdentifier}' in list.`);\n          } else {\n            runtimeRawList.Add(item, listItem.seriesValue);\n          }\n        }\n      }\n    }\n\n    container.AddContent(new ListValue(runtimeRawList));\n  };\n}\n","import { ListDefinition } from \"./ListDefinition\";\nimport { ParsedObject } from \"../Object\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\nimport { Story } from \"../Story\";\nimport { SymbolType } from \"../SymbolType\";\nimport { Identifier } from \"../Identifier\";\n\nexport class ListElementDefinition extends ParsedObject {\n  public seriesValue: number = 0;\n\n  public parent: ListDefinition | null = null;\n\n  get fullName(): string {\n    const parentList = this.parent;\n    if (parentList === null) {\n      throw new Error(\"Can't get full name without a parent list.\");\n    }\n\n    return `${parentList.identifier?.name}.${this.name}`;\n  }\n\n  get typeName(): string {\n    return \"ListElement\";\n  }\n\n  get name(): string | null {\n    return this.indentifier?.name || null;\n  }\n\n  constructor(\n    public readonly indentifier: Identifier,\n    public readonly inInitialList: boolean,\n    public readonly explicitValue: number | null = null\n  ) {\n    super();\n    this.parent = super.parent as ListDefinition;\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    throw new Error(\"Not implemented.\");\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n    context.CheckForNamingCollisions(\n      this,\n      this.indentifier,\n      SymbolType.ListItem\n    );\n  }\n\n  public readonly toString = (): string => this.fullName;\n}\n","import { Argument } from \"./Argument\";\nimport { FlowBase } from \"./Flow/FlowBase\";\nimport { FlowLevel } from \"./Flow/FlowLevel\";\nimport { Identifier } from \"./Identifier\";\nimport { ParsedObject } from \"./Object\";\n\nexport class Stitch extends FlowBase {\n  get flowLevel(): FlowLevel {\n    return FlowLevel.Stitch;\n  }\n\n  constructor(\n    name: Identifier,\n    topLevelObjects: ParsedObject[],\n    args: Argument[],\n    isFunction: boolean\n  ) {\n    super(name, topLevelObjects, args, isFunction);\n  }\n\n  get typeName(): string {\n    return \"Stitch\";\n  }\n\n  public toString = (): string => {\n    return `${\n      this.parent !== null ? this.parent + \" > \" : \"\"\n    }${super.toString()}`;\n  };\n}\n","import { InkObject } from \"./Object\";\n\n// New version of tags is dynamic - it constructs the tags\n// at runtime based on BeginTag and EndTag control commands.\n// Plain text that's in the output stream is turned into tags\n// when you do story.currentTags.\n// The only place this is used is when flattening tags down\n// to string in advance, during dynamic string generation if\n// there's a tag embedded in it. See how ControlCommand.EndString\n// is implemented in Story.cs for more details + comment\nexport class Tag extends InkObject {\n  public readonly text: string;\n\n  constructor(tagText: string) {\n    super();\n    this.text = tagText.toString() || \"\";\n  }\n\n  public toString(): string {\n    return \"# \" + this.text;\n  }\n}\n","import { Path } from \"./Path\";\nimport { CallStack } from \"./CallStack\";\nimport { throwNullException } from \"./NullException\";\nimport { InkObject } from \"./Object\";\n\nexport class Choice extends InkObject {\n  public text: string = \"\";\n  public index: number = 0;\n  public threadAtGeneration: CallStack.Thread | null = null;\n  public sourcePath: string = \"\";\n  public targetPath: Path | null = null;\n  public isInvisibleDefault: boolean = false;\n  public tags: string[] | null = null;\n  public originalThreadIndex: number = 0;\n\n  get pathStringOnChoice(): string {\n    if (this.targetPath === null)\n      return throwNullException(\"Choice.targetPath\");\n    return this.targetPath.toString();\n  }\n  set pathStringOnChoice(value: string) {\n    this.targetPath = new Path(value);\n  }\n}\n","import { InkListItem } from \"./InkList\";\nimport { ListValue } from \"./Value\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { TryGetResult } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\n\nexport class ListDefinitionsOrigin {\n  protected _lists: Map<string, ListDefinition>;\n  protected _allUnambiguousListValueCache: Map<string, ListValue>;\n\n  constructor(lists: ListDefinition[]) {\n    this._lists = new Map();\n    this._allUnambiguousListValueCache = new Map();\n\n    for (let list of lists) {\n      this._lists.set(list.name, list);\n\n      for (let [key, val] of list.items) {\n        let item = InkListItem.fromSerializedKey(key);\n        let listValue = new ListValue(item, val);\n\n        if (!item.itemName) {\n          throw new Error(\"item.itemName is null or undefined.\");\n        }\n\n        this._allUnambiguousListValueCache.set(item.itemName, listValue);\n        this._allUnambiguousListValueCache.set(item.fullName, listValue);\n      }\n    }\n  }\n  get lists(): ListDefinition[] {\n    let listOfLists: ListDefinition[] = [];\n\n    for (let [, value] of this._lists) {\n      listOfLists.push(value);\n    }\n\n    return listOfLists;\n  }\n  public TryListGetDefinition(\n    name: string | null,\n    /* out */ def: ListDefinition | null\n  ): TryGetResult<ListDefinition | null> {\n    if (name === null) {\n      return { result: def, exists: false };\n    }\n    // initially, this function returns a boolean and the second parameter is an out.\n    let definition = this._lists.get(name);\n    if (!definition) return { result: def, exists: false };\n\n    return { result: definition, exists: true };\n  }\n  public FindSingleItemListWithName(name: string | null) {\n    if (name === null) {\n      return throwNullException(\"name\");\n    }\n    let val = this._allUnambiguousListValueCache.get(name);\n\n    if (typeof val !== \"undefined\") {\n      return val;\n    }\n\n    return null;\n  }\n}\n","import { Container } from \"./Container\";\nimport {\n  Value,\n  IntValue,\n  FloatValue,\n  StringValue,\n  DivertTargetValue,\n  VariablePointerValue,\n  ListValue,\n  BoolValue,\n} from \"./Value\";\nimport { Glue } from \"./Glue\";\nimport { ControlCommand } from \"./ControlCommand\";\nimport { PushPopType } from \"./PushPop\";\nimport { Divert } from \"./Divert\";\nimport { ChoicePoint } from \"./ChoicePoint\";\nimport { VariableReference } from \"./VariableReference\";\nimport { VariableAssignment } from \"./VariableAssignment\";\nimport { NativeFunctionCall } from \"./NativeFunctionCall\";\nimport { Void } from \"./Void\";\nimport { Tag } from \"./Tag\";\nimport { Path } from \"./Path\";\nimport { Choice } from \"./Choice\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { ListDefinitionsOrigin } from \"./ListDefinitionsOrigin\";\nimport { InkListItem, InkList } from \"./InkList\";\nimport { InkObject } from \"./Object\";\nimport { asOrNull } from \"./TypeAssertion\";\nimport { throwNullException } from \"./NullException\";\nimport { SimpleJson } from \"./SimpleJson\";\n\nexport class JsonSerialisation {\n  public static JArrayToRuntimeObjList(\n    jArray: any[],\n    skipLast: boolean = false\n  ) {\n    let count = jArray.length;\n    if (skipLast) count--;\n\n    let list: InkObject[] = [];\n\n    for (let i = 0; i < count; i++) {\n      let jTok = jArray[i];\n      let runtimeObj = this.JTokenToRuntimeObject(jTok);\n      if (runtimeObj === null) {\n        return throwNullException(\"runtimeObj\");\n      }\n      list.push(runtimeObj);\n    }\n\n    return list;\n  }\n\n  public static WriteDictionaryRuntimeObjs(\n    writer: SimpleJson.Writer,\n    dictionary: Map<string, InkObject>\n  ) {\n    writer.WriteObjectStart();\n    for (let [key, value] of dictionary) {\n      writer.WritePropertyStart(key);\n      this.WriteRuntimeObject(writer, value);\n      writer.WritePropertyEnd();\n    }\n    writer.WriteObjectEnd();\n  }\n\n  public static WriteListRuntimeObjs(\n    writer: SimpleJson.Writer,\n    list: InkObject[]\n  ) {\n    writer.WriteArrayStart();\n    for (let value of list) {\n      this.WriteRuntimeObject(writer, value);\n    }\n    writer.WriteArrayEnd();\n  }\n\n  public static WriteIntDictionary(\n    writer: SimpleJson.Writer,\n    dict: Map<string, number>\n  ) {\n    writer.WriteObjectStart();\n    for (let [key, value] of dict) {\n      writer.WriteIntProperty(key, value);\n    }\n    writer.WriteObjectEnd();\n  }\n\n  public static WriteRuntimeObject(\n    writer: SimpleJson.Writer,\n    obj: InkObject\n  ): void {\n    let container = asOrNull(obj, Container);\n    if (container) {\n      this.WriteRuntimeContainer(writer, container);\n      return;\n    }\n\n    let divert = asOrNull(obj, Divert);\n    if (divert) {\n      let divTypeKey = \"->\";\n      if (divert.isExternal) {\n        divTypeKey = \"x()\";\n      } else if (divert.pushesToStack) {\n        if (divert.stackPushType == PushPopType.Function) {\n          divTypeKey = \"f()\";\n        } else if (divert.stackPushType == PushPopType.Tunnel) {\n          divTypeKey = \"->t->\";\n        }\n      }\n\n      let targetStr;\n      if (divert.hasVariableTarget) {\n        targetStr = divert.variableDivertName;\n      } else {\n        targetStr = divert.targetPathString;\n      }\n\n      writer.WriteObjectStart();\n      writer.WriteProperty(divTypeKey, targetStr);\n\n      if (divert.hasVariableTarget) {\n        writer.WriteProperty(\"var\", true);\n      }\n\n      if (divert.isConditional) {\n        writer.WriteProperty(\"c\", true);\n      }\n\n      if (divert.externalArgs > 0) {\n        writer.WriteIntProperty(\"exArgs\", divert.externalArgs);\n      }\n\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let choicePoint = asOrNull(obj, ChoicePoint);\n    if (choicePoint) {\n      writer.WriteObjectStart();\n      writer.WriteProperty(\"*\", choicePoint.pathStringOnChoice);\n      writer.WriteIntProperty(\"flg\", choicePoint.flags);\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let boolVal = asOrNull(obj, BoolValue);\n    if (boolVal) {\n      writer.WriteBool(boolVal.value);\n      return;\n    }\n\n    let intVal = asOrNull(obj, IntValue);\n    if (intVal) {\n      writer.WriteInt(intVal.value);\n      return;\n    }\n\n    let floatVal = asOrNull(obj, FloatValue);\n    if (floatVal) {\n      writer.WriteFloat(floatVal.value);\n      return;\n    }\n\n    let strVal = asOrNull(obj, StringValue);\n    if (strVal) {\n      if (strVal.isNewline) {\n        writer.Write(\"\\n\", false);\n      } else {\n        writer.WriteStringStart();\n        writer.WriteStringInner(\"^\");\n        writer.WriteStringInner(strVal.value);\n        writer.WriteStringEnd();\n      }\n      return;\n    }\n\n    let listVal = asOrNull(obj, ListValue);\n    if (listVal) {\n      this.WriteInkList(writer, listVal);\n      return;\n    }\n\n    let divTargetVal = asOrNull(obj, DivertTargetValue);\n    if (divTargetVal) {\n      writer.WriteObjectStart();\n      if (divTargetVal.value === null) {\n        return throwNullException(\"divTargetVal.value\");\n      }\n      writer.WriteProperty(\"^->\", divTargetVal.value.componentsString);\n      writer.WriteObjectEnd();\n\n      return;\n    }\n\n    let varPtrVal = asOrNull(obj, VariablePointerValue);\n    if (varPtrVal) {\n      writer.WriteObjectStart();\n      writer.WriteProperty(\"^var\", varPtrVal.value);\n      writer.WriteIntProperty(\"ci\", varPtrVal.contextIndex);\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let glue = asOrNull(obj, Glue);\n    if (glue) {\n      writer.Write(\"<>\");\n      return;\n    }\n\n    let controlCmd = asOrNull(obj, ControlCommand);\n    if (controlCmd) {\n      writer.Write(\n        JsonSerialisation._controlCommandNames[controlCmd.commandType]\n      );\n      return;\n    }\n\n    let nativeFunc = asOrNull(obj, NativeFunctionCall);\n    if (nativeFunc) {\n      let name = nativeFunc.name;\n\n      if (name == \"^\") name = \"L^\";\n\n      writer.Write(name);\n      return;\n    }\n\n    let varRef = asOrNull(obj, VariableReference);\n    if (varRef) {\n      writer.WriteObjectStart();\n      let readCountPath = varRef.pathStringForCount;\n      if (readCountPath != null) {\n        writer.WriteProperty(\"CNT?\", readCountPath);\n      } else {\n        writer.WriteProperty(\"VAR?\", varRef.name);\n      }\n\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let varAss = asOrNull(obj, VariableAssignment);\n    if (varAss) {\n      writer.WriteObjectStart();\n\n      let key = varAss.isGlobal ? \"VAR=\" : \"temp=\";\n      writer.WriteProperty(key, varAss.variableName);\n\n      // Reassignment?\n      if (!varAss.isNewDeclaration) writer.WriteProperty(\"re\", true);\n\n      writer.WriteObjectEnd();\n\n      return;\n    }\n\n    let voidObj = asOrNull(obj, Void);\n    if (voidObj) {\n      writer.Write(\"void\");\n      return;\n    }\n\n    let tag = asOrNull(obj, Tag);\n    if (tag) {\n      writer.WriteObjectStart();\n      writer.WriteProperty(\"#\", tag.text);\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let choice = asOrNull(obj, Choice);\n    if (choice) {\n      this.WriteChoice(writer, choice);\n      return;\n    }\n\n    throw new Error(\"Failed to convert runtime object to Json token: \" + obj);\n  }\n\n  public static JObjectToDictionaryRuntimeObjs(jObject: Record<string, any>) {\n    let dict: Map<string, InkObject> = new Map();\n\n    for (let key in jObject) {\n      if (jObject.hasOwnProperty(key)) {\n        let inkObject = this.JTokenToRuntimeObject(jObject[key]);\n        if (inkObject === null) {\n          return throwNullException(\"inkObject\");\n        }\n        dict.set(key, inkObject);\n      }\n    }\n\n    return dict;\n  }\n\n  public static JObjectToIntDictionary(jObject: Record<string, any>) {\n    let dict: Map<string, number> = new Map();\n    for (let key in jObject) {\n      if (jObject.hasOwnProperty(key)) {\n        dict.set(key, parseInt(jObject[key]));\n      }\n    }\n    return dict;\n  }\n\n  public static JTokenToRuntimeObject(token: any): InkObject | null {\n    if (\n      (typeof token === \"number\" && !isNaN(token)) ||\n      typeof token === \"boolean\"\n    ) {\n      return Value.Create(token);\n    }\n\n    if (typeof token === \"string\") {\n      let str = token.toString();\n\n      // String value\n      let firstChar = str[0];\n      if (firstChar == \"^\") return new StringValue(str.substring(1));\n      else if (firstChar == \"\\n\" && str.length == 1)\n        return new StringValue(\"\\n\");\n\n      // Glue\n      if (str == \"<>\") return new Glue();\n\n      // Control commands (would looking up in a hash set be faster?)\n      for (let i = 0; i < JsonSerialisation._controlCommandNames.length; ++i) {\n        let cmdName = JsonSerialisation._controlCommandNames[i];\n        if (str == cmdName) {\n          return new ControlCommand(i);\n        }\n      }\n\n      // Native functions\n      if (str == \"L^\") str = \"^\";\n      if (NativeFunctionCall.CallExistsWithName(str))\n        return NativeFunctionCall.CallWithName(str);\n\n      // Pop\n      if (str == \"->->\") return ControlCommand.PopTunnel();\n      else if (str == \"~ret\") return ControlCommand.PopFunction();\n\n      // Void\n      if (str == \"void\") return new Void();\n    }\n\n    if (typeof token === \"object\" && !Array.isArray(token)) {\n      let obj = token as Record<string, any>;\n      let propValue;\n\n      // Divert target value to path\n      if (obj[\"^->\"]) {\n        propValue = obj[\"^->\"];\n        return new DivertTargetValue(new Path(propValue.toString()));\n      }\n\n      // VariablePointerValue\n      if (obj[\"^var\"]) {\n        propValue = obj[\"^var\"];\n        let varPtr = new VariablePointerValue(propValue.toString());\n        if (\"ci\" in obj) {\n          propValue = obj[\"ci\"];\n          varPtr.contextIndex = parseInt(propValue);\n        }\n        return varPtr;\n      }\n\n      // Divert\n      let isDivert = false;\n      let pushesToStack = false;\n      let divPushType = PushPopType.Function;\n      let external = false;\n      if ((propValue = obj[\"->\"])) {\n        isDivert = true;\n      } else if ((propValue = obj[\"f()\"])) {\n        isDivert = true;\n        pushesToStack = true;\n        divPushType = PushPopType.Function;\n      } else if ((propValue = obj[\"->t->\"])) {\n        isDivert = true;\n        pushesToStack = true;\n        divPushType = PushPopType.Tunnel;\n      } else if ((propValue = obj[\"x()\"])) {\n        isDivert = true;\n        external = true;\n        pushesToStack = false;\n        divPushType = PushPopType.Function;\n      }\n\n      if (isDivert) {\n        let divert = new Divert();\n        divert.pushesToStack = pushesToStack;\n        divert.stackPushType = divPushType;\n        divert.isExternal = external;\n\n        let target = propValue.toString();\n\n        if ((propValue = obj[\"var\"])) divert.variableDivertName = target;\n        else divert.targetPathString = target;\n\n        divert.isConditional = !!obj[\"c\"];\n\n        if (external) {\n          if ((propValue = obj[\"exArgs\"]))\n            divert.externalArgs = parseInt(propValue);\n        }\n\n        return divert;\n      }\n\n      // Choice\n      if ((propValue = obj[\"*\"])) {\n        let choice = new ChoicePoint();\n        choice.pathStringOnChoice = propValue.toString();\n\n        if ((propValue = obj[\"flg\"])) choice.flags = parseInt(propValue);\n\n        return choice;\n      }\n\n      // Variable reference\n      if ((propValue = obj[\"VAR?\"])) {\n        return new VariableReference(propValue.toString());\n      } else if ((propValue = obj[\"CNT?\"])) {\n        let readCountVarRef = new VariableReference();\n        readCountVarRef.pathStringForCount = propValue.toString();\n        return readCountVarRef;\n      }\n\n      // Variable assignment\n      let isVarAss = false;\n      let isGlobalVar = false;\n      if ((propValue = obj[\"VAR=\"])) {\n        isVarAss = true;\n        isGlobalVar = true;\n      } else if ((propValue = obj[\"temp=\"])) {\n        isVarAss = true;\n        isGlobalVar = false;\n      }\n      if (isVarAss) {\n        let varName = propValue.toString();\n        let isNewDecl = !obj[\"re\"];\n        let varAss = new VariableAssignment(varName, isNewDecl);\n        varAss.isGlobal = isGlobalVar;\n        return varAss;\n      }\n      if (obj[\"#\"] !== undefined) {\n        propValue = obj[\"#\"];\n        return new Tag(propValue.toString());\n      }\n\n      // List value\n      if ((propValue = obj[\"list\"])) {\n        // var listContent = (Dictionary<string, object>)propValue;\n        let listContent = propValue as Record<string, any>;\n        let rawList = new InkList();\n        if ((propValue = obj[\"origins\"])) {\n          // var namesAsObjs = (List<object>)propValue;\n          let namesAsObjs = propValue as string[];\n          // rawList.SetInitialOriginNames(namesAsObjs.Cast<string>().ToList());\n          rawList.SetInitialOriginNames(namesAsObjs);\n        }\n\n        for (let key in listContent) {\n          if (listContent.hasOwnProperty(key)) {\n            let nameToVal = listContent[key];\n            let item = new InkListItem(key);\n            let val = parseInt(nameToVal);\n            rawList.Add(item, val);\n          }\n        }\n\n        return new ListValue(rawList);\n      }\n\n      if (obj[\"originalChoicePath\"] != null) return this.JObjectToChoice(obj);\n    }\n\n    // Array is always a Runtime.Container\n    if (Array.isArray(token)) {\n      return this.JArrayToContainer(token);\n    }\n\n    if (token === null || token === undefined) return null;\n\n    throw new Error(\n      \"Failed to convert token to runtime object: \" +\n        this.toJson(token, [\"parent\"])\n    );\n  }\n\n  public static toJson<T>(\n    me: T,\n    removes?: (keyof T)[],\n    space?: number\n  ): string {\n    return JSON.stringify(\n      me,\n      (k, v) => (removes?.some((r) => r === k) ? undefined : v),\n      space\n    );\n  }\n\n  public static WriteRuntimeContainer(\n    writer: SimpleJson.Writer,\n    container: Container | null,\n    withoutName: boolean = false\n  ) {\n    writer.WriteArrayStart();\n    if (container === null) {\n      return throwNullException(\"container\");\n    }\n    for (let c of container.content) this.WriteRuntimeObject(writer, c);\n\n    let namedOnlyContent = container.namedOnlyContent;\n    let countFlags = container.countFlags;\n    let hasNameProperty = container.name != null && !withoutName;\n\n    let hasTerminator =\n      namedOnlyContent != null || countFlags > 0 || hasNameProperty;\n    if (hasTerminator) {\n      writer.WriteObjectStart();\n    }\n\n    if (namedOnlyContent != null) {\n      for (let [key, value] of namedOnlyContent) {\n        let name = key;\n        let namedContainer = asOrNull(value, Container);\n        writer.WritePropertyStart(name);\n        this.WriteRuntimeContainer(writer, namedContainer, true);\n        writer.WritePropertyEnd();\n      }\n    }\n\n    if (countFlags > 0) writer.WriteIntProperty(\"#f\", countFlags);\n\n    if (hasNameProperty) writer.WriteProperty(\"#n\", container.name);\n\n    if (hasTerminator) writer.WriteObjectEnd();\n    else writer.WriteNull();\n\n    writer.WriteArrayEnd();\n  }\n\n  public static JArrayToContainer(jArray: any[]) {\n    let container = new Container();\n    container.content = this.JArrayToRuntimeObjList(jArray, true);\n\n    let terminatingObj = jArray[jArray.length - 1] as Record<string, any>;\n    if (terminatingObj != null) {\n      let namedOnlyContent = new Map();\n\n      for (let key in terminatingObj) {\n        if (key == \"#f\") {\n          container.countFlags = parseInt(terminatingObj[key]);\n        } else if (key == \"#n\") {\n          container.name = terminatingObj[key].toString();\n        } else {\n          let namedContentItem = this.JTokenToRuntimeObject(\n            terminatingObj[key]\n          );\n          // var namedSubContainer = namedContentItem as Container;\n          let namedSubContainer = asOrNull(namedContentItem, Container);\n          if (namedSubContainer) namedSubContainer.name = key;\n          namedOnlyContent.set(key, namedContentItem);\n        }\n      }\n\n      container.namedOnlyContent = namedOnlyContent;\n    }\n\n    return container;\n  }\n\n  public static JObjectToChoice(jObj: Record<string, any>) {\n    let choice = new Choice();\n    choice.text = jObj[\"text\"].toString();\n    choice.index = parseInt(jObj[\"index\"]);\n    choice.sourcePath = jObj[\"originalChoicePath\"].toString();\n    choice.originalThreadIndex = parseInt(jObj[\"originalThreadIndex\"]);\n    choice.pathStringOnChoice = jObj[\"targetPath\"].toString();\n    if (jObj[\"tags\"]) {\n      choice.tags = jObj[\"tags\"];\n    }\n    return choice;\n  }\n\n  public static WriteChoice(writer: SimpleJson.Writer, choice: Choice) {\n    writer.WriteObjectStart();\n    writer.WriteProperty(\"text\", choice.text);\n    writer.WriteIntProperty(\"index\", choice.index);\n    writer.WriteProperty(\"originalChoicePath\", choice.sourcePath);\n    writer.WriteIntProperty(\"originalThreadIndex\", choice.originalThreadIndex);\n    writer.WriteProperty(\"targetPath\", choice.pathStringOnChoice);\n    if (choice.tags) {\n      writer.WriteProperty(\"tags\", (w) => {\n        w.WriteArrayStart();\n        for (const tag of choice.tags!) {\n          w.WriteStringStart();\n          w.WriteStringInner(tag);\n          w.WriteStringEnd();\n        }\n        w.WriteArrayEnd();\n      });\n    }\n    writer.WriteObjectEnd();\n  }\n\n  public static WriteInkList(writer: SimpleJson.Writer, listVal: ListValue) {\n    let rawList = listVal.value;\n    if (rawList === null) {\n      return throwNullException(\"rawList\");\n    }\n\n    writer.WriteObjectStart();\n    writer.WritePropertyStart(\"list\");\n    writer.WriteObjectStart();\n\n    for (let [key, val] of rawList) {\n      let item = InkListItem.fromSerializedKey(key);\n      let itemVal = val;\n\n      if (item.itemName === null) {\n        return throwNullException(\"item.itemName\");\n      }\n\n      writer.WritePropertyNameStart();\n      writer.WritePropertyNameInner(item.originName ? item.originName : \"?\");\n      writer.WritePropertyNameInner(\".\");\n      writer.WritePropertyNameInner(item.itemName);\n      writer.WritePropertyNameEnd();\n\n      writer.Write(itemVal);\n\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteObjectEnd();\n\n    writer.WritePropertyEnd();\n\n    if (\n      rawList.Count == 0 &&\n      rawList.originNames != null &&\n      rawList.originNames.length > 0\n    ) {\n      writer.WritePropertyStart(\"origins\");\n      writer.WriteArrayStart();\n      for (let name of rawList.originNames) writer.Write(name);\n      writer.WriteArrayEnd();\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteObjectEnd();\n  }\n\n  public static ListDefinitionsToJToken(origin: ListDefinitionsOrigin) {\n    let result: Record<string, any> = {};\n\n    for (let def of origin.lists) {\n      let listDefJson: Record<string, any> = {};\n\n      for (let [key, val] of def.items) {\n        let item = InkListItem.fromSerializedKey(key);\n        if (item.itemName === null) {\n          return throwNullException(\"item.itemName\");\n        }\n        listDefJson[item.itemName] = val;\n      }\n\n      result[def.name] = listDefJson;\n    }\n\n    return result;\n  }\n\n  public static JTokenToListDefinitions(obj: Record<string, any>) {\n    // var defsObj = (Dictionary<string, object>)obj;\n    let defsObj = obj;\n\n    let allDefs: ListDefinition[] = [];\n\n    for (let key in defsObj) {\n      if (defsObj.hasOwnProperty(key)) {\n        let name = key.toString();\n        // var listDefJson = (Dictionary<string, object>)kv.Value;\n        let listDefJson = defsObj[key] as Record<string, any>;\n\n        // Cast (string, object) to (string, int) for items\n        let items: Map<string, number> = new Map();\n\n        for (let nameValueKey in listDefJson) {\n          if (defsObj.hasOwnProperty(key)) {\n            let nameValue = listDefJson[nameValueKey];\n            items.set(nameValueKey, parseInt(nameValue));\n          }\n        }\n\n        let def = new ListDefinition(name, items);\n        allDefs.push(def);\n      }\n    }\n\n    return new ListDefinitionsOrigin(allDefs);\n  }\n\n  private static _controlCommandNames = (() => {\n    let _controlCommandNames: string[] = [];\n\n    _controlCommandNames[ControlCommand.CommandType.EvalStart] = \"ev\";\n    _controlCommandNames[ControlCommand.CommandType.EvalOutput] = \"out\";\n    _controlCommandNames[ControlCommand.CommandType.EvalEnd] = \"/ev\";\n    _controlCommandNames[ControlCommand.CommandType.Duplicate] = \"du\";\n    _controlCommandNames[ControlCommand.CommandType.PopEvaluatedValue] = \"pop\";\n    _controlCommandNames[ControlCommand.CommandType.PopFunction] = \"~ret\";\n    _controlCommandNames[ControlCommand.CommandType.PopTunnel] = \"->->\";\n    _controlCommandNames[ControlCommand.CommandType.BeginString] = \"str\";\n    _controlCommandNames[ControlCommand.CommandType.EndString] = \"/str\";\n    _controlCommandNames[ControlCommand.CommandType.NoOp] = \"nop\";\n    _controlCommandNames[ControlCommand.CommandType.ChoiceCount] = \"choiceCnt\";\n    _controlCommandNames[ControlCommand.CommandType.Turns] = \"turn\";\n    _controlCommandNames[ControlCommand.CommandType.TurnsSince] = \"turns\";\n    _controlCommandNames[ControlCommand.CommandType.ReadCount] = \"readc\";\n    _controlCommandNames[ControlCommand.CommandType.Random] = \"rnd\";\n    _controlCommandNames[ControlCommand.CommandType.SeedRandom] = \"srnd\";\n    _controlCommandNames[ControlCommand.CommandType.VisitIndex] = \"visit\";\n    _controlCommandNames[ControlCommand.CommandType.SequenceShuffleIndex] =\n      \"seq\";\n    _controlCommandNames[ControlCommand.CommandType.StartThread] = \"thread\";\n    _controlCommandNames[ControlCommand.CommandType.Done] = \"done\";\n    _controlCommandNames[ControlCommand.CommandType.End] = \"end\";\n    _controlCommandNames[ControlCommand.CommandType.ListFromInt] = \"listInt\";\n    _controlCommandNames[ControlCommand.CommandType.ListRange] = \"range\";\n    _controlCommandNames[ControlCommand.CommandType.ListRandom] = \"lrnd\";\n    _controlCommandNames[ControlCommand.CommandType.BeginTag] = \"#\";\n    _controlCommandNames[ControlCommand.CommandType.EndTag] = \"/#\";\n\n    for (let i = 0; i < ControlCommand.CommandType.TOTAL_VALUES; ++i) {\n      if (_controlCommandNames[i] == null)\n        throw new Error(\"Control command not accounted for in serialisation\");\n    }\n\n    return _controlCommandNames;\n  })();\n}\n","import { PushPopType } from \"./PushPop\";\nimport { Path } from \"./Path\";\nimport { Story } from \"./Story\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { ListValue } from \"./Value\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { Pointer } from \"./Pointer\";\nimport { InkObject } from \"./Object\";\nimport { Debug } from \"./Debug\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\nimport { SimpleJson } from \"./SimpleJson\";\n\nexport class CallStack {\n  get elements() {\n    return this.callStack;\n  }\n\n  get depth() {\n    return this.elements.length;\n  }\n\n  get currentElement() {\n    let thread = this._threads[this._threads.length - 1];\n    let cs = thread.callstack;\n    return cs[cs.length - 1];\n  }\n\n  get currentElementIndex() {\n    return this.callStack.length - 1;\n  }\n\n  get currentThread(): CallStack.Thread {\n    return this._threads[this._threads.length - 1];\n  }\n  set currentThread(value: CallStack.Thread) {\n    Debug.Assert(\n      this._threads.length == 1,\n      \"Shouldn't be directly setting the current thread when we have a stack of them\"\n    );\n\n    this._threads.length = 0;\n    this._threads.push(value);\n  }\n\n  get canPop() {\n    return this.callStack.length > 1;\n  }\n\n  constructor(storyContext: Story);\n  constructor(toCopy: CallStack);\n  constructor() {\n    if (arguments[0] instanceof Story) {\n      let storyContext = arguments[0] as Story;\n\n      this._startOfRoot = Pointer.StartOf(storyContext.rootContentContainer);\n      this.Reset();\n    } else {\n      let toCopy = arguments[0] as CallStack;\n\n      this._threads = [];\n      for (let otherThread of toCopy._threads) {\n        this._threads.push(otherThread.Copy());\n      }\n      this._threadCounter = toCopy._threadCounter;\n      this._startOfRoot = toCopy._startOfRoot.copy();\n    }\n  }\n\n  public Reset() {\n    this._threads = [];\n    this._threads.push(new CallStack.Thread());\n\n    this._threads[0].callstack.push(\n      new CallStack.Element(PushPopType.Tunnel, this._startOfRoot)\n    );\n  }\n\n  public SetJsonToken(jObject: Record<string, any>, storyContext: Story) {\n    this._threads.length = 0;\n\n    // TODO: (List<object>) jObject [\"threads\"];\n    let jThreads: any[] = jObject[\"threads\"];\n\n    for (let jThreadTok of jThreads) {\n      // TODO: var jThreadObj = (Dictionary<string, object>)jThreadTok;\n      let jThreadObj = jThreadTok;\n      let thread = new CallStack.Thread(jThreadObj, storyContext);\n      this._threads.push(thread);\n    }\n\n    // TODO: (int)jObject [\"threadCounter\"];\n    this._threadCounter = parseInt(jObject[\"threadCounter\"]);\n    this._startOfRoot = Pointer.StartOf(storyContext.rootContentContainer);\n  }\n  public WriteJson(w: SimpleJson.Writer) {\n    w.WriteObject((writer) => {\n      writer.WritePropertyStart(\"threads\");\n      writer.WriteArrayStart();\n\n      for (let thread of this._threads) {\n        thread.WriteJson(writer);\n      }\n\n      writer.WriteArrayEnd();\n      writer.WritePropertyEnd();\n\n      writer.WritePropertyStart(\"threadCounter\");\n      writer.WriteInt(this._threadCounter);\n      writer.WritePropertyEnd();\n    });\n  }\n\n  public PushThread() {\n    let newThread = this.currentThread.Copy();\n    this._threadCounter++;\n    newThread.threadIndex = this._threadCounter;\n    this._threads.push(newThread);\n  }\n\n  public ForkThread() {\n    let forkedThread = this.currentThread.Copy();\n    this._threadCounter++;\n    forkedThread.threadIndex = this._threadCounter;\n    return forkedThread;\n  }\n\n  public PopThread() {\n    if (this.canPopThread) {\n      this._threads.splice(this._threads.indexOf(this.currentThread), 1); // should be equivalent to a pop()\n    } else {\n      throw new Error(\"Can't pop thread\");\n    }\n  }\n\n  get canPopThread() {\n    return this._threads.length > 1 && !this.elementIsEvaluateFromGame;\n  }\n\n  get elementIsEvaluateFromGame() {\n    return this.currentElement.type == PushPopType.FunctionEvaluationFromGame;\n  }\n\n  public Push(\n    type: PushPopType,\n    externalEvaluationStackHeight: number = 0,\n    outputStreamLengthWithPushed: number = 0\n  ) {\n    let element = new CallStack.Element(\n      type,\n      this.currentElement.currentPointer,\n      false\n    );\n\n    element.evaluationStackHeightWhenPushed = externalEvaluationStackHeight;\n    element.functionStartInOutputStream = outputStreamLengthWithPushed;\n\n    this.callStack.push(element);\n  }\n\n  public CanPop(type: PushPopType | null = null) {\n    if (!this.canPop) return false;\n\n    if (type == null) return true;\n\n    return this.currentElement.type == type;\n  }\n\n  public Pop(type: PushPopType | null = null) {\n    if (this.CanPop(type)) {\n      this.callStack.pop();\n      return;\n    } else {\n      throw new Error(\"Mismatched push/pop in Callstack\");\n    }\n  }\n\n  public GetTemporaryVariableWithName(\n    name: string | null,\n    contextIndex: number = -1\n  ) {\n    if (contextIndex == -1) contextIndex = this.currentElementIndex + 1;\n\n    let contextElement = this.callStack[contextIndex - 1];\n\n    let varValue = tryGetValueFromMap(\n      contextElement.temporaryVariables,\n      name,\n      null\n    );\n    if (varValue.exists) {\n      return varValue.result;\n    } else {\n      return null;\n    }\n  }\n\n  public SetTemporaryVariable(\n    name: string,\n    value: any,\n    declareNew: boolean,\n    contextIndex: number = -1\n  ) {\n    if (contextIndex == -1) contextIndex = this.currentElementIndex + 1;\n\n    let contextElement = this.callStack[contextIndex - 1];\n\n    if (!declareNew && !contextElement.temporaryVariables.get(name)) {\n      throw new Error(\"Could not find temporary variable to set: \" + name);\n    }\n\n    let oldValue = tryGetValueFromMap(\n      contextElement.temporaryVariables,\n      name,\n      null\n    );\n    if (oldValue.exists)\n      ListValue.RetainListOriginsForAssignment(oldValue.result, value);\n\n    contextElement.temporaryVariables.set(name, value);\n  }\n\n  public ContextForVariableNamed(name: string) {\n    if (this.currentElement.temporaryVariables.get(name)) {\n      return this.currentElementIndex + 1;\n    } else {\n      return 0;\n    }\n  }\n\n  public ThreadWithIndex(index: number) {\n    let filtered = this._threads.filter((t) => {\n      if (t.threadIndex == index) return t;\n    });\n\n    return filtered.length > 0 ? filtered[0] : null;\n  }\n\n  get callStack() {\n    return this.currentThread.callstack;\n  }\n\n  get callStackTrace() {\n    let sb = new StringBuilder();\n\n    for (let t = 0; t < this._threads.length; t++) {\n      let thread = this._threads[t];\n      let isCurrent = t == this._threads.length - 1;\n      sb.AppendFormat(\n        \"=== THREAD {0}/{1} {2}===\\n\",\n        t + 1,\n        this._threads.length,\n        isCurrent ? \"(current) \" : \"\"\n      );\n\n      for (let i = 0; i < thread.callstack.length; i++) {\n        if (thread.callstack[i].type == PushPopType.Function)\n          sb.Append(\"  [FUNCTION] \");\n        else sb.Append(\"  [TUNNEL] \");\n\n        let pointer = thread.callstack[i].currentPointer;\n        if (!pointer.isNull) {\n          sb.Append(\"<SOMEWHERE IN \");\n          if (pointer.container === null) {\n            return throwNullException(\"pointer.container\");\n          }\n          sb.Append(pointer.container.path.toString());\n          sb.AppendLine(\">\");\n        }\n      }\n    }\n\n    return sb.toString();\n  }\n\n  public _threads!: CallStack.Thread[]; // Banged because it's initialized in Reset().\n  public _threadCounter: number = 0;\n  public _startOfRoot: Pointer = Pointer.Null;\n}\n\nexport namespace CallStack {\n  export class Element {\n    public currentPointer: Pointer;\n    public inExpressionEvaluation: boolean;\n    public temporaryVariables: Map<string, InkObject>;\n    public type: PushPopType;\n\n    public evaluationStackHeightWhenPushed: number = 0;\n    public functionStartInOutputStream: number = 0;\n\n    constructor(\n      type: PushPopType,\n      pointer: Pointer,\n      inExpressionEvaluation: boolean = false\n    ) {\n      this.currentPointer = pointer.copy();\n      this.inExpressionEvaluation = inExpressionEvaluation;\n      this.temporaryVariables = new Map();\n      this.type = type;\n    }\n\n    public Copy() {\n      let copy = new Element(\n        this.type,\n        this.currentPointer,\n        this.inExpressionEvaluation\n      );\n      copy.temporaryVariables = new Map(this.temporaryVariables);\n      copy.evaluationStackHeightWhenPushed =\n        this.evaluationStackHeightWhenPushed;\n      copy.functionStartInOutputStream = this.functionStartInOutputStream;\n      return copy;\n    }\n  }\n\n  export class Thread {\n    public callstack: Element[];\n    public threadIndex: number = 0;\n    public previousPointer: Pointer = Pointer.Null;\n\n    constructor();\n    constructor(jThreadObj: any, storyContext: Story);\n    constructor() {\n      this.callstack = [];\n\n      if (arguments[0] && arguments[1]) {\n        let jThreadObj = arguments[0];\n        let storyContext = arguments[1];\n\n        // TODO: (int) jThreadObj['threadIndex'] can raise;\n        this.threadIndex = parseInt(jThreadObj[\"threadIndex\"]);\n\n        let jThreadCallstack = jThreadObj[\"callstack\"];\n\n        for (let jElTok of jThreadCallstack) {\n          let jElementObj = jElTok;\n\n          // TODO: (int) jElementObj['type'] can raise;\n          let pushPopType: PushPopType = parseInt(jElementObj[\"type\"]);\n\n          let pointer = Pointer.Null;\n\n          let currentContainerPathStr: string;\n          // TODO: jElementObj.TryGetValue (\"cPath\", out currentContainerPathStrToken);\n          let currentContainerPathStrToken = jElementObj[\"cPath\"];\n          if (typeof currentContainerPathStrToken !== \"undefined\") {\n            currentContainerPathStr = currentContainerPathStrToken.toString();\n\n            let threadPointerResult = storyContext.ContentAtPath(\n              new Path(currentContainerPathStr)\n            );\n            pointer.container = threadPointerResult.container;\n            pointer.index = parseInt(jElementObj[\"idx\"]);\n\n            if (threadPointerResult.obj == null)\n              throw new Error(\n                \"When loading state, internal story location couldn't be found: \" +\n                  currentContainerPathStr +\n                  \". Has the story changed since this save data was created?\"\n              );\n            else if (threadPointerResult.approximate) {\n              if (pointer.container === null) {\n                return throwNullException(\"pointer.container\");\n              }\n              storyContext.Warning(\n                \"When loading state, exact internal story location couldn't be found: '\" +\n                  currentContainerPathStr +\n                  \"', so it was approximated to '\" +\n                  pointer.container.path.toString() +\n                  \"' to recover. Has the story changed since this save data was created?\"\n              );\n            }\n          }\n\n          let inExpressionEvaluation = !!jElementObj[\"exp\"];\n\n          let el = new Element(pushPopType, pointer, inExpressionEvaluation);\n\n          let temps = jElementObj[\"temp\"];\n          if (typeof temps !== \"undefined\") {\n            el.temporaryVariables =\n              JsonSerialisation.JObjectToDictionaryRuntimeObjs(temps);\n          } else {\n            el.temporaryVariables.clear();\n          }\n\n          this.callstack.push(el);\n        }\n\n        let prevContentObjPath = jThreadObj[\"previousContentObject\"];\n        if (typeof prevContentObjPath !== \"undefined\") {\n          let prevPath = new Path(prevContentObjPath.toString());\n          this.previousPointer = storyContext.PointerAtPath(prevPath);\n        }\n      }\n    }\n\n    public Copy() {\n      let copy = new Thread();\n      copy.threadIndex = this.threadIndex;\n      for (let e of this.callstack) {\n        copy.callstack.push(e.Copy());\n      }\n      copy.previousPointer = this.previousPointer.copy();\n      return copy;\n    }\n\n    public WriteJson(writer: SimpleJson.Writer) {\n      writer.WriteObjectStart();\n\n      writer.WritePropertyStart(\"callstack\");\n      writer.WriteArrayStart();\n      for (let el of this.callstack) {\n        writer.WriteObjectStart();\n        if (!el.currentPointer.isNull) {\n          if (el.currentPointer.container === null) {\n            return throwNullException(\"el.currentPointer.container\");\n          }\n          writer.WriteProperty(\n            \"cPath\",\n            el.currentPointer.container.path.componentsString\n          );\n          writer.WriteIntProperty(\"idx\", el.currentPointer.index);\n        }\n\n        writer.WriteProperty(\"exp\", el.inExpressionEvaluation);\n        writer.WriteIntProperty(\"type\", el.type);\n\n        if (el.temporaryVariables.size > 0) {\n          writer.WritePropertyStart(\"temp\");\n          JsonSerialisation.WriteDictionaryRuntimeObjs(\n            writer,\n            el.temporaryVariables\n          );\n          writer.WritePropertyEnd();\n        }\n\n        writer.WriteObjectEnd();\n      }\n      writer.WriteArrayEnd();\n      writer.WritePropertyEnd();\n\n      writer.WriteIntProperty(\"threadIndex\", this.threadIndex);\n\n      if (!this.previousPointer.isNull) {\n        let resolvedPointer = this.previousPointer.Resolve();\n        if (resolvedPointer === null) {\n          return throwNullException(\"this.previousPointer.Resolve()\");\n        }\n        writer.WriteProperty(\n          \"previousContentObject\",\n          resolvedPointer.path.toString()\n        );\n      }\n\n      writer.WriteObjectEnd();\n    }\n  }\n}\n","import {\n  AbstractValue,\n  Value,\n  VariablePointerValue,\n  ListValue,\n  IntValue,\n  FloatValue,\n  BoolValue,\n} from \"./Value\";\nimport { VariableAssignment } from \"./VariableAssignment\";\nimport { InkObject } from \"./Object\";\nimport { ListDefinitionsOrigin } from \"./ListDefinitionsOrigin\";\nimport { StoryException } from \"./StoryException\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { asOrThrows, asOrNull, isEquatable } from \"./TypeAssertion\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\nimport { CallStack } from \"./CallStack\";\nimport { StatePatch } from \"./StatePatch\";\nimport { SimpleJson } from \"./SimpleJson\";\nimport { InkList } from \"./Story\";\nimport { Path } from \"./Path\";\n\n// Fake class wrapper around VariableState to have correct typing\n// when using the Proxy syntax in typescript\nfunction VariablesStateAccessor<T>(): new () => Pick<T, keyof T> {\n  return class {} as any;\n}\n\ntype VariableStateValue = boolean | string | number | InkList | Path | null;\n\nexport class VariablesState extends VariablesStateAccessor<\n  Record<string, any>\n>() {\n  // The way variableChangedEvent is a bit different than the reference implementation.\n  // Originally it uses the C# += operator to add delegates, but in js we need to maintain\n  // an actual collection of delegates (ie. callbacks) to register a new one, there is a\n  // special ObserveVariableChange method below.\n  public variableChangedEventCallbacks: Array<\n    (variableName: string, newValue: InkObject) => void\n  > = [];\n  public variableChangedEvent(variableName: string, newValue: InkObject): void {\n    for (let callback of this.variableChangedEventCallbacks) {\n      callback(variableName, newValue);\n    }\n  }\n\n  public patch: StatePatch | null = null;\n\n  get batchObservingVariableChanges() {\n    return this._batchObservingVariableChanges;\n  }\n  set batchObservingVariableChanges(value: boolean) {\n    this._batchObservingVariableChanges = value;\n    if (value) {\n      this._changedVariablesForBatchObs = new Set();\n    } else {\n      if (this._changedVariablesForBatchObs != null) {\n        for (let variableName of this._changedVariablesForBatchObs) {\n          let currentValue = this._globalVariables.get(variableName);\n          if (!currentValue) {\n            throwNullException(\"currentValue\");\n          } else {\n            this.variableChangedEvent(variableName, currentValue);\n          }\n        }\n\n        this._changedVariablesForBatchObs = null;\n      }\n    }\n  }\n\n  get callStack() {\n    return this._callStack;\n  }\n  set callStack(callStack) {\n    this._callStack = callStack;\n  }\n\n  private _batchObservingVariableChanges: boolean = false;\n\n  // the original code uses a magic getter and setter for global variables,\n  // allowing things like variableState['varname]. This is not quite possible\n  // in js without a Proxy, so it is replaced with this $ function.\n  public $(variableName: string): VariableStateValue;\n  public $(variableName: string, value: VariableStateValue): void;\n  public $(variableName: string, value?: any) {\n    if (typeof value === \"undefined\") {\n      let varContents = null;\n\n      if (this.patch !== null) {\n        varContents = this.patch.TryGetGlobal(variableName, null);\n        if (varContents.exists)\n          return (varContents.result as AbstractValue).valueObject;\n      }\n\n      varContents = this._globalVariables.get(variableName);\n\n      if (typeof varContents === \"undefined\") {\n        varContents = this._defaultGlobalVariables.get(variableName);\n      }\n\n      if (typeof varContents !== \"undefined\")\n        return (varContents as AbstractValue).valueObject;\n      else return null;\n    } else {\n      if (typeof this._defaultGlobalVariables.get(variableName) === \"undefined\")\n        throw new StoryException(\n          \"Cannot assign to a variable (\" +\n            variableName +\n            \") that hasn't been declared in the story\"\n        );\n\n      let val = Value.Create(value);\n      if (val == null) {\n        if (value == null) {\n          throw new Error(\"Cannot pass null to VariableState\");\n        } else {\n          throw new Error(\n            \"Invalid value passed to VariableState: \" + value.toString()\n          );\n        }\n      }\n\n      this.SetGlobal(variableName, val);\n    }\n  }\n\n  constructor(\n    callStack: CallStack,\n    listDefsOrigin: ListDefinitionsOrigin | null\n  ) {\n    super();\n    this._globalVariables = new Map();\n    this._callStack = callStack;\n    this._listDefsOrigin = listDefsOrigin;\n\n    // if es6 proxies are available, use them.\n    try {\n      // the proxy is used to allow direct manipulation of global variables.\n      // It first tries to access the objects own property, and if none is\n      // found it delegates the call to the $ method, defined below\n      let p = new Proxy(this, {\n        get(target: any, name) {\n          return name in target ? target[name] : target.$(name);\n        },\n        set(target: any, name, value) {\n          if (name in target) target[name] = value;\n          else target.$(name, value);\n          return true; // returning a falsy value make the trap fail\n        },\n      });\n\n      return p;\n    } catch (e) {\n      // the proxy object is not available in this context. we should warn the\n      // dev but writing to the console feels a bit intrusive.\n      // console.log(\"ES6 Proxy not available - direct manipulation of global variables can't work, use $() instead.\");\n    }\n  }\n\n  public ApplyPatch() {\n    if (this.patch === null) {\n      return throwNullException(\"this.patch\");\n    }\n\n    for (let [namedVarKey, namedVarValue] of this.patch.globals) {\n      this._globalVariables.set(namedVarKey, namedVarValue);\n    }\n\n    if (this._changedVariablesForBatchObs !== null) {\n      for (let name of this.patch.changedVariables) {\n        this._changedVariablesForBatchObs.add(name);\n      }\n    }\n\n    this.patch = null;\n  }\n\n  public SetJsonToken(jToken: Record<string, any>) {\n    this._globalVariables.clear();\n\n    for (let [varValKey, varValValue] of this._defaultGlobalVariables) {\n      let loadedToken = jToken[varValKey];\n      if (typeof loadedToken !== \"undefined\") {\n        let tokenInkObject =\n          JsonSerialisation.JTokenToRuntimeObject(loadedToken);\n        if (tokenInkObject === null) {\n          return throwNullException(\"tokenInkObject\");\n        }\n        this._globalVariables.set(varValKey, tokenInkObject);\n      } else {\n        this._globalVariables.set(varValKey, varValValue);\n      }\n    }\n  }\n\n  public static dontSaveDefaultValues: boolean = true;\n\n  public WriteJson(writer: SimpleJson.Writer) {\n    writer.WriteObjectStart();\n    for (let [keyValKey, keyValValue] of this._globalVariables) {\n      let name = keyValKey;\n      let val = keyValValue;\n\n      if (VariablesState.dontSaveDefaultValues) {\n        if (this._defaultGlobalVariables.has(name)) {\n          let defaultVal = this._defaultGlobalVariables.get(name)!;\n          if (this.RuntimeObjectsEqual(val, defaultVal)) continue;\n        }\n      }\n\n      writer.WritePropertyStart(name);\n      JsonSerialisation.WriteRuntimeObject(writer, val);\n      writer.WritePropertyEnd();\n    }\n    writer.WriteObjectEnd();\n  }\n\n  public RuntimeObjectsEqual(\n    obj1: InkObject | null,\n    obj2: InkObject | null\n  ): boolean {\n    if (obj1 === null) {\n      return throwNullException(\"obj1\");\n    }\n    if (obj2 === null) {\n      return throwNullException(\"obj2\");\n    }\n\n    if (obj1.constructor !== obj2.constructor) return false;\n\n    let boolVal = asOrNull(obj1, BoolValue);\n    if (boolVal !== null) {\n      return boolVal.value === asOrThrows(obj2, BoolValue).value;\n    }\n\n    let intVal = asOrNull(obj1, IntValue);\n    if (intVal !== null) {\n      return intVal.value === asOrThrows(obj2, IntValue).value;\n    }\n\n    let floatVal = asOrNull(obj1, FloatValue);\n    if (floatVal !== null) {\n      return floatVal.value === asOrThrows(obj2, FloatValue).value;\n    }\n\n    let val1 = asOrNull(obj1, Value);\n    let val2 = asOrNull(obj2, Value);\n    if (val1 !== null && val2 !== null) {\n      if (isEquatable(val1.valueObject) && isEquatable(val2.valueObject)) {\n        return val1.valueObject.Equals(val2.valueObject);\n      } else {\n        return val1.valueObject === val2.valueObject;\n      }\n    }\n\n    throw new Error(\n      \"FastRoughDefinitelyEquals: Unsupported runtime object type: \" +\n        obj1.constructor.name\n    );\n  }\n\n  public GetVariableWithName(\n    name: string | null,\n    contextIndex: number = -1\n  ): InkObject | null {\n    let varValue = this.GetRawVariableWithName(name, contextIndex);\n\n    // var varPointer = varValue as VariablePointerValue;\n    let varPointer = asOrNull(varValue, VariablePointerValue);\n    if (varPointer !== null) {\n      varValue = this.ValueAtVariablePointer(varPointer);\n    }\n\n    return varValue;\n  }\n\n  public TryGetDefaultVariableValue(name: string | null): InkObject | null {\n    let val = tryGetValueFromMap(this._defaultGlobalVariables, name, null);\n    return val.exists ? val.result : null;\n  }\n\n  public GlobalVariableExistsWithName(name: string) {\n    return (\n      this._globalVariables.has(name) ||\n      (this._defaultGlobalVariables !== null &&\n        this._defaultGlobalVariables.has(name))\n    );\n  }\n\n  public GetRawVariableWithName(name: string | null, contextIndex: number) {\n    let varValue: InkObject | null = null;\n\n    if (contextIndex == 0 || contextIndex == -1) {\n      let variableValue = null;\n      if (this.patch !== null) {\n        variableValue = this.patch.TryGetGlobal(name, null);\n        if (variableValue.exists) return variableValue.result!;\n      }\n\n      // this is a conditional assignment\n      variableValue = tryGetValueFromMap(this._globalVariables, name, null);\n      if (variableValue.exists) return variableValue.result;\n\n      if (this._defaultGlobalVariables !== null) {\n        variableValue = tryGetValueFromMap(\n          this._defaultGlobalVariables,\n          name,\n          null\n        );\n        if (variableValue.exists) return variableValue.result;\n      }\n\n      if (this._listDefsOrigin === null)\n        return throwNullException(\"VariablesState._listDefsOrigin\");\n      let listItemValue = this._listDefsOrigin.FindSingleItemListWithName(name);\n      if (listItemValue) return listItemValue;\n    }\n\n    varValue = this._callStack.GetTemporaryVariableWithName(name, contextIndex);\n\n    return varValue;\n  }\n\n  public ValueAtVariablePointer(pointer: VariablePointerValue) {\n    return this.GetVariableWithName(pointer.variableName, pointer.contextIndex);\n  }\n\n  public Assign(varAss: VariableAssignment, value: InkObject) {\n    let name = varAss.variableName;\n    if (name === null) {\n      return throwNullException(\"name\");\n    }\n    let contextIndex = -1;\n\n    let setGlobal = false;\n    if (varAss.isNewDeclaration) {\n      setGlobal = varAss.isGlobal;\n    } else {\n      setGlobal = this.GlobalVariableExistsWithName(name);\n    }\n\n    if (varAss.isNewDeclaration) {\n      // var varPointer = value as VariablePointerValue;\n      let varPointer = asOrNull(value, VariablePointerValue);\n      if (varPointer !== null) {\n        let fullyResolvedVariablePointer =\n          this.ResolveVariablePointer(varPointer);\n        value = fullyResolvedVariablePointer;\n      }\n    } else {\n      let existingPointer = null;\n      do {\n        // existingPointer = GetRawVariableWithName (name, contextIndex) as VariablePointerValue;\n        existingPointer = asOrNull(\n          this.GetRawVariableWithName(name, contextIndex),\n          VariablePointerValue\n        );\n        if (existingPointer != null) {\n          name = existingPointer.variableName;\n          contextIndex = existingPointer.contextIndex;\n          setGlobal = contextIndex == 0;\n        }\n      } while (existingPointer != null);\n    }\n\n    if (setGlobal) {\n      this.SetGlobal(name, value);\n    } else {\n      this._callStack.SetTemporaryVariable(\n        name,\n        value,\n        varAss.isNewDeclaration,\n        contextIndex\n      );\n    }\n  }\n\n  public SnapshotDefaultGlobals() {\n    this._defaultGlobalVariables = new Map(this._globalVariables);\n  }\n\n  public RetainListOriginsForAssignment(\n    oldValue: InkObject,\n    newValue: InkObject\n  ) {\n    let oldList = asOrThrows(oldValue, ListValue);\n    let newList = asOrThrows(newValue, ListValue);\n\n    if (oldList.value && newList.value && newList.value.Count == 0) {\n      newList.value.SetInitialOriginNames(oldList.value.originNames);\n    }\n  }\n\n  public SetGlobal(variableName: string | null, value: InkObject) {\n    let oldValue = null;\n\n    if (this.patch === null) {\n      oldValue = tryGetValueFromMap(this._globalVariables, variableName, null);\n    }\n\n    if (this.patch !== null) {\n      oldValue = this.patch.TryGetGlobal(variableName, null);\n      if (!oldValue.exists) {\n        oldValue = tryGetValueFromMap(\n          this._globalVariables,\n          variableName,\n          null\n        );\n      }\n    }\n\n    ListValue.RetainListOriginsForAssignment(oldValue!.result!, value);\n\n    if (variableName === null) {\n      return throwNullException(\"variableName\");\n    }\n\n    if (this.patch !== null) {\n      this.patch.SetGlobal(variableName, value);\n    } else {\n      this._globalVariables.set(variableName, value);\n    }\n\n    // TODO: Not sure !== is equivalent to !value.Equals(oldValue)\n    if (\n      this.variableChangedEvent !== null &&\n      oldValue !== null &&\n      value !== oldValue.result\n    ) {\n      if (this.batchObservingVariableChanges) {\n        if (this._changedVariablesForBatchObs === null) {\n          return throwNullException(\"this._changedVariablesForBatchObs\");\n        }\n\n        if (this.patch !== null) {\n          this.patch.AddChangedVariable(variableName);\n        } else if (this._changedVariablesForBatchObs !== null) {\n          this._changedVariablesForBatchObs.add(variableName);\n        }\n      } else {\n        this.variableChangedEvent(variableName, value);\n      }\n    }\n  }\n\n  public ResolveVariablePointer(varPointer: VariablePointerValue) {\n    let contextIndex = varPointer.contextIndex;\n\n    if (contextIndex == -1)\n      contextIndex = this.GetContextIndexOfVariableNamed(\n        varPointer.variableName\n      );\n\n    let valueOfVariablePointedTo = this.GetRawVariableWithName(\n      varPointer.variableName,\n      contextIndex\n    );\n\n    // var doubleRedirectionPointer = valueOfVariablePointedTo as VariablePointerValue;\n    let doubleRedirectionPointer = asOrNull(\n      valueOfVariablePointedTo,\n      VariablePointerValue\n    );\n    if (doubleRedirectionPointer != null) {\n      return doubleRedirectionPointer;\n    } else {\n      return new VariablePointerValue(varPointer.variableName, contextIndex);\n    }\n  }\n\n  public GetContextIndexOfVariableNamed(varName: string) {\n    if (this.GlobalVariableExistsWithName(varName)) return 0;\n\n    return this._callStack.currentElementIndex;\n  }\n\n  /**\n   * This function is specific to the js version of ink. It allows to register a\n   * callback that will be called when a variable changes. The original code uses\n   * `state.variableChangedEvent += callback` instead.\n   *\n   * @param {function} callback\n   */\n  public ObserveVariableChange(\n    callback: (variableName: string, newValue: InkObject) => void\n  ) {\n    this.variableChangedEventCallbacks.push(callback);\n  }\n\n  private _globalVariables: Map<string, InkObject>;\n  private _defaultGlobalVariables: Map<string, InkObject> = new Map();\n\n  private _callStack: CallStack;\n  private _changedVariablesForBatchObs: Set<string> | null = new Set();\n  private _listDefsOrigin: ListDefinitionsOrigin | null;\n}\n","// Taken from https://gist.github.com/blixt/f17b47c62508be59987b\n// Ink uses a seedable PRNG of which there is none in native javascript.\nexport class PRNG {\n  private seed: number;\n\n  constructor(seed: number) {\n    this.seed = seed % 2147483647;\n    if (this.seed <= 0) this.seed += 2147483646;\n  }\n  public next(): number {\n    return (this.seed = (this.seed * 48271) % 2147483647);\n  }\n  public nextFloat(): number {\n    return (this.next() - 1) / 2147483646;\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Container } from \"./Container\";\n\nexport class StatePatch {\n  get globals() {\n    return this._globals;\n  }\n  get changedVariables() {\n    return this._changedVariables;\n  }\n  get visitCounts() {\n    return this._visitCounts;\n  }\n  get turnIndices() {\n    return this._turnIndices;\n  }\n\n  constructor();\n  constructor(toCopy: StatePatch | null);\n  constructor() {\n    if (arguments.length === 1 && arguments[0] !== null) {\n      let toCopy = arguments[0] as StatePatch;\n      this._globals = new Map(toCopy._globals);\n      this._changedVariables = new Set(toCopy._changedVariables);\n      this._visitCounts = new Map(toCopy._visitCounts);\n      this._turnIndices = new Map(toCopy._turnIndices);\n    } else {\n      this._globals = new Map();\n      this._changedVariables = new Set();\n      this._visitCounts = new Map();\n      this._turnIndices = new Map();\n    }\n  }\n\n  public TryGetGlobal(name: string | null, /* out */ value: InkObject | null) {\n    if (name !== null && this._globals.has(name)) {\n      return { result: this._globals.get(name), exists: true };\n    }\n\n    return { result: value, exists: false };\n  }\n\n  public SetGlobal(name: string, value: InkObject) {\n    this._globals.set(name, value);\n  }\n\n  public AddChangedVariable(name: string) {\n    return this._changedVariables.add(name);\n  }\n\n  public TryGetVisitCount(container: Container, /* out */ count: number) {\n    if (this._visitCounts.has(container)) {\n      return { result: this._visitCounts.get(container), exists: true };\n    }\n\n    return { result: count, exists: false };\n  }\n\n  public SetVisitCount(container: Container, count: number) {\n    this._visitCounts.set(container, count);\n  }\n\n  public SetTurnIndex(container: Container, index: number) {\n    this._turnIndices.set(container, index);\n  }\n\n  public TryGetTurnIndex(container: Container, /* out */ index: number) {\n    if (this._turnIndices.has(container)) {\n      return { result: this._turnIndices.get(container), exists: true };\n    }\n\n    return { result: index, exists: false };\n  }\n\n  private _globals: Map<string, InkObject>;\n  private _changedVariables: Set<string> = new Set();\n  private _visitCounts: Map<Container, number> = new Map();\n  private _turnIndices: Map<Container, number> = new Map();\n}\n","export class SimpleJson {\n  public static TextToDictionary(text: string) {\n    return new SimpleJson.Reader(text).ToDictionary();\n  }\n\n  public static TextToArray(text: string) {\n    return new SimpleJson.Reader(text).ToArray();\n  }\n}\n\nexport namespace SimpleJson {\n  export class Reader {\n    constructor(text: string) {\n      this._rootObject = JSON.parse(text);\n    }\n\n    public ToDictionary() {\n      return this._rootObject as Record<string, any>;\n    }\n\n    public ToArray() {\n      return this._rootObject as any[];\n    }\n\n    private _rootObject: any[] | Record<string, any>;\n  }\n\n  // In C#, this class writes json tokens directly to a StringWriter or\n  // another stream. Here, a temporary hierarchy is created in the form\n  // of a javascript object, which is serialised in the `toString` method.\n  // See individual methods and properties for more information.\n  export class Writer {\n    public WriteObject(inner: (w: Writer) => void) {\n      this.WriteObjectStart();\n      inner(this);\n      this.WriteObjectEnd();\n    }\n\n    // Add a new object.\n    public WriteObjectStart() {\n      this.StartNewObject(true);\n\n      let newObject: Record<string, any> = {};\n\n      if (this.state === SimpleJson.Writer.State.Property) {\n        // This object is created as the value of a property,\n        // inside an other object.\n        this.Assert(this.currentCollection !== null);\n        this.Assert(this.currentPropertyName !== null);\n\n        let propertyName = this._propertyNameStack.pop();\n        this.currentCollection![propertyName!] = newObject;\n        this._collectionStack.push(newObject);\n      } else if (this.state === SimpleJson.Writer.State.Array) {\n        // This object is created as the child of an array.\n        this.Assert(this.currentCollection !== null);\n\n        this.currentCollection!.push(newObject);\n        this._collectionStack.push(newObject);\n      } else {\n        // This object is the root object.\n        this.Assert(this.state === SimpleJson.Writer.State.None);\n        this._jsonObject = newObject;\n        this._collectionStack.push(newObject);\n      }\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Object)\n      );\n    }\n\n    public WriteObjectEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.Object);\n      this._collectionStack.pop();\n      this._stateStack.pop();\n    }\n\n    // Write a property name / value pair to the current object.\n    public WriteProperty(\n      name: any,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      innerOrContent: ((w: Writer) => void) | string | boolean | null\n    ) {\n      this.WritePropertyStart(name);\n      if (arguments[1] instanceof Function) {\n        let inner = arguments[1];\n        inner(this);\n      } else {\n        let content: string | boolean | null = arguments[1];\n        this.Write(content);\n      }\n      this.WritePropertyEnd();\n    }\n\n    // Int and Float are separate calls, since there both are\n    // numbers in JavaScript, but need to be handled differently.\n\n    public WriteIntProperty(name: any, content: number) {\n      this.WritePropertyStart(name);\n      this.WriteInt(content);\n      this.WritePropertyEnd();\n    }\n\n    public WriteFloatProperty(name: any, content: number) {\n      this.WritePropertyStart(name);\n      this.WriteFloat(content);\n      this.WritePropertyEnd();\n    }\n\n    // Prepare a new property name, which will be use to add the\n    // new object when calling _addToCurrentObject() from a Write\n    // method.\n    public WritePropertyStart(name: any) {\n      this.Assert(this.state === SimpleJson.Writer.State.Object);\n      this._propertyNameStack.push(name);\n\n      this.IncrementChildCount();\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Property)\n      );\n    }\n\n    public WritePropertyEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.Property);\n      this.Assert(this.childCount === 1);\n      this._stateStack.pop();\n    }\n\n    // Prepare a new property name, except this time, the property name\n    // will be created by concatenating all the strings passed to\n    // WritePropertyNameInner.\n    public WritePropertyNameStart() {\n      this.Assert(this.state === SimpleJson.Writer.State.Object);\n      this.IncrementChildCount();\n\n      this._currentPropertyName = \"\";\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Property)\n      );\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.PropertyName)\n      );\n    }\n\n    public WritePropertyNameEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.PropertyName);\n      this.Assert(this._currentPropertyName !== null);\n      this._propertyNameStack.push(this._currentPropertyName!);\n      this._currentPropertyName = null;\n      this._stateStack.pop();\n    }\n\n    public WritePropertyNameInner(str: string) {\n      this.Assert(this.state === SimpleJson.Writer.State.PropertyName);\n      this.Assert(this._currentPropertyName !== null);\n      this._currentPropertyName += str;\n    }\n\n    // Add a new array.\n    public WriteArrayStart() {\n      this.StartNewObject(true);\n\n      let newObject: any[] = [];\n\n      if (this.state === SimpleJson.Writer.State.Property) {\n        // This array is created as the value of a property,\n        // inside an object.\n        this.Assert(this.currentCollection !== null);\n        this.Assert(this.currentPropertyName !== null);\n\n        let propertyName = this._propertyNameStack.pop();\n        this.currentCollection![propertyName!] = newObject;\n        this._collectionStack.push(newObject);\n      } else if (this.state === SimpleJson.Writer.State.Array) {\n        // This array is created as the child of another array.\n        this.Assert(this.currentCollection !== null);\n\n        this.currentCollection!.push(newObject);\n        this._collectionStack.push(newObject);\n      } else {\n        // This array is the root object.\n        this.Assert(this.state === SimpleJson.Writer.State.None);\n        this._jsonObject = newObject;\n        this._collectionStack.push(newObject);\n      }\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Array)\n      );\n    }\n\n    public WriteArrayEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.Array);\n      this._collectionStack.pop();\n      this._stateStack.pop();\n    }\n\n    // Add the value to the appropriate collection (array / object), given the current\n    // context.\n    public Write(\n      value: number | string | boolean | null,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      escape: boolean = true\n    ) {\n      if (value === null) {\n        console.error(\"Warning: trying to write a null value\");\n        return;\n      }\n\n      this.StartNewObject(false);\n      this._addToCurrentObject(value);\n    }\n\n    public WriteBool(value: boolean | null) {\n      if (value === null) {\n        return;\n      }\n\n      this.StartNewObject(false);\n      this._addToCurrentObject(value);\n    }\n\n    public WriteInt(value: number | null) {\n      if (value === null) {\n        return;\n      }\n\n      this.StartNewObject(false);\n\n      // Math.floor is used as a precaution:\n      //     1. to ensure that the value is written as an integer\n      //        (without a fractional part -> 1 instead of 1.0), even\n      //        though it should be the default behaviour of\n      //        JSON.serialize;\n      //     2. to ensure that if a floating number is passed\n      //        accidentally, it's converted to an integer.\n      //\n      // This guarantees savegame compatibility with the reference\n      // implementation.\n      this._addToCurrentObject(Math.floor(value));\n    }\n\n    // Since JSON doesn't support NaN and Infinity, these values\n    // are converted here.\n    public WriteFloat(value: number | null) {\n      if (value === null) {\n        return;\n      }\n\n      this.StartNewObject(false);\n      if (value == Number.POSITIVE_INFINITY) {\n        this._addToCurrentObject(3.4e38);\n      } else if (value == Number.NEGATIVE_INFINITY) {\n        this._addToCurrentObject(-3.4e38);\n      } else if (isNaN(value)) {\n        this._addToCurrentObject(0.0);\n      } else {\n        this._addToCurrentObject(value);\n      }\n    }\n\n    public WriteNull() {\n      this.StartNewObject(false);\n      this._addToCurrentObject(null);\n    }\n\n    // Prepare a string before adding it to the current collection in\n    // WriteStringEnd(). The string will be a concatenation of all the\n    // strings passed to WriteStringInner.\n    public WriteStringStart() {\n      this.StartNewObject(false);\n      this._currentString = \"\";\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.String)\n      );\n    }\n\n    public WriteStringEnd() {\n      this.Assert(this.state == SimpleJson.Writer.State.String);\n      this._stateStack.pop();\n      this._addToCurrentObject(this._currentString);\n      this._currentString = null;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    public WriteStringInner(str: string | null, escape: boolean = true) {\n      this.Assert(this.state === SimpleJson.Writer.State.String);\n\n      if (str === null) {\n        console.error(\"Warning: trying to write a null string\");\n        return;\n      }\n\n      this._currentString += str;\n    }\n\n    // Serialise the root object into a JSON string.\n    public toString() {\n      if (this._jsonObject === null) {\n        return \"\";\n      }\n\n      return JSON.stringify(this._jsonObject);\n    }\n\n    // Prepare the state stack when adding new objects / values.\n    private StartNewObject(container: boolean) {\n      if (container) {\n        this.Assert(\n          this.state === SimpleJson.Writer.State.None ||\n            this.state === SimpleJson.Writer.State.Property ||\n            this.state === SimpleJson.Writer.State.Array\n        );\n      } else {\n        this.Assert(\n          this.state === SimpleJson.Writer.State.Property ||\n            this.state === SimpleJson.Writer.State.Array\n        );\n      }\n\n      if (this.state === SimpleJson.Writer.State.Property) {\n        this.Assert(this.childCount === 0);\n      }\n\n      if (\n        this.state === SimpleJson.Writer.State.Array ||\n        this.state === SimpleJson.Writer.State.Property\n      ) {\n        this.IncrementChildCount();\n      }\n    }\n\n    // These getters peek all the different stacks.\n\n    private get state() {\n      if (this._stateStack.length > 0) {\n        return this._stateStack[this._stateStack.length - 1].type;\n      } else {\n        return SimpleJson.Writer.State.None;\n      }\n    }\n\n    private get childCount() {\n      if (this._stateStack.length > 0) {\n        return this._stateStack[this._stateStack.length - 1].childCount;\n      } else {\n        return 0;\n      }\n    }\n\n    private get currentCollection() {\n      if (this._collectionStack.length > 0) {\n        return this._collectionStack[this._collectionStack.length - 1];\n      } else {\n        return null;\n      }\n    }\n\n    private get currentPropertyName() {\n      if (this._propertyNameStack.length > 0) {\n        return this._propertyNameStack[this._propertyNameStack.length - 1];\n      } else {\n        return null;\n      }\n    }\n\n    private IncrementChildCount() {\n      this.Assert(this._stateStack.length > 0);\n      let currEl = this._stateStack.pop()!;\n      currEl.childCount++;\n      this._stateStack.push(currEl);\n    }\n\n    private Assert(condition: boolean) {\n      if (!condition) throw Error(\"Assert failed while writing JSON\");\n    }\n\n    // This method did not exist in the original C# code. It adds\n    // the given value to the current collection (used by Write methods).\n    private _addToCurrentObject(value: number | string | boolean | null) {\n      this.Assert(this.currentCollection !== null);\n      if (this.state === SimpleJson.Writer.State.Array) {\n        this.Assert(Array.isArray(this.currentCollection));\n        (this.currentCollection as any[]).push(value);\n      } else if (this.state === SimpleJson.Writer.State.Property) {\n        this.Assert(!Array.isArray(this.currentCollection));\n        this.Assert(this.currentPropertyName !== null);\n        (this.currentCollection as Record<string, any>)[\n          this.currentPropertyName!\n        ] = value;\n        this._propertyNameStack.pop();\n      }\n    }\n\n    // In addition to `_stateStack` present in the original code,\n    // this implementation of SimpleJson use two other stacks and two\n    // temporary variables holding the current context.\n\n    // Used to keep track of the current property name being built\n    // with `WritePropertyNameStart`, `WritePropertyNameInner` and\n    // `WritePropertyNameEnd`.\n    private _currentPropertyName: string | null = null;\n\n    // Used to keep track of the current string value being built\n    // with `WriteStringStart`, `WriteStringInner` and\n    // `WriteStringEnd`.\n    private _currentString: string | null = null;\n\n    private _stateStack: SimpleJson.Writer.StateElement[] = [];\n\n    // Keep track of the current collection being built (either an array\n    // or an object). For instance, at the '?' step during the hiarchy\n    // creation, this hierarchy:\n    // [3, {a: [b, ?]}] will have this corresponding stack:\n    // (bottom) [Array, Object, Array] (top)\n    private _collectionStack: Array<any[] | Record<string, any>> = [];\n\n    // Keep track of the current property being assigned. For instance, at\n    // the '?' step during the hiarchy creation, this hierarchy:\n    // [3, {a: [b, {c: ?}]}] will have this corresponding stack:\n    // (bottom) [a, c] (top)\n    private _propertyNameStack: string[] = [];\n\n    // Object containing the entire hiearchy.\n    private _jsonObject: Record<string, any> | any[] | null = null;\n  }\n\n  export namespace Writer {\n    export enum State {\n      None,\n      Object,\n      Array,\n      Property,\n      PropertyName,\n      String,\n    }\n\n    export class StateElement {\n      public type: SimpleJson.Writer.State = SimpleJson.Writer.State.None;\n      public childCount: number = 0;\n\n      constructor(type: SimpleJson.Writer.State) {\n        this.type = type;\n      }\n    }\n  }\n}\n","import { CallStack } from \"./CallStack\";\nimport { Choice } from \"./Choice\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { InkObject } from \"./Object\";\nimport { SimpleJson } from \"./SimpleJson\";\nimport { Story } from \"./Story\";\nimport { throwNullException } from \"./NullException\";\n\nexport class Flow {\n  public name: string;\n  public callStack: CallStack;\n  public outputStream: InkObject[];\n  public currentChoices: Choice[];\n\n  constructor(name: String, story: Story);\n  constructor(name: String, story: Story, jObject: Record<string, any>);\n  constructor() {\n    let name = arguments[0] as string;\n    let story = arguments[1] as Story;\n\n    this.name = name;\n    this.callStack = new CallStack(story);\n\n    if (arguments[2]) {\n      let jObject = arguments[2] as Record<string, any>;\n\n      this.callStack.SetJsonToken(jObject[\"callstack\"], story);\n      this.outputStream = JsonSerialisation.JArrayToRuntimeObjList(\n        jObject[\"outputStream\"]\n      );\n      this.currentChoices = JsonSerialisation.JArrayToRuntimeObjList(\n        jObject[\"currentChoices\"]\n      ) as Choice[];\n\n      let jChoiceThreadsObj = jObject[\"choiceThreads\"];\n      if (typeof jChoiceThreadsObj !== \"undefined\") {\n        this.LoadFlowChoiceThreads(jChoiceThreadsObj, story);\n      }\n    } else {\n      this.outputStream = [];\n      this.currentChoices = [];\n    }\n  }\n\n  public WriteJson(writer: SimpleJson.Writer) {\n    writer.WriteObjectStart();\n\n    writer.WriteProperty(\"callstack\", (w) => this.callStack.WriteJson(w));\n    writer.WriteProperty(\"outputStream\", (w) =>\n      JsonSerialisation.WriteListRuntimeObjs(w, this.outputStream)\n    );\n\n    let hasChoiceThreads = false;\n    for (let c of this.currentChoices) {\n      if (c.threadAtGeneration === null)\n        return throwNullException(\"c.threadAtGeneration\");\n\n      c.originalThreadIndex = c.threadAtGeneration.threadIndex;\n\n      if (this.callStack.ThreadWithIndex(c.originalThreadIndex) === null) {\n        if (!hasChoiceThreads) {\n          hasChoiceThreads = true;\n          writer.WritePropertyStart(\"choiceThreads\");\n          writer.WriteObjectStart();\n        }\n\n        writer.WritePropertyStart(c.originalThreadIndex);\n        c.threadAtGeneration.WriteJson(writer);\n        writer.WritePropertyEnd();\n      }\n    }\n\n    if (hasChoiceThreads) {\n      writer.WriteObjectEnd();\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteProperty(\"currentChoices\", (w) => {\n      w.WriteArrayStart();\n      for (let c of this.currentChoices) {\n        JsonSerialisation.WriteChoice(w, c);\n      }\n      w.WriteArrayEnd();\n    });\n\n    writer.WriteObjectEnd();\n  }\n\n  public LoadFlowChoiceThreads(\n    jChoiceThreads: Record<string, any>,\n    story: Story\n  ) {\n    for (let choice of this.currentChoices) {\n      let foundActiveThread = this.callStack.ThreadWithIndex(\n        choice.originalThreadIndex\n      );\n      if (foundActiveThread !== null) {\n        choice.threadAtGeneration = foundActiveThread.Copy();\n      } else {\n        let jSavedChoiceThread =\n          jChoiceThreads[`${choice.originalThreadIndex}`];\n        choice.threadAtGeneration = new CallStack.Thread(\n          jSavedChoiceThread,\n          story\n        );\n      }\n    }\n  }\n}\n","// TODO: Unify with Compiler.\n\nexport type ErrorHandler = (message: string, type: ErrorType) => void;\n\nexport enum ErrorType {\n  Author,\n  Warning,\n  Error,\n}\n","import { CallStack } from \"./CallStack\";\nimport { VariablesState } from \"./VariablesState\";\nimport { ValueType, Value, StringValue, ListValue } from \"./Value\";\nimport { PushPopType } from \"./PushPop\";\nimport { Tag } from \"./Tag\";\nimport { Glue } from \"./Glue\";\nimport { Path } from \"./Path\";\nimport { ControlCommand } from \"./ControlCommand\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { PRNG } from \"./PRNG\";\nimport { Void } from \"./Void\";\nimport { Pointer } from \"./Pointer\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { Choice } from \"./Choice\";\nimport { asOrNull, asOrThrows, nullIfUndefined } from \"./TypeAssertion\";\nimport { Debug } from \"./Debug\";\nimport { Container } from \"./Container\";\nimport { InkObject } from \"./Object\";\nimport { throwNullException } from \"./NullException\";\nimport { Story } from \"./Story\";\nimport { StatePatch } from \"./StatePatch\";\nimport { SimpleJson } from \"./SimpleJson\";\nimport { Flow } from \"./Flow\";\nimport { InkList } from \"./InkList\";\n\nexport class StoryState {\n  // Backward compatible changes since v8:\n  // v10: dynamic tags\n  // v9:  multi-flows\n  public readonly kInkSaveStateVersion = 10;\n  public readonly kMinCompatibleLoadVersion = 8;\n\n  public onDidLoadState: (() => void) | null = null;\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  public ToJson(indented: boolean = false) {\n    let writer = new SimpleJson.Writer();\n    this.WriteJson(writer);\n    return writer.toString();\n  }\n  public toJson(indented: boolean = false) {\n    return this.ToJson(indented);\n  }\n\n  public LoadJson(json: string) {\n    let jObject = SimpleJson.TextToDictionary(json);\n    this.LoadJsonObj(jObject);\n    if (this.onDidLoadState !== null) this.onDidLoadState();\n  }\n\n  public VisitCountAtPathString(pathString: string) {\n    let visitCountOut;\n\n    if (this._patch !== null) {\n      let container = this.story.ContentAtPath(new Path(pathString)).container;\n      if (container === null)\n        throw new Error(\"Content at path not found: \" + pathString);\n\n      visitCountOut = this._patch.TryGetVisitCount(container, 0);\n      if (visitCountOut.exists) return visitCountOut.result;\n    }\n\n    visitCountOut = tryGetValueFromMap(this._visitCounts, pathString, null);\n    if (visitCountOut.exists) return visitCountOut.result;\n\n    return 0;\n  }\n\n  public VisitCountForContainer(container: Container | null): number {\n    if (container === null) {\n      return throwNullException(\"container\");\n    }\n    if (!container.visitsShouldBeCounted) {\n      this.story.Error(\n        \"Read count for target (\" +\n          container.name +\n          \" - on \" +\n          container.debugMetadata +\n          \") unknown. The story may need to be compiled with countAllVisits flag (-c).\"\n      );\n      return 0;\n    }\n\n    if (this._patch !== null) {\n      let count = this._patch.TryGetVisitCount(container, 0);\n      if (count.exists) {\n        return count.result!;\n      }\n    }\n\n    let containerPathStr = container.path.toString();\n    let count2 = tryGetValueFromMap(this._visitCounts, containerPathStr, null);\n    if (count2.exists) {\n      return count2.result!;\n    }\n\n    return 0;\n  }\n\n  public IncrementVisitCountForContainer(container: Container) {\n    if (this._patch !== null) {\n      let currCount = this.VisitCountForContainer(container);\n      currCount++;\n      this._patch.SetVisitCount(container, currCount);\n      return;\n    }\n\n    let containerPathStr = container.path.toString();\n    let count = tryGetValueFromMap(this._visitCounts, containerPathStr, null);\n    if (count.exists) {\n      this._visitCounts.set(containerPathStr, count.result! + 1);\n    } else {\n      this._visitCounts.set(containerPathStr, 1);\n    }\n  }\n\n  public RecordTurnIndexVisitToContainer(container: Container) {\n    if (this._patch !== null) {\n      this._patch.SetTurnIndex(container, this.currentTurnIndex);\n      return;\n    }\n\n    let containerPathStr = container.path.toString();\n    this._turnIndices.set(containerPathStr, this.currentTurnIndex);\n  }\n\n  public TurnsSinceForContainer(container: Container) {\n    if (!container.turnIndexShouldBeCounted) {\n      this.story.Error(\n        \"TURNS_SINCE() for target (\" +\n          container.name +\n          \" - on \" +\n          container.debugMetadata +\n          \") unknown. The story may need to be compiled with countAllVisits flag (-c).\"\n      );\n    }\n\n    if (this._patch !== null) {\n      let index = this._patch.TryGetTurnIndex(container, 0);\n      if (index.exists) {\n        return this.currentTurnIndex - index.result!;\n      }\n    }\n\n    let containerPathStr = container.path.toString();\n    let index2 = tryGetValueFromMap(this._turnIndices, containerPathStr, 0);\n    if (index2.exists) {\n      return this.currentTurnIndex - index2.result!;\n    } else {\n      return -1;\n    }\n  }\n\n  get callstackDepth() {\n    return this.callStack.depth;\n  }\n\n  get outputStream() {\n    return this._currentFlow.outputStream;\n  }\n\n  get currentChoices() {\n    // If we can continue generating text content rather than choices,\n    // then we reflect the choice list as being empty, since choices\n    // should always come at the end.\n    if (this.canContinue) return [];\n    return this._currentFlow.currentChoices;\n  }\n\n  get generatedChoices() {\n    return this._currentFlow.currentChoices;\n  }\n\n  get currentErrors() {\n    return this._currentErrors;\n  }\n  private _currentErrors: string[] | null = null;\n\n  get currentWarnings() {\n    return this._currentWarnings;\n  }\n  private _currentWarnings: string[] | null = null;\n\n  get variablesState() {\n    return this._variablesState;\n  }\n  set variablesState(value) {\n    this._variablesState = value;\n  }\n  private _variablesState: VariablesState;\n\n  get callStack() {\n    return this._currentFlow.callStack;\n  }\n\n  get evaluationStack() {\n    return this._evaluationStack;\n  }\n  private _evaluationStack: InkObject[];\n\n  public divertedPointer: Pointer = Pointer.Null;\n\n  get currentTurnIndex() {\n    return this._currentTurnIndex;\n  }\n  set currentTurnIndex(value) {\n    this._currentTurnIndex = value;\n  }\n  private _currentTurnIndex: number = 0;\n\n  public storySeed: number = 0;\n  public previousRandom: number = 0;\n  public didSafeExit: boolean = false;\n\n  public story: Story;\n\n  get currentPathString() {\n    let pointer = this.currentPointer;\n    if (pointer.isNull) {\n      return null;\n    } else {\n      if (pointer.path === null) {\n        return throwNullException(\"pointer.path\");\n      }\n      return pointer.path.toString();\n    }\n  }\n\n  get currentPointer() {\n    return this.callStack.currentElement.currentPointer.copy();\n  }\n\n  set currentPointer(value) {\n    this.callStack.currentElement.currentPointer = value.copy();\n  }\n\n  get previousPointer() {\n    return this.callStack.currentThread.previousPointer.copy();\n  }\n\n  set previousPointer(value) {\n    this.callStack.currentThread.previousPointer = value.copy();\n  }\n\n  get canContinue() {\n    return !this.currentPointer.isNull && !this.hasError;\n  }\n\n  get hasError() {\n    return this.currentErrors != null && this.currentErrors.length > 0;\n  }\n\n  get hasWarning() {\n    return this.currentWarnings != null && this.currentWarnings.length > 0;\n  }\n\n  get currentText() {\n    if (this._outputStreamTextDirty) {\n      let sb = new StringBuilder();\n\n      let inTag: boolean = false;\n\n      for (let outputObj of this.outputStream) {\n        // var textContent = outputObj as StringValue;\n        let textContent = asOrNull(outputObj, StringValue);\n        if (!inTag && textContent !== null) {\n          sb.Append(textContent.value);\n        } else {\n          let controlCommand = asOrNull(outputObj, ControlCommand);\n          if (controlCommand !== null) {\n            if (\n              controlCommand.commandType == ControlCommand.CommandType.BeginTag\n            ) {\n              inTag = true;\n            } else if (\n              controlCommand.commandType == ControlCommand.CommandType.EndTag\n            ) {\n              inTag = false;\n            }\n          }\n        }\n      }\n\n      this._currentText = this.CleanOutputWhitespace(sb.toString());\n      this._outputStreamTextDirty = false;\n    }\n\n    return this._currentText;\n  }\n  private _currentText: string | null = null;\n\n  public CleanOutputWhitespace(str: string) {\n    let sb = new StringBuilder();\n\n    let currentWhitespaceStart = -1;\n    let startOfLine = 0;\n\n    for (let i = 0; i < str.length; i++) {\n      let c = str.charAt(i);\n\n      let isInlineWhitespace = c == \" \" || c == \"\\t\";\n\n      if (isInlineWhitespace && currentWhitespaceStart == -1)\n        currentWhitespaceStart = i;\n\n      if (!isInlineWhitespace) {\n        if (\n          c != \"\\n\" &&\n          currentWhitespaceStart > 0 &&\n          currentWhitespaceStart != startOfLine\n        ) {\n          sb.Append(\" \");\n        }\n        currentWhitespaceStart = -1;\n      }\n\n      if (c == \"\\n\") startOfLine = i + 1;\n\n      if (!isInlineWhitespace) sb.Append(c);\n    }\n\n    return sb.toString();\n  }\n\n  get currentTags() {\n    if (this._outputStreamTagsDirty) {\n      this._currentTags = [];\n      let inTag: boolean = false;\n      let sb = new StringBuilder();\n\n      for (let outputObj of this.outputStream) {\n        let controlCommand = asOrNull(outputObj, ControlCommand);\n        if (controlCommand != null) {\n          if (\n            controlCommand.commandType == ControlCommand.CommandType.BeginTag\n          ) {\n            if (inTag && sb.Length > 0) {\n              let txt = this.CleanOutputWhitespace(sb.toString());\n              this._currentTags.push(txt);\n              sb.Clear();\n            }\n            inTag = true;\n          } else if (\n            controlCommand.commandType == ControlCommand.CommandType.EndTag\n          ) {\n            if (sb.Length > 0) {\n              let txt = this.CleanOutputWhitespace(sb.toString());\n              this._currentTags.push(txt);\n              sb.Clear();\n            }\n            inTag = false;\n          }\n        } else if (inTag) {\n          let strVal = asOrNull(outputObj, StringValue);\n          if (strVal !== null) {\n            sb.Append(strVal.value);\n          }\n        } else {\n          let tag = asOrNull(outputObj, Tag);\n          if (tag != null && tag.text != null && tag.text.length > 0) {\n            this._currentTags.push(tag.text); // tag.text has whitespae already cleaned\n          }\n        }\n      }\n\n      if (sb.Length > 0) {\n        let txt = this.CleanOutputWhitespace(sb.toString());\n        this._currentTags.push(txt);\n        sb.Clear();\n      }\n\n      this._outputStreamTagsDirty = false;\n    }\n\n    return this._currentTags;\n  }\n  private _currentTags: string[] | null = null;\n\n  get currentFlowName() {\n    return this._currentFlow.name;\n  }\n\n  get currentFlowIsDefaultFlow() {\n    return this._currentFlow.name == this.kDefaultFlowName;\n  }\n\n  get aliveFlowNames() {\n    if (this._aliveFlowNamesDirty) {\n      this._aliveFlowNames = [];\n\n      if (this._namedFlows != null) {\n        for (let flowName of this._namedFlows.keys()) {\n          if (flowName != this.kDefaultFlowName) {\n            this._aliveFlowNames.push(flowName);\n          }\n        }\n      }\n\n      this._aliveFlowNamesDirty = false;\n    }\n\n    return this._aliveFlowNames;\n  }\n\n  get inExpressionEvaluation() {\n    return this.callStack.currentElement.inExpressionEvaluation;\n  }\n  set inExpressionEvaluation(value) {\n    this.callStack.currentElement.inExpressionEvaluation = value;\n  }\n\n  constructor(story: Story) {\n    this.story = story;\n\n    this._currentFlow = new Flow(this.kDefaultFlowName, story);\n    this.OutputStreamDirty();\n\n    this._aliveFlowNamesDirty = true;\n    this._evaluationStack = [];\n\n    this._variablesState = new VariablesState(\n      this.callStack,\n      story.listDefinitions\n    );\n\n    this._visitCounts = new Map();\n    this._turnIndices = new Map();\n    this.currentTurnIndex = -1;\n\n    let timeSeed = new Date().getTime();\n    this.storySeed = new PRNG(timeSeed).next() % 100;\n    this.previousRandom = 0;\n\n    this.GoToStart();\n  }\n\n  public GoToStart() {\n    this.callStack.currentElement.currentPointer = Pointer.StartOf(\n      this.story.mainContentContainer\n    );\n  }\n\n  public SwitchFlow_Internal(flowName: string | null) {\n    if (flowName === null)\n      throw new Error(\"Must pass a non-null string to Story.SwitchFlow\");\n\n    if (this._namedFlows === null) {\n      this._namedFlows = new Map();\n      this._namedFlows.set(this.kDefaultFlowName, this._currentFlow);\n    }\n\n    if (flowName === this._currentFlow.name) {\n      return;\n    }\n\n    let flow: Flow;\n    let content = tryGetValueFromMap(this._namedFlows, flowName, null);\n    if (content.exists) {\n      flow = content.result!;\n    } else {\n      flow = new Flow(flowName, this.story);\n      this._namedFlows.set(flowName, flow);\n      this._aliveFlowNamesDirty = true;\n    }\n\n    this._currentFlow = flow;\n    this.variablesState.callStack = this._currentFlow.callStack;\n\n    this.OutputStreamDirty();\n  }\n\n  public SwitchToDefaultFlow_Internal() {\n    if (this._namedFlows === null) return;\n    this.SwitchFlow_Internal(this.kDefaultFlowName);\n  }\n\n  public RemoveFlow_Internal(flowName: string | null) {\n    if (flowName === null)\n      throw new Error(\"Must pass a non-null string to Story.DestroyFlow\");\n    if (flowName === this.kDefaultFlowName)\n      throw new Error(\"Cannot destroy default flow\");\n\n    if (this._currentFlow.name === flowName) {\n      this.SwitchToDefaultFlow_Internal();\n    }\n\n    if (this._namedFlows === null)\n      return throwNullException(\"this._namedFlows\");\n    this._namedFlows.delete(flowName);\n    this._aliveFlowNamesDirty = true;\n  }\n\n  public CopyAndStartPatching() {\n    let copy = new StoryState(this.story);\n\n    copy._patch = new StatePatch(this._patch);\n\n    copy._currentFlow.name = this._currentFlow.name;\n    copy._currentFlow.callStack = new CallStack(this._currentFlow.callStack);\n    copy._currentFlow.currentChoices.push(...this._currentFlow.currentChoices);\n    copy._currentFlow.outputStream.push(...this._currentFlow.outputStream);\n    copy.OutputStreamDirty();\n\n    if (this._namedFlows !== null) {\n      copy._namedFlows = new Map();\n      for (let [namedFlowKey, namedFlowValue] of this._namedFlows) {\n        copy._namedFlows.set(namedFlowKey, namedFlowValue);\n        copy._aliveFlowNamesDirty = true;\n      }\n      copy._namedFlows.set(this._currentFlow.name, copy._currentFlow);\n    }\n\n    if (this.hasError) {\n      copy._currentErrors = [];\n      copy._currentErrors.push(...(this.currentErrors || []));\n    }\n\n    if (this.hasWarning) {\n      copy._currentWarnings = [];\n      copy._currentWarnings.push(...(this.currentWarnings || []));\n    }\n\n    copy.variablesState = this.variablesState;\n    copy.variablesState.callStack = copy.callStack;\n    copy.variablesState.patch = copy._patch;\n\n    copy.evaluationStack.push(...this.evaluationStack);\n\n    if (!this.divertedPointer.isNull)\n      copy.divertedPointer = this.divertedPointer.copy();\n\n    copy.previousPointer = this.previousPointer.copy();\n\n    copy._visitCounts = this._visitCounts;\n    copy._turnIndices = this._turnIndices;\n\n    copy.currentTurnIndex = this.currentTurnIndex;\n    copy.storySeed = this.storySeed;\n    copy.previousRandom = this.previousRandom;\n\n    copy.didSafeExit = this.didSafeExit;\n\n    return copy;\n  }\n\n  public RestoreAfterPatch() {\n    this.variablesState.callStack = this.callStack;\n    this.variablesState.patch = this._patch;\n  }\n\n  public ApplyAnyPatch() {\n    if (this._patch === null) return;\n\n    this.variablesState.ApplyPatch();\n\n    for (let [key, value] of this._patch.visitCounts)\n      this.ApplyCountChanges(key, value, true);\n\n    for (let [key, value] of this._patch.turnIndices)\n      this.ApplyCountChanges(key, value, false);\n\n    this._patch = null;\n  }\n\n  public ApplyCountChanges(\n    container: Container,\n    newCount: number,\n    isVisit: boolean\n  ) {\n    let counts = isVisit ? this._visitCounts : this._turnIndices;\n    counts.set(container.path.toString(), newCount);\n  }\n\n  public WriteJson(writer: SimpleJson.Writer) {\n    writer.WriteObjectStart();\n\n    writer.WritePropertyStart(\"flows\");\n    writer.WriteObjectStart();\n\n    // NOTE: Never pass `WriteJson` directly as an argument to `WriteProperty`.\n    // Call it inside a function to make sure `this` is correctly bound\n    // and passed down the call hierarchy.\n\n    if (this._namedFlows !== null) {\n      for (let [namedFlowKey, namedFlowValue] of this._namedFlows) {\n        writer.WriteProperty(namedFlowKey, (w) => namedFlowValue.WriteJson(w));\n      }\n    } else {\n      writer.WriteProperty(this._currentFlow.name, (w) =>\n        this._currentFlow.WriteJson(w)\n      );\n    }\n\n    writer.WriteObjectEnd();\n    writer.WritePropertyEnd();\n\n    writer.WriteProperty(\"currentFlowName\", this._currentFlow.name);\n\n    writer.WriteProperty(\"variablesState\", (w) =>\n      this.variablesState.WriteJson(w)\n    );\n\n    writer.WriteProperty(\"evalStack\", (w) =>\n      JsonSerialisation.WriteListRuntimeObjs(w, this.evaluationStack)\n    );\n\n    if (!this.divertedPointer.isNull) {\n      if (this.divertedPointer.path === null) {\n        return throwNullException(\"divertedPointer\");\n      }\n      writer.WriteProperty(\n        \"currentDivertTarget\",\n        this.divertedPointer.path.componentsString\n      );\n    }\n\n    writer.WriteProperty(\"visitCounts\", (w) =>\n      JsonSerialisation.WriteIntDictionary(w, this._visitCounts)\n    );\n    writer.WriteProperty(\"turnIndices\", (w) =>\n      JsonSerialisation.WriteIntDictionary(w, this._turnIndices)\n    );\n\n    writer.WriteIntProperty(\"turnIdx\", this.currentTurnIndex);\n    writer.WriteIntProperty(\"storySeed\", this.storySeed);\n    writer.WriteIntProperty(\"previousRandom\", this.previousRandom);\n\n    writer.WriteIntProperty(\"inkSaveVersion\", this.kInkSaveStateVersion);\n\n    writer.WriteIntProperty(\"inkFormatVersion\", Story.inkVersionCurrent);\n\n    writer.WriteObjectEnd();\n  }\n\n  public LoadJsonObj(value: Record<string, any>) {\n    let jObject = value;\n\n    let jSaveVersion = jObject[\"inkSaveVersion\"];\n    if (jSaveVersion == null) {\n      throw new Error(\"ink save format incorrect, can't load.\");\n    } else if (parseInt(jSaveVersion) < this.kMinCompatibleLoadVersion) {\n      throw new Error(\n        \"Ink save format isn't compatible with the current version (saw '\" +\n          jSaveVersion +\n          \"', but minimum is \" +\n          this.kMinCompatibleLoadVersion +\n          \"), so can't load.\"\n      );\n    }\n\n    let flowsObj = jObject[\"flows\"];\n    if (flowsObj != null) {\n      let flowsObjDict = flowsObj as Record<string, any>;\n\n      // Single default flow\n      if (Object.keys(flowsObjDict).length === 1) {\n        this._namedFlows = null;\n      } else if (this._namedFlows === null) {\n        this._namedFlows = new Map();\n      } else {\n        this._namedFlows.clear();\n      }\n\n      let flowsObjDictEntries = Object.entries(flowsObjDict);\n      for (let [namedFlowObjKey, namedFlowObjValue] of flowsObjDictEntries) {\n        let name = namedFlowObjKey;\n        let flowObj = namedFlowObjValue as Record<string, any>;\n\n        let flow = new Flow(name, this.story, flowObj);\n\n        if (Object.keys(flowsObjDict).length === 1) {\n          this._currentFlow = new Flow(name, this.story, flowObj);\n        } else {\n          if (this._namedFlows === null)\n            return throwNullException(\"this._namedFlows\");\n          this._namedFlows.set(name, flow);\n        }\n      }\n\n      if (this._namedFlows != null && this._namedFlows.size > 1) {\n        let currFlowName = jObject[\"currentFlowName\"] as string;\n        // Adding a bang at the end, because we're trusting the save, as\n        // done in upstream.  If the save is corrupted, the execution\n        // is undefined.\n        this._currentFlow = this._namedFlows.get(currFlowName)!;\n      }\n    } else {\n      this._namedFlows = null;\n      this._currentFlow.name = this.kDefaultFlowName;\n      this._currentFlow.callStack.SetJsonToken(\n        jObject[\"callstackThreads\"] as Record<string, any>,\n        this.story\n      );\n      this._currentFlow.outputStream = JsonSerialisation.JArrayToRuntimeObjList(\n        jObject[\"outputStream\"] as any[]\n      );\n      this._currentFlow.currentChoices =\n        JsonSerialisation.JArrayToRuntimeObjList(\n          jObject[\"currentChoices\"] as any[]\n        ) as Choice[];\n\n      let jChoiceThreadsObj = jObject[\"choiceThreads\"];\n      this._currentFlow.LoadFlowChoiceThreads(jChoiceThreadsObj, this.story);\n    }\n\n    this.OutputStreamDirty();\n    this._aliveFlowNamesDirty = true;\n\n    this.variablesState.SetJsonToken(jObject[\"variablesState\"]);\n    this.variablesState.callStack = this._currentFlow.callStack;\n\n    this._evaluationStack = JsonSerialisation.JArrayToRuntimeObjList(\n      jObject[\"evalStack\"]\n    );\n\n    let currentDivertTargetPath = jObject[\"currentDivertTarget\"];\n    if (currentDivertTargetPath != null) {\n      let divertPath = new Path(currentDivertTargetPath.toString());\n      this.divertedPointer = this.story.PointerAtPath(divertPath);\n    }\n\n    this._visitCounts = JsonSerialisation.JObjectToIntDictionary(\n      jObject[\"visitCounts\"]\n    );\n    this._turnIndices = JsonSerialisation.JObjectToIntDictionary(\n      jObject[\"turnIndices\"]\n    );\n    this.currentTurnIndex = parseInt(jObject[\"turnIdx\"]);\n    this.storySeed = parseInt(jObject[\"storySeed\"]);\n    this.previousRandom = parseInt(jObject[\"previousRandom\"]);\n  }\n\n  public ResetErrors() {\n    this._currentErrors = null;\n    this._currentWarnings = null;\n  }\n  public ResetOutput(objs: InkObject[] | null = null) {\n    this.outputStream.length = 0;\n    if (objs !== null) this.outputStream.push(...objs);\n    this.OutputStreamDirty();\n  }\n\n  public PushToOutputStream(obj: InkObject | null) {\n    // var text = obj as StringValue;\n    let text = asOrNull(obj, StringValue);\n    if (text !== null) {\n      let listText = this.TrySplittingHeadTailWhitespace(text);\n      if (listText !== null) {\n        for (let textObj of listText) {\n          this.PushToOutputStreamIndividual(textObj);\n        }\n        this.OutputStreamDirty();\n        return;\n      }\n    }\n\n    this.PushToOutputStreamIndividual(obj);\n    this.OutputStreamDirty();\n  }\n\n  public PopFromOutputStream(count: number) {\n    this.outputStream.splice(this.outputStream.length - count, count);\n    this.OutputStreamDirty();\n  }\n\n  public TrySplittingHeadTailWhitespace(single: StringValue) {\n    let str = single.value;\n    if (str === null) {\n      return throwNullException(\"single.value\");\n    }\n\n    let headFirstNewlineIdx = -1;\n    let headLastNewlineIdx = -1;\n    for (let i = 0; i < str.length; i++) {\n      let c = str[i];\n      if (c == \"\\n\") {\n        if (headFirstNewlineIdx == -1) headFirstNewlineIdx = i;\n        headLastNewlineIdx = i;\n      } else if (c == \" \" || c == \"\\t\") continue;\n      else break;\n    }\n\n    let tailLastNewlineIdx = -1;\n    let tailFirstNewlineIdx = -1;\n    for (let i = str.length - 1; i >= 0; i--) {\n      let c = str[i];\n      if (c == \"\\n\") {\n        if (tailLastNewlineIdx == -1) tailLastNewlineIdx = i;\n        tailFirstNewlineIdx = i;\n      } else if (c == \" \" || c == \"\\t\") continue;\n      else break;\n    }\n\n    // No splitting to be done?\n    if (headFirstNewlineIdx == -1 && tailLastNewlineIdx == -1) return null;\n\n    let listTexts: StringValue[] = [];\n    let innerStrStart = 0;\n    let innerStrEnd = str.length;\n\n    if (headFirstNewlineIdx != -1) {\n      if (headFirstNewlineIdx > 0) {\n        let leadingSpaces = new StringValue(\n          str.substring(0, headFirstNewlineIdx)\n        );\n        listTexts.push(leadingSpaces);\n      }\n      listTexts.push(new StringValue(\"\\n\"));\n      innerStrStart = headLastNewlineIdx + 1;\n    }\n\n    if (tailLastNewlineIdx != -1) {\n      innerStrEnd = tailFirstNewlineIdx;\n    }\n\n    if (innerStrEnd > innerStrStart) {\n      let innerStrText = str.substring(innerStrStart, innerStrEnd);\n      listTexts.push(new StringValue(innerStrText));\n    }\n\n    if (tailLastNewlineIdx != -1 && tailFirstNewlineIdx > headLastNewlineIdx) {\n      listTexts.push(new StringValue(\"\\n\"));\n      if (tailLastNewlineIdx < str.length - 1) {\n        let numSpaces = str.length - tailLastNewlineIdx - 1;\n        let trailingSpaces = new StringValue(\n          str.substring(\n            tailLastNewlineIdx + 1,\n            tailLastNewlineIdx + 1 + numSpaces\n          )\n        );\n        listTexts.push(trailingSpaces);\n      }\n    }\n\n    return listTexts;\n  }\n\n  public PushToOutputStreamIndividual(obj: InkObject | null) {\n    let glue = asOrNull(obj, Glue);\n    let text = asOrNull(obj, StringValue);\n\n    let includeInOutput = true;\n\n    if (glue) {\n      this.TrimNewlinesFromOutputStream();\n      includeInOutput = true;\n    } else if (text) {\n      let functionTrimIndex = -1;\n      let currEl = this.callStack.currentElement;\n      if (currEl.type == PushPopType.Function) {\n        functionTrimIndex = currEl.functionStartInOutputStream;\n      }\n\n      let glueTrimIndex = -1;\n      for (let i = this.outputStream.length - 1; i >= 0; i--) {\n        let o = this.outputStream[i];\n        let c = o instanceof ControlCommand ? o : null;\n        let g = o instanceof Glue ? o : null;\n\n        if (g != null) {\n          glueTrimIndex = i;\n          break;\n        } else if (\n          c != null &&\n          c.commandType == ControlCommand.CommandType.BeginString\n        ) {\n          if (i >= functionTrimIndex) {\n            functionTrimIndex = -1;\n          }\n          break;\n        }\n      }\n\n      let trimIndex = -1;\n      if (glueTrimIndex != -1 && functionTrimIndex != -1)\n        trimIndex = Math.min(functionTrimIndex, glueTrimIndex);\n      else if (glueTrimIndex != -1) trimIndex = glueTrimIndex;\n      else trimIndex = functionTrimIndex;\n\n      if (trimIndex != -1) {\n        if (text.isNewline) {\n          includeInOutput = false;\n        } else if (text.isNonWhitespace) {\n          if (glueTrimIndex > -1) this.RemoveExistingGlue();\n\n          if (functionTrimIndex > -1) {\n            let callStackElements = this.callStack.elements;\n            for (let i = callStackElements.length - 1; i >= 0; i--) {\n              let el = callStackElements[i];\n              if (el.type == PushPopType.Function) {\n                el.functionStartInOutputStream = -1;\n              } else {\n                break;\n              }\n            }\n          }\n        }\n      } else if (text.isNewline) {\n        if (this.outputStreamEndsInNewline || !this.outputStreamContainsContent)\n          includeInOutput = false;\n      }\n    }\n\n    if (includeInOutput) {\n      if (obj === null) {\n        return throwNullException(\"obj\");\n      }\n      this.outputStream.push(obj);\n      this.OutputStreamDirty();\n    }\n  }\n\n  public TrimNewlinesFromOutputStream() {\n    let removeWhitespaceFrom = -1;\n\n    let i = this.outputStream.length - 1;\n    while (i >= 0) {\n      let obj = this.outputStream[i];\n      let cmd = asOrNull(obj, ControlCommand);\n      let txt = asOrNull(obj, StringValue);\n\n      if (cmd != null || (txt != null && txt.isNonWhitespace)) {\n        break;\n      } else if (txt != null && txt.isNewline) {\n        removeWhitespaceFrom = i;\n      }\n      i--;\n    }\n\n    // Remove the whitespace\n    if (removeWhitespaceFrom >= 0) {\n      i = removeWhitespaceFrom;\n      while (i < this.outputStream.length) {\n        let text = asOrNull(this.outputStream[i], StringValue);\n        if (text) {\n          this.outputStream.splice(i, 1);\n        } else {\n          i++;\n        }\n      }\n    }\n\n    this.OutputStreamDirty();\n  }\n\n  public RemoveExistingGlue() {\n    for (let i = this.outputStream.length - 1; i >= 0; i--) {\n      let c = this.outputStream[i];\n      if (c instanceof Glue) {\n        this.outputStream.splice(i, 1);\n      } else if (c instanceof ControlCommand) {\n        break;\n      }\n    }\n\n    this.OutputStreamDirty();\n  }\n\n  get outputStreamEndsInNewline() {\n    if (this.outputStream.length > 0) {\n      for (let i = this.outputStream.length - 1; i >= 0; i--) {\n        let obj = this.outputStream[i];\n        if (obj instanceof ControlCommand) break;\n        let text = this.outputStream[i];\n        if (text instanceof StringValue) {\n          if (text.isNewline) return true;\n          else if (text.isNonWhitespace) break;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  get outputStreamContainsContent() {\n    for (let content of this.outputStream) {\n      if (content instanceof StringValue) return true;\n    }\n    return false;\n  }\n\n  get inStringEvaluation() {\n    for (let i = this.outputStream.length - 1; i >= 0; i--) {\n      let cmd = asOrNull(this.outputStream[i], ControlCommand);\n      if (\n        cmd instanceof ControlCommand &&\n        cmd.commandType == ControlCommand.CommandType.BeginString\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  public PushEvaluationStack(obj: InkObject | null) {\n    // var listValue = obj as ListValue;\n    let listValue = asOrNull(obj, ListValue);\n    if (listValue) {\n      // Update origin when list is has something to indicate the list origin\n      let rawList = listValue.value;\n      if (rawList === null) {\n        return throwNullException(\"rawList\");\n      }\n\n      if (rawList.originNames != null) {\n        if (!rawList.origins) rawList.origins = [];\n        rawList.origins.length = 0;\n\n        for (let n of rawList.originNames) {\n          if (this.story.listDefinitions === null)\n            return throwNullException(\"StoryState.story.listDefinitions\");\n          let def = this.story.listDefinitions.TryListGetDefinition(n, null);\n          if (def.result === null)\n            return throwNullException(\"StoryState def.result\");\n          if (rawList.origins.indexOf(def.result) < 0)\n            rawList.origins.push(def.result);\n        }\n      }\n    }\n\n    if (obj === null) {\n      return throwNullException(\"obj\");\n    }\n    this.evaluationStack.push(obj);\n  }\n\n  public PopEvaluationStack(): InkObject;\n  public PopEvaluationStack(numberOfObjects: number): InkObject[];\n  public PopEvaluationStack(numberOfObjects?: number) {\n    if (typeof numberOfObjects === \"undefined\") {\n      let obj = this.evaluationStack.pop();\n      return nullIfUndefined(obj);\n    } else {\n      if (numberOfObjects > this.evaluationStack.length) {\n        throw new Error(\"trying to pop too many objects\");\n      }\n\n      let popped = this.evaluationStack.splice(\n        this.evaluationStack.length - numberOfObjects,\n        numberOfObjects\n      );\n      return nullIfUndefined(popped);\n    }\n  }\n\n  public PeekEvaluationStack() {\n    return this.evaluationStack[this.evaluationStack.length - 1];\n  }\n\n  public ForceEnd() {\n    this.callStack.Reset();\n\n    this._currentFlow.currentChoices.length = 0;\n\n    this.currentPointer = Pointer.Null;\n    this.previousPointer = Pointer.Null;\n\n    this.didSafeExit = true;\n  }\n\n  public TrimWhitespaceFromFunctionEnd() {\n    Debug.Assert(this.callStack.currentElement.type == PushPopType.Function);\n    let functionStartPoint =\n      this.callStack.currentElement.functionStartInOutputStream;\n\n    if (functionStartPoint == -1) {\n      functionStartPoint = 0;\n    }\n\n    for (let i = this.outputStream.length - 1; i >= functionStartPoint; i--) {\n      let obj = this.outputStream[i];\n      let txt = asOrNull(obj, StringValue);\n      let cmd = asOrNull(obj, ControlCommand);\n\n      if (txt == null) continue;\n      if (cmd) break;\n\n      if (txt.isNewline || txt.isInlineWhitespace) {\n        this.outputStream.splice(i, 1);\n        this.OutputStreamDirty();\n      } else {\n        break;\n      }\n    }\n  }\n\n  public PopCallStack(popType: PushPopType | null = null) {\n    if (this.callStack.currentElement.type == PushPopType.Function)\n      this.TrimWhitespaceFromFunctionEnd();\n\n    this.callStack.Pop(popType);\n  }\n\n  public SetChosenPath(path: Path, incrementingTurnIndex: boolean) {\n    // Changing direction, assume we need to clear current set of choices\n    this._currentFlow.currentChoices.length = 0;\n\n    let newPointer = this.story.PointerAtPath(path);\n    if (!newPointer.isNull && newPointer.index == -1) newPointer.index = 0;\n\n    this.currentPointer = newPointer;\n\n    if (incrementingTurnIndex) {\n      this.currentTurnIndex++;\n    }\n  }\n\n  public StartFunctionEvaluationFromGame(\n    funcContainer: Container,\n    args: any[]\n  ) {\n    this.callStack.Push(\n      PushPopType.FunctionEvaluationFromGame,\n      this.evaluationStack.length\n    );\n    this.callStack.currentElement.currentPointer =\n      Pointer.StartOf(funcContainer);\n\n    this.PassArgumentsToEvaluationStack(args);\n  }\n\n  public PassArgumentsToEvaluationStack(args: any[] | null) {\n    if (args !== null) {\n      for (let i = 0; i < args.length; i++) {\n        if (\n          !(\n            typeof args[i] === \"number\" ||\n            typeof args[i] === \"string\" ||\n            typeof args[i] === \"boolean\" ||\n            args[i] instanceof InkList\n          )\n        ) {\n          throw new Error(\n            \"ink arguments when calling EvaluateFunction / ChoosePathStringWithParameters must be\" +\n            \"number, string, bool or InkList. Argument was \" +\n            (nullIfUndefined(arguments[i]) === null)\n              ? \"null\"\n              : arguments[i].constructor.name\n          );\n        }\n\n        this.PushEvaluationStack(Value.Create(args[i]));\n      }\n    }\n  }\n\n  public TryExitFunctionEvaluationFromGame() {\n    if (\n      this.callStack.currentElement.type ==\n      PushPopType.FunctionEvaluationFromGame\n    ) {\n      this.currentPointer = Pointer.Null;\n      this.didSafeExit = true;\n      return true;\n    }\n\n    return false;\n  }\n\n  public CompleteFunctionEvaluationFromGame() {\n    if (\n      this.callStack.currentElement.type !=\n      PushPopType.FunctionEvaluationFromGame\n    ) {\n      throw new Error(\n        \"Expected external function evaluation to be complete. Stack trace: \" +\n          this.callStack.callStackTrace\n      );\n    }\n\n    let originalEvaluationStackHeight =\n      this.callStack.currentElement.evaluationStackHeightWhenPushed;\n\n    let returnedObj: InkObject | null = null;\n    while (this.evaluationStack.length > originalEvaluationStackHeight) {\n      let poppedObj = this.PopEvaluationStack();\n      if (returnedObj === null) returnedObj = poppedObj;\n    }\n\n    this.PopCallStack(PushPopType.FunctionEvaluationFromGame);\n\n    if (returnedObj) {\n      if (returnedObj instanceof Void) return null;\n\n      // Some kind of value, if not void\n      // var returnVal = returnedObj as Runtime.Value;\n      let returnVal = asOrThrows(returnedObj, Value);\n\n      // DivertTargets get returned as the string of components\n      // (rather than a Path, which isn't public)\n      if (returnVal.valueType == ValueType.DivertTarget) {\n        return returnVal.valueObject.toString();\n      }\n\n      // Other types can just have their exact object type:\n      // int, float, string. VariablePointers get returned as strings.\n      return returnVal.valueObject;\n    }\n\n    return null;\n  }\n\n  public AddError(message: string, isWarning: boolean) {\n    if (!isWarning) {\n      if (this._currentErrors == null) this._currentErrors = [];\n      this._currentErrors.push(message);\n    } else {\n      if (this._currentWarnings == null) this._currentWarnings = [];\n      this._currentWarnings.push(message);\n    }\n  }\n\n  public OutputStreamDirty() {\n    this._outputStreamTextDirty = true;\n    this._outputStreamTagsDirty = true;\n  }\n\n  private _visitCounts: Map<string, number>;\n  private _turnIndices: Map<string, number>;\n\n  private _outputStreamTextDirty = true;\n  private _outputStreamTagsDirty = true;\n\n  private _patch: StatePatch | null = null;\n\n  private _currentFlow: Flow;\n  private _aliveFlowNames: string[] | null = null;\n  private _namedFlows: Map<string, Flow> | null = null;\n  private readonly kDefaultFlowName = \"DEFAULT_FLOW\";\n  private _aliveFlowNamesDirty: boolean = true;\n}\n","// This is simple replacement of the Stopwatch class from the .NET Framework.\n// The original class can count time with much more accuracy than the Javascript version.\n// It might be worth considering using `window.performance` in the browser\n// or `process.hrtime()` in node.\nexport class Stopwatch {\n  private startTime: number | undefined;\n\n  constructor() {\n    this.startTime = undefined;\n  }\n\n  get ElapsedMilliseconds(): number {\n    if (typeof this.startTime === \"undefined\") {\n      return 0;\n    }\n    return new Date().getTime() - this.startTime;\n  }\n\n  public Start() {\n    this.startTime = new Date().getTime();\n  }\n  public Stop() {\n    this.startTime = undefined;\n  }\n}\n","import { Container } from \"./Container\";\nimport { InkObject } from \"./Object\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { StoryState } from \"./StoryState\";\nimport { ControlCommand } from \"./ControlCommand\";\nimport { PushPopType } from \"./PushPop\";\nimport { ChoicePoint } from \"./ChoicePoint\";\nimport { Choice } from \"./Choice\";\nimport { Divert } from \"./Divert\";\nimport {\n  Value,\n  StringValue,\n  IntValue,\n  DivertTargetValue,\n  VariablePointerValue,\n  ListValue,\n} from \"./Value\";\nimport { Path } from \"./Path\";\nimport { Void } from \"./Void\";\nimport { Tag } from \"./Tag\";\nimport { VariableAssignment } from \"./VariableAssignment\";\nimport { VariableReference } from \"./VariableReference\";\nimport { NativeFunctionCall } from \"./NativeFunctionCall\";\nimport { StoryException } from \"./StoryException\";\nimport { PRNG } from \"./PRNG\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { ListDefinitionsOrigin } from \"./ListDefinitionsOrigin\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { Stopwatch } from \"./StopWatch\";\nimport { Pointer } from \"./Pointer\";\nimport { InkList, InkListItem, KeyValuePair } from \"./InkList\";\nimport { asOrNull, asOrThrows } from \"./TypeAssertion\";\nimport { DebugMetadata } from \"./DebugMetadata\";\nimport { throwNullException } from \"./NullException\";\nimport { SimpleJson } from \"./SimpleJson\";\nimport { ErrorHandler, ErrorType } from \"./Error\";\n\nexport { InkList } from \"./InkList\";\n\nif (!Number.isInteger) {\n  Number.isInteger = function isInteger(nVal: any) {\n    return (\n      typeof nVal === \"number\" &&\n      isFinite(nVal) &&\n      nVal > -9007199254740992 &&\n      nVal < 9007199254740992 &&\n      Math.floor(nVal) === nVal\n    );\n  };\n}\n\nexport class Story extends InkObject {\n  public static inkVersionCurrent = 21;\n\n  public inkVersionMinimumCompatible = 18;\n\n  get currentChoices() {\n    let choices: Choice[] = [];\n\n    if (this._state === null) {\n      return throwNullException(\"this._state\");\n    }\n    for (let c of this._state.currentChoices) {\n      if (!c.isInvisibleDefault) {\n        c.index = choices.length;\n        choices.push(c);\n      }\n    }\n\n    return choices;\n  }\n\n  get currentText() {\n    this.IfAsyncWeCant(\"call currentText since it's a work in progress\");\n    return this.state.currentText;\n  }\n\n  get currentTags() {\n    this.IfAsyncWeCant(\"call currentTags since it's a work in progress\");\n    return this.state.currentTags;\n  }\n\n  get currentErrors() {\n    return this.state.currentErrors;\n  }\n\n  get currentWarnings() {\n    return this.state.currentWarnings;\n  }\n\n  get currentFlowName() {\n    return this.state.currentFlowName;\n  }\n\n  get currentFlowIsDefaultFlow() {\n    return this.state.currentFlowIsDefaultFlow;\n  }\n\n  get aliveFlowNames() {\n    return this.state.aliveFlowNames;\n  }\n\n  get hasError() {\n    return this.state.hasError;\n  }\n\n  get hasWarning() {\n    return this.state.hasWarning;\n  }\n\n  get variablesState() {\n    return this.state.variablesState;\n  }\n\n  get listDefinitions() {\n    return this._listDefinitions;\n  }\n\n  get state() {\n    return this._state;\n  }\n\n  public onError: ErrorHandler | null = null;\n\n  public onDidContinue: (() => void) | null = null;\n\n  public onMakeChoice: ((arg1: Choice) => void) | null = null;\n\n  public onEvaluateFunction: ((arg1: string, arg2: any[]) => void) | null =\n    null;\n\n  public onCompleteEvaluateFunction:\n    | ((arg1: string, arg2: any[], arg3: string, arg4: any) => void)\n    | null = null;\n\n  public onChoosePathString: ((arg1: string, arg2: any[]) => void) | null =\n    null;\n\n  // TODO: Implement Profiler\n  public StartProfiling() {\n    /* */\n  }\n  public EndProfiling() {\n    /* */\n  }\n\n  constructor(contentContainer: Container, lists: ListDefinition[] | null);\n  constructor(jsonString: string);\n  constructor(json: Record<string, any>);\n  constructor() {\n    super();\n\n    // Discrimination between constructors\n    let contentContainer: Container;\n    let lists: ListDefinition[] | null = null;\n    let json: Record<string, any> | null = null;\n\n    if (arguments[0] instanceof Container) {\n      contentContainer = arguments[0] as Container;\n\n      if (typeof arguments[1] !== \"undefined\") {\n        lists = arguments[1] as ListDefinition[];\n      }\n\n      // ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)\n      this._mainContentContainer = contentContainer;\n      // ------\n    } else {\n      if (typeof arguments[0] === \"string\") {\n        let jsonString = arguments[0] as string;\n        json = SimpleJson.TextToDictionary(jsonString);\n      } else {\n        json = arguments[0] as Record<string, any>;\n      }\n    }\n\n    // ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)\n    if (lists != null) this._listDefinitions = new ListDefinitionsOrigin(lists);\n\n    this._externals = new Map();\n    // ------\n\n    // ------ Story(string jsonString) : this((Container)null)\n    if (json !== null) {\n      let rootObject: Record<string, any> = json;\n\n      let versionObj = rootObject[\"inkVersion\"];\n      if (versionObj == null)\n        throw new Error(\n          \"ink version number not found. Are you sure it's a valid .ink.json file?\"\n        );\n\n      let formatFromFile = parseInt(versionObj);\n      if (formatFromFile > Story.inkVersionCurrent) {\n        throw new Error(\n          \"Version of ink used to build story was newer than the current version of the engine\"\n        );\n      } else if (formatFromFile < this.inkVersionMinimumCompatible) {\n        throw new Error(\n          \"Version of ink used to build story is too old to be loaded by this version of the engine\"\n        );\n      } else if (formatFromFile != Story.inkVersionCurrent) {\n        console.warn(\n          \"WARNING: Version of ink used to build story doesn't match current version of engine. Non-critical, but recommend synchronising.\"\n        );\n      }\n\n      let rootToken = rootObject[\"root\"];\n      if (rootToken == null)\n        throw new Error(\n          \"Root node for ink not found. Are you sure it's a valid .ink.json file?\"\n        );\n\n      let listDefsObj;\n      if ((listDefsObj = rootObject[\"listDefs\"])) {\n        this._listDefinitions =\n          JsonSerialisation.JTokenToListDefinitions(listDefsObj);\n      }\n\n      this._mainContentContainer = asOrThrows(\n        JsonSerialisation.JTokenToRuntimeObject(rootToken),\n        Container\n      );\n\n      this.ResetState();\n    }\n    // ------\n  }\n\n  // Merge together `public string ToJson()` and `void ToJson(SimpleJson.Writer writer)`.\n  // Will only return a value if writer was not provided.\n  public ToJson(writer?: SimpleJson.Writer): string | void {\n    let shouldReturn = false;\n\n    if (!writer) {\n      shouldReturn = true;\n      writer = new SimpleJson.Writer();\n    }\n\n    writer.WriteObjectStart();\n\n    writer.WriteIntProperty(\"inkVersion\", Story.inkVersionCurrent);\n\n    writer.WriteProperty(\"root\", (w) =>\n      JsonSerialisation.WriteRuntimeContainer(w, this._mainContentContainer)\n    );\n\n    if (this._listDefinitions != null) {\n      writer.WritePropertyStart(\"listDefs\");\n      writer.WriteObjectStart();\n\n      for (let def of this._listDefinitions.lists) {\n        writer.WritePropertyStart(def.name);\n        writer.WriteObjectStart();\n\n        for (let [key, value] of def.items) {\n          let item = InkListItem.fromSerializedKey(key);\n          let val = value;\n          writer.WriteIntProperty(item.itemName, val);\n        }\n\n        writer.WriteObjectEnd();\n        writer.WritePropertyEnd();\n      }\n\n      writer.WriteObjectEnd();\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteObjectEnd();\n\n    if (shouldReturn) return writer.toString();\n  }\n\n  public ResetState() {\n    this.IfAsyncWeCant(\"ResetState\");\n\n    this._state = new StoryState(this);\n    this._state.variablesState.ObserveVariableChange(\n      this.VariableStateDidChangeEvent.bind(this)\n    );\n\n    this.ResetGlobals();\n  }\n\n  public ResetErrors() {\n    if (this._state === null) {\n      return throwNullException(\"this._state\");\n    }\n    this._state.ResetErrors();\n  }\n\n  public ResetCallstack() {\n    this.IfAsyncWeCant(\"ResetCallstack\");\n    if (this._state === null) {\n      return throwNullException(\"this._state\");\n    }\n    this._state.ForceEnd();\n  }\n\n  public ResetGlobals() {\n    if (this._mainContentContainer.namedContent.get(\"global decl\")) {\n      let originalPointer = this.state.currentPointer.copy();\n\n      this.ChoosePath(new Path(\"global decl\"), false);\n\n      this.ContinueInternal();\n\n      this.state.currentPointer = originalPointer;\n    }\n\n    this.state.variablesState.SnapshotDefaultGlobals();\n  }\n\n  public SwitchFlow(flowName: string) {\n    this.IfAsyncWeCant(\"switch flow\");\n    if (this._asyncSaving) {\n      throw new Error(\n        \"Story is already in background saving mode, can't switch flow to \" +\n          flowName\n      );\n    }\n\n    this.state.SwitchFlow_Internal(flowName);\n  }\n\n  public RemoveFlow(flowName: string) {\n    this.state.RemoveFlow_Internal(flowName);\n  }\n\n  public SwitchToDefaultFlow() {\n    this.state.SwitchToDefaultFlow_Internal();\n  }\n\n  public Continue() {\n    this.ContinueAsync(0);\n    return this.currentText;\n  }\n\n  get canContinue() {\n    return this.state.canContinue;\n  }\n\n  get asyncContinueComplete() {\n    return !this._asyncContinueActive;\n  }\n\n  public ContinueAsync(millisecsLimitAsync: number) {\n    if (!this._hasValidatedExternals) this.ValidateExternalBindings();\n\n    this.ContinueInternal(millisecsLimitAsync);\n  }\n\n  public ContinueInternal(millisecsLimitAsync = 0) {\n    if (this._profiler != null) this._profiler.PreContinue();\n\n    let isAsyncTimeLimited = millisecsLimitAsync > 0;\n    this._recursiveContinueCount++;\n\n    if (!this._asyncContinueActive) {\n      this._asyncContinueActive = isAsyncTimeLimited;\n\n      if (!this.canContinue) {\n        throw new Error(\n          \"Can't continue - should check canContinue before calling Continue\"\n        );\n      }\n\n      this._state.didSafeExit = false;\n      this._state.ResetOutput();\n\n      if (this._recursiveContinueCount == 1)\n        this._state.variablesState.batchObservingVariableChanges = true;\n    }\n\n    let durationStopwatch = new Stopwatch();\n    durationStopwatch.Start();\n\n    let outputStreamEndsInNewline = false;\n    this._sawLookaheadUnsafeFunctionAfterNewline = false;\n    do {\n      try {\n        outputStreamEndsInNewline = this.ContinueSingleStep();\n      } catch (e) {\n        if (!(e instanceof StoryException)) throw e;\n\n        this.AddError(e.message, undefined, e.useEndLineNumber);\n        break;\n      }\n\n      if (outputStreamEndsInNewline) break;\n\n      if (\n        this._asyncContinueActive &&\n        durationStopwatch.ElapsedMilliseconds > millisecsLimitAsync\n      ) {\n        break;\n      }\n    } while (this.canContinue);\n\n    durationStopwatch.Stop();\n\n    if (outputStreamEndsInNewline || !this.canContinue) {\n      if (this._stateSnapshotAtLastNewline !== null) {\n        this.RestoreStateSnapshot();\n      }\n\n      if (!this.canContinue) {\n        if (this.state.callStack.canPopThread)\n          this.AddError(\n            \"Thread available to pop, threads should always be flat by the end of evaluation?\"\n          );\n\n        if (\n          this.state.generatedChoices.length == 0 &&\n          !this.state.didSafeExit &&\n          this._temporaryEvaluationContainer == null\n        ) {\n          if (this.state.callStack.CanPop(PushPopType.Tunnel))\n            this.AddError(\n              \"unexpectedly reached end of content. Do you need a '->->' to return from a tunnel?\"\n            );\n          else if (this.state.callStack.CanPop(PushPopType.Function))\n            this.AddError(\n              \"unexpectedly reached end of content. Do you need a '~ return'?\"\n            );\n          else if (!this.state.callStack.canPop)\n            this.AddError(\n              \"ran out of content. Do you need a '-> DONE' or '-> END'?\"\n            );\n          else\n            this.AddError(\n              \"unexpectedly reached end of content for unknown reason. Please debug compiler!\"\n            );\n        }\n      }\n\n      this.state.didSafeExit = false;\n      this._sawLookaheadUnsafeFunctionAfterNewline = false;\n\n      if (this._recursiveContinueCount == 1)\n        this._state.variablesState.batchObservingVariableChanges = false;\n\n      this._asyncContinueActive = false;\n      if (this.onDidContinue !== null) this.onDidContinue();\n    }\n\n    this._recursiveContinueCount--;\n\n    if (this._profiler != null) this._profiler.PostContinue();\n\n    // In the following code, we're masking a lot of non-null assertion,\n    // because testing for against `hasError` or `hasWarning` makes sure\n    // the arrays are present and contain at least one element.\n    if (this.state.hasError || this.state.hasWarning) {\n      if (this.onError !== null) {\n        if (this.state.hasError) {\n          for (let err of this.state.currentErrors!) {\n            this.onError(err, ErrorType.Error);\n          }\n        }\n        if (this.state.hasWarning) {\n          for (let err of this.state.currentWarnings!) {\n            this.onError(err, ErrorType.Warning);\n          }\n        }\n        this.ResetErrors();\n      } else {\n        let sb = new StringBuilder();\n        sb.Append(\"Ink had \");\n        if (this.state.hasError) {\n          sb.Append(`${this.state.currentErrors!.length}`);\n          sb.Append(\n            this.state.currentErrors!.length == 1 ? \" error\" : \"errors\"\n          );\n          if (this.state.hasWarning) sb.Append(\" and \");\n        }\n        if (this.state.hasWarning) {\n          sb.Append(`${this.state.currentWarnings!.length}`);\n          sb.Append(\n            this.state.currentWarnings!.length == 1 ? \" warning\" : \"warnings\"\n          );\n          if (this.state.hasWarning) sb.Append(\" and \");\n        }\n        sb.Append(\n          \". It is strongly suggested that you assign an error handler to story.onError. The first issue was: \"\n        );\n        sb.Append(\n          this.state.hasError\n            ? this.state.currentErrors![0]\n            : this.state.currentWarnings![0]\n        );\n\n        throw new StoryException(sb.toString());\n      }\n    }\n  }\n\n  public ContinueSingleStep() {\n    if (this._profiler != null) this._profiler.PreStep();\n\n    this.Step();\n\n    if (this._profiler != null) this._profiler.PostStep();\n\n    if (!this.canContinue && !this.state.callStack.elementIsEvaluateFromGame) {\n      this.TryFollowDefaultInvisibleChoice();\n    }\n\n    if (this._profiler != null) this._profiler.PreSnapshot();\n\n    if (!this.state.inStringEvaluation) {\n      if (this._stateSnapshotAtLastNewline !== null) {\n        if (this._stateSnapshotAtLastNewline.currentTags === null) {\n          return throwNullException(\"this._stateAtLastNewline.currentTags\");\n        }\n        if (this.state.currentTags === null) {\n          return throwNullException(\"this.state.currentTags\");\n        }\n\n        let change = this.CalculateNewlineOutputStateChange(\n          this._stateSnapshotAtLastNewline.currentText,\n          this.state.currentText,\n          this._stateSnapshotAtLastNewline.currentTags.length,\n          this.state.currentTags.length\n        );\n\n        if (\n          change == Story.OutputStateChange.ExtendedBeyondNewline ||\n          this._sawLookaheadUnsafeFunctionAfterNewline\n        ) {\n          this.RestoreStateSnapshot();\n\n          return true;\n        } else if (change == Story.OutputStateChange.NewlineRemoved) {\n          this.DiscardSnapshot();\n        }\n      }\n\n      if (this.state.outputStreamEndsInNewline) {\n        if (this.canContinue) {\n          if (this._stateSnapshotAtLastNewline == null) this.StateSnapshot();\n        } else {\n          this.DiscardSnapshot();\n        }\n      }\n    }\n\n    if (this._profiler != null) this._profiler.PostSnapshot();\n\n    return false;\n  }\n\n  public CalculateNewlineOutputStateChange(\n    prevText: string | null,\n    currText: string | null,\n    prevTagCount: number,\n    currTagCount: number\n  ) {\n    if (prevText === null) {\n      return throwNullException(\"prevText\");\n    }\n    if (currText === null) {\n      return throwNullException(\"currText\");\n    }\n\n    let newlineStillExists =\n      currText.length >= prevText.length &&\n      prevText.length > 0 &&\n      currText.charAt(prevText.length - 1) == \"\\n\";\n    if (\n      prevTagCount == currTagCount &&\n      prevText.length == currText.length &&\n      newlineStillExists\n    )\n      return Story.OutputStateChange.NoChange;\n\n    if (!newlineStillExists) {\n      return Story.OutputStateChange.NewlineRemoved;\n    }\n\n    if (currTagCount > prevTagCount)\n      return Story.OutputStateChange.ExtendedBeyondNewline;\n\n    for (let i = prevText.length; i < currText.length; i++) {\n      let c = currText.charAt(i);\n      if (c != \" \" && c != \"\\t\") {\n        return Story.OutputStateChange.ExtendedBeyondNewline;\n      }\n    }\n\n    return Story.OutputStateChange.NoChange;\n  }\n\n  public ContinueMaximally() {\n    this.IfAsyncWeCant(\"ContinueMaximally\");\n\n    let sb = new StringBuilder();\n\n    while (this.canContinue) {\n      sb.Append(this.Continue());\n    }\n\n    return sb.toString();\n  }\n\n  public ContentAtPath(path: Path) {\n    return this.mainContentContainer.ContentAtPath(path);\n  }\n\n  public KnotContainerWithName(name: string) {\n    let namedContainer = this.mainContentContainer.namedContent.get(name);\n    if (namedContainer instanceof Container) return namedContainer;\n    else return null;\n  }\n\n  public PointerAtPath(path: Path) {\n    if (path.length == 0) return Pointer.Null;\n\n    let p = new Pointer();\n\n    let pathLengthToUse = path.length;\n\n    let result = null;\n    if (path.lastComponent === null) {\n      return throwNullException(\"path.lastComponent\");\n    }\n\n    if (path.lastComponent.isIndex) {\n      pathLengthToUse = path.length - 1;\n      result = this.mainContentContainer.ContentAtPath(\n        path,\n        undefined,\n        pathLengthToUse\n      );\n      p.container = result.container;\n      p.index = path.lastComponent.index;\n    } else {\n      result = this.mainContentContainer.ContentAtPath(path);\n      p.container = result.container;\n      p.index = -1;\n    }\n\n    if (\n      result.obj == null ||\n      (result.obj == this.mainContentContainer && pathLengthToUse > 0)\n    ) {\n      this.Error(\n        \"Failed to find content at path '\" +\n          path +\n          \"', and no approximation of it was possible.\"\n      );\n    } else if (result.approximate)\n      this.Warning(\n        \"Failed to find content at path '\" +\n          path +\n          \"', so it was approximated to: '\" +\n          result.obj.path +\n          \"'.\"\n      );\n\n    return p;\n  }\n\n  public StateSnapshot() {\n    this._stateSnapshotAtLastNewline = this._state;\n    this._state = this._state.CopyAndStartPatching();\n  }\n\n  public RestoreStateSnapshot() {\n    if (this._stateSnapshotAtLastNewline === null) {\n      throwNullException(\"_stateSnapshotAtLastNewline\");\n    }\n    this._stateSnapshotAtLastNewline.RestoreAfterPatch();\n\n    this._state = this._stateSnapshotAtLastNewline;\n    this._stateSnapshotAtLastNewline = null;\n\n    if (!this._asyncSaving) {\n      this._state.ApplyAnyPatch();\n    }\n  }\n\n  public DiscardSnapshot() {\n    if (!this._asyncSaving) this._state.ApplyAnyPatch();\n\n    this._stateSnapshotAtLastNewline = null;\n  }\n\n  public CopyStateForBackgroundThreadSave() {\n    this.IfAsyncWeCant(\"start saving on a background thread\");\n\n    if (this._asyncSaving)\n      throw new Error(\n        \"Story is already in background saving mode, can't call CopyStateForBackgroundThreadSave again!\"\n      );\n\n    let stateToSave = this._state;\n    this._state = this._state.CopyAndStartPatching();\n    this._asyncSaving = true;\n    return stateToSave;\n  }\n\n  public BackgroundSaveComplete() {\n    if (this._stateSnapshotAtLastNewline === null) {\n      this._state.ApplyAnyPatch();\n    }\n\n    this._asyncSaving = false;\n  }\n\n  public Step() {\n    let shouldAddToStream = true;\n\n    let pointer = this.state.currentPointer.copy();\n    if (pointer.isNull) {\n      return;\n    }\n\n    // Container containerToEnter = pointer.Resolve () as Container;\n    let containerToEnter = asOrNull(pointer.Resolve(), Container);\n\n    while (containerToEnter) {\n      this.VisitContainer(containerToEnter, true);\n\n      // No content? the most we can do is step past it\n      if (containerToEnter.content.length == 0) {\n        break;\n      }\n\n      pointer = Pointer.StartOf(containerToEnter);\n      // containerToEnter = pointer.Resolve() as Container;\n      containerToEnter = asOrNull(pointer.Resolve(), Container);\n    }\n\n    this.state.currentPointer = pointer.copy();\n\n    if (this._profiler != null) this._profiler.Step(this.state.callStack);\n\n    // Is the current content object:\n    //  - Normal content\n    //  - Or a logic/flow statement - if so, do it\n    // Stop flow if we hit a stack pop when we're unable to pop (e.g. return/done statement in knot\n    // that was diverted to rather than called as a function)\n    let currentContentObj = pointer.Resolve();\n    let isLogicOrFlowControl =\n      this.PerformLogicAndFlowControl(currentContentObj);\n\n    // Has flow been forced to end by flow control above?\n    if (this.state.currentPointer.isNull) {\n      return;\n    }\n\n    if (isLogicOrFlowControl) {\n      shouldAddToStream = false;\n    }\n\n    // Choice with condition?\n    // var choicePoint = currentContentObj as ChoicePoint;\n    let choicePoint = asOrNull(currentContentObj, ChoicePoint);\n    if (choicePoint) {\n      let choice = this.ProcessChoice(choicePoint);\n      if (choice) {\n        this.state.generatedChoices.push(choice);\n      }\n\n      currentContentObj = null;\n      shouldAddToStream = false;\n    }\n\n    // If the container has no content, then it will be\n    // the \"content\" itself, but we skip over it.\n    if (currentContentObj instanceof Container) {\n      shouldAddToStream = false;\n    }\n\n    // Content to add to evaluation stack or the output stream\n    if (shouldAddToStream) {\n      // If we're pushing a variable pointer onto the evaluation stack, ensure that it's specific\n      // to our current (possibly temporary) context index. And make a copy of the pointer\n      // so that we're not editing the original runtime object.\n      // var varPointer = currentContentObj as VariablePointerValue;\n      let varPointer = asOrNull(currentContentObj, VariablePointerValue);\n      if (varPointer && varPointer.contextIndex == -1) {\n        // Create new object so we're not overwriting the story's own data\n        let contextIdx = this.state.callStack.ContextForVariableNamed(\n          varPointer.variableName\n        );\n        currentContentObj = new VariablePointerValue(\n          varPointer.variableName,\n          contextIdx\n        );\n      }\n\n      // Expression evaluation content\n      if (this.state.inExpressionEvaluation) {\n        this.state.PushEvaluationStack(currentContentObj);\n      }\n      // Output stream content (i.e. not expression evaluation)\n      else {\n        this.state.PushToOutputStream(currentContentObj);\n      }\n    }\n\n    // Increment the content pointer, following diverts if necessary\n    this.NextContent();\n\n    // Starting a thread should be done after the increment to the content pointer,\n    // so that when returning from the thread, it returns to the content after this instruction.\n    // var controlCmd = currentContentObj as ;\n    let controlCmd = asOrNull(currentContentObj, ControlCommand);\n    if (\n      controlCmd &&\n      controlCmd.commandType == ControlCommand.CommandType.StartThread\n    ) {\n      this.state.callStack.PushThread();\n    }\n  }\n\n  public VisitContainer(container: Container, atStart: boolean) {\n    if (!container.countingAtStartOnly || atStart) {\n      if (container.visitsShouldBeCounted)\n        this.state.IncrementVisitCountForContainer(container);\n\n      if (container.turnIndexShouldBeCounted)\n        this.state.RecordTurnIndexVisitToContainer(container);\n    }\n  }\n\n  private _prevContainers: Container[] = [];\n  public VisitChangedContainersDueToDivert() {\n    let previousPointer = this.state.previousPointer.copy();\n    let pointer = this.state.currentPointer.copy();\n\n    if (pointer.isNull || pointer.index == -1) return;\n\n    this._prevContainers.length = 0;\n    if (!previousPointer.isNull) {\n      // Container prevAncestor = previousPointer.Resolve() as Container ?? previousPointer.container as Container;\n      let resolvedPreviousAncestor = previousPointer.Resolve();\n      let prevAncestor =\n        asOrNull(resolvedPreviousAncestor, Container) ||\n        asOrNull(previousPointer.container, Container);\n      while (prevAncestor) {\n        this._prevContainers.push(prevAncestor);\n        // prevAncestor = prevAncestor.parent as Container;\n        prevAncestor = asOrNull(prevAncestor.parent, Container);\n      }\n    }\n\n    let currentChildOfContainer = pointer.Resolve();\n\n    if (currentChildOfContainer == null) return;\n\n    // Container currentContainerAncestor = currentChildOfContainer.parent as Container;\n    let currentContainerAncestor = asOrNull(\n      currentChildOfContainer.parent,\n      Container\n    );\n    let allChildrenEnteredAtStart = true;\n    while (\n      currentContainerAncestor &&\n      (this._prevContainers.indexOf(currentContainerAncestor) < 0 ||\n        currentContainerAncestor.countingAtStartOnly)\n    ) {\n      // Check whether this ancestor container is being entered at the start,\n      // by checking whether the child object is the first.\n      let enteringAtStart =\n        currentContainerAncestor.content.length > 0 &&\n        currentChildOfContainer == currentContainerAncestor.content[0] &&\n        allChildrenEnteredAtStart;\n\n      if (!enteringAtStart) allChildrenEnteredAtStart = false;\n\n      // Mark a visit to this container\n      this.VisitContainer(currentContainerAncestor, enteringAtStart);\n\n      currentChildOfContainer = currentContainerAncestor;\n      // currentContainerAncestor = currentContainerAncestor.parent as Container;\n      currentContainerAncestor = asOrNull(\n        currentContainerAncestor.parent,\n        Container\n      );\n    }\n  }\n\n  public PopChoiceStringAndTags(tags: string[]) {\n    let choiceOnlyStrVal = asOrThrows(\n      this.state.PopEvaluationStack(),\n      StringValue\n    );\n\n    while (\n      this.state.evaluationStack.length > 0 &&\n      asOrNull(this.state.PeekEvaluationStack(), Tag) != null\n    ) {\n      let tag = asOrNull(this.state.PopEvaluationStack(), Tag);\n      if (tag) tags.push(tag.text);\n    }\n    return choiceOnlyStrVal.value;\n  }\n\n  public ProcessChoice(choicePoint: ChoicePoint) {\n    let showChoice = true;\n\n    // Don't create choice if choice point doesn't pass conditional\n    if (choicePoint.hasCondition) {\n      let conditionValue = this.state.PopEvaluationStack();\n      if (!this.IsTruthy(conditionValue)) {\n        showChoice = false;\n      }\n    }\n\n    let startText = \"\";\n    let choiceOnlyText = \"\";\n    let tags: string[] = [];\n\n    if (choicePoint.hasChoiceOnlyContent) {\n      choiceOnlyText = this.PopChoiceStringAndTags(tags) || \"\";\n    }\n\n    if (choicePoint.hasStartContent) {\n      startText = this.PopChoiceStringAndTags(tags) || \"\";\n    }\n\n    // Don't create choice if player has already read this content\n    if (choicePoint.onceOnly) {\n      let visitCount = this.state.VisitCountForContainer(\n        choicePoint.choiceTarget\n      );\n      if (visitCount > 0) {\n        showChoice = false;\n      }\n    }\n\n    // We go through the full process of creating the choice above so\n    // that we consume the content for it, since otherwise it'll\n    // be shown on the output stream.\n    if (!showChoice) {\n      return null;\n    }\n\n    let choice = new Choice();\n    choice.targetPath = choicePoint.pathOnChoice;\n    choice.sourcePath = choicePoint.path.toString();\n    choice.isInvisibleDefault = choicePoint.isInvisibleDefault;\n    choice.threadAtGeneration = this.state.callStack.ForkThread();\n    choice.tags = tags.reverse(); //C# is a stack\n    choice.text = (startText + choiceOnlyText).replace(/^[ \\t]+|[ \\t]+$/g, \"\");\n\n    return choice;\n  }\n\n  public IsTruthy(obj: InkObject) {\n    let truthy = false;\n    if (obj instanceof Value) {\n      let val = obj;\n\n      if (val instanceof DivertTargetValue) {\n        let divTarget = val;\n        this.Error(\n          \"Shouldn't use a divert target (to \" +\n            divTarget.targetPath +\n            \") as a conditional value. Did you intend a function call 'likeThis()' or a read count check 'likeThis'? (no arrows)\"\n        );\n        return false;\n      }\n\n      return val.isTruthy;\n    }\n    return truthy;\n  }\n\n  public PerformLogicAndFlowControl(contentObj: InkObject | null) {\n    if (contentObj == null) {\n      return false;\n    }\n\n    // Divert\n    if (contentObj instanceof Divert) {\n      let currentDivert = contentObj;\n\n      if (currentDivert.isConditional) {\n        let conditionValue = this.state.PopEvaluationStack();\n\n        // False conditional? Cancel divert\n        if (!this.IsTruthy(conditionValue)) return true;\n      }\n\n      if (currentDivert.hasVariableTarget) {\n        let varName = currentDivert.variableDivertName;\n\n        let varContents =\n          this.state.variablesState.GetVariableWithName(varName);\n\n        if (varContents == null) {\n          this.Error(\n            \"Tried to divert using a target from a variable that could not be found (\" +\n              varName +\n              \")\"\n          );\n        } else if (!(varContents instanceof DivertTargetValue)) {\n          // var intContent = varContents as IntValue;\n          let intContent = asOrNull(varContents, IntValue);\n\n          let errorMessage =\n            \"Tried to divert to a target from a variable, but the variable (\" +\n            varName +\n            \") didn't contain a divert target, it \";\n          if (intContent instanceof IntValue && intContent.value == 0) {\n            errorMessage += \"was empty/null (the value 0).\";\n          } else {\n            errorMessage += \"contained '\" + varContents + \"'.\";\n          }\n\n          this.Error(errorMessage);\n        }\n\n        let target = asOrThrows(varContents, DivertTargetValue);\n        this.state.divertedPointer = this.PointerAtPath(target.targetPath);\n      } else if (currentDivert.isExternal) {\n        this.CallExternalFunction(\n          currentDivert.targetPathString,\n          currentDivert.externalArgs\n        );\n        return true;\n      } else {\n        this.state.divertedPointer = currentDivert.targetPointer.copy();\n      }\n\n      if (currentDivert.pushesToStack) {\n        this.state.callStack.Push(\n          currentDivert.stackPushType,\n          undefined,\n          this.state.outputStream.length\n        );\n      }\n\n      if (this.state.divertedPointer.isNull && !currentDivert.isExternal) {\n        if (\n          currentDivert &&\n          currentDivert.debugMetadata &&\n          currentDivert.debugMetadata.sourceName != null\n        ) {\n          this.Error(\n            \"Divert target doesn't exist: \" +\n              currentDivert.debugMetadata.sourceName\n          );\n        } else {\n          this.Error(\"Divert resolution failed: \" + currentDivert);\n        }\n      }\n\n      return true;\n    }\n\n    // Start/end an expression evaluation? Or print out the result?\n    else if (contentObj instanceof ControlCommand) {\n      let evalCommand = contentObj;\n\n      switch (evalCommand.commandType) {\n        case ControlCommand.CommandType.EvalStart:\n          this.Assert(\n            this.state.inExpressionEvaluation === false,\n            \"Already in expression evaluation?\"\n          );\n          this.state.inExpressionEvaluation = true;\n          break;\n\n        case ControlCommand.CommandType.EvalEnd:\n          this.Assert(\n            this.state.inExpressionEvaluation === true,\n            \"Not in expression evaluation mode\"\n          );\n          this.state.inExpressionEvaluation = false;\n          break;\n\n        case ControlCommand.CommandType.EvalOutput:\n          // If the expression turned out to be empty, there may not be anything on the stack\n          if (this.state.evaluationStack.length > 0) {\n            let output = this.state.PopEvaluationStack();\n\n            // Functions may evaluate to Void, in which case we skip output\n            if (!(output instanceof Void)) {\n              // TODO: Should we really always blanket convert to string?\n              // It would be okay to have numbers in the output stream the\n              // only problem is when exporting text for viewing, it skips over numbers etc.\n              let text = new StringValue(output.toString());\n\n              this.state.PushToOutputStream(text);\n            }\n          }\n          break;\n\n        case ControlCommand.CommandType.NoOp:\n          break;\n\n        case ControlCommand.CommandType.Duplicate:\n          this.state.PushEvaluationStack(this.state.PeekEvaluationStack());\n          break;\n\n        case ControlCommand.CommandType.PopEvaluatedValue:\n          this.state.PopEvaluationStack();\n          break;\n\n        case ControlCommand.CommandType.PopFunction:\n        case ControlCommand.CommandType.PopTunnel:\n          let popType =\n            evalCommand.commandType == ControlCommand.CommandType.PopFunction\n              ? PushPopType.Function\n              : PushPopType.Tunnel;\n\n          let overrideTunnelReturnTarget: DivertTargetValue | null = null;\n          if (popType == PushPopType.Tunnel) {\n            let popped = this.state.PopEvaluationStack();\n            // overrideTunnelReturnTarget = popped as DivertTargetValue;\n            overrideTunnelReturnTarget = asOrNull(popped, DivertTargetValue);\n            if (overrideTunnelReturnTarget === null) {\n              this.Assert(\n                popped instanceof Void,\n                \"Expected void if ->-> doesn't override target\"\n              );\n            }\n          }\n\n          if (this.state.TryExitFunctionEvaluationFromGame()) {\n            break;\n          } else if (\n            this.state.callStack.currentElement.type != popType ||\n            !this.state.callStack.canPop\n          ) {\n            let names: Map<PushPopType, string> = new Map();\n            names.set(\n              PushPopType.Function,\n              \"function return statement (~ return)\"\n            );\n            names.set(PushPopType.Tunnel, \"tunnel onwards statement (->->)\");\n\n            let expected = names.get(this.state.callStack.currentElement.type);\n            if (!this.state.callStack.canPop) {\n              expected = \"end of flow (-> END or choice)\";\n            }\n\n            let errorMsg =\n              \"Found \" + names.get(popType) + \", when expected \" + expected;\n\n            this.Error(errorMsg);\n          } else {\n            this.state.PopCallStack();\n\n            if (overrideTunnelReturnTarget)\n              this.state.divertedPointer = this.PointerAtPath(\n                overrideTunnelReturnTarget.targetPath\n              );\n          }\n          break;\n\n        case ControlCommand.CommandType.BeginString:\n          this.state.PushToOutputStream(evalCommand);\n\n          this.Assert(\n            this.state.inExpressionEvaluation === true,\n            \"Expected to be in an expression when evaluating a string\"\n          );\n          this.state.inExpressionEvaluation = false;\n          break;\n\n        // Leave it to story.currentText and story.currentTags to sort out the text from the tags\n        // This is mostly because we can't always rely on the existence of EndTag, and we don't want\n        // to try and flatten dynamic tags to strings every time \\n is pushed to output\n        case ControlCommand.CommandType.BeginTag:\n          this.state.PushToOutputStream(evalCommand);\n          break;\n\n        // EndTag has 2 modes:\n        //  - When in string evaluation (for choices)\n        //  - Normal\n        //\n        // The only way you could have an EndTag in the middle of\n        // string evaluation is if we're currently generating text for a\n        // choice, such as:\n        //\n        //   + choice # tag\n        //\n        // In the above case, the ink will be run twice:\n        //  - First, to generate the choice text. String evaluation\n        //    will be on, and the final string will be pushed to the\n        //    evaluation stack, ready to be popped to make a Choice\n        //    object.\n        //  - Second, when ink generates text after choosing the choice.\n        //    On this ocassion, it's not in string evaluation mode.\n        //\n        // On the writing side, we disallow manually putting tags within\n        // strings like this:\n        //\n        //   {\"hello # world\"}\n        //\n        // So we know that the tag must be being generated as part of\n        // choice content. Therefore, when the tag has been generated,\n        // we push it onto the evaluation stack in the exact same way\n        // as the string for the choice content.\n        case ControlCommand.CommandType.EndTag: {\n          if (this.state.inStringEvaluation) {\n            let contentStackForTag: InkObject[] = [];\n            let outputCountConsumed = 0;\n            for (let i = this.state.outputStream.length - 1; i >= 0; --i) {\n              let obj = this.state.outputStream[i];\n              outputCountConsumed++;\n\n              // var command = obj as ControlCommand;\n              let command = asOrNull(obj, ControlCommand);\n              if (command != null) {\n                if (\n                  command.commandType == ControlCommand.CommandType.BeginTag\n                ) {\n                  break;\n                } else {\n                  this.Error(\n                    \"Unexpected ControlCommand while extracting tag from choice\"\n                  );\n                  break;\n                }\n              }\n              if (obj instanceof StringValue) {\n                contentStackForTag.push(obj);\n              }\n            }\n\n            // Consume the content that was produced for this string\n            this.state.PopFromOutputStream(outputCountConsumed);\n            // Build string out of the content we collected\n            let sb = new StringBuilder();\n            for (let strVal of contentStackForTag) {\n              sb.Append(strVal.toString());\n            }\n            let choiceTag = new Tag(\n              this.state.CleanOutputWhitespace(sb.toString())\n            );\n            // Pushing to the evaluation stack means it gets picked up\n            // when a Choice is generated from the next Choice Point.\n            this.state.PushEvaluationStack(choiceTag);\n          } else {\n            // Otherwise! Simply push EndTag, so that in the output stream we\n            // have a structure of: [BeginTag, \"the tag content\", EndTag]\n            this.state.PushToOutputStream(evalCommand);\n          }\n          break;\n        }\n\n        case ControlCommand.CommandType.EndString: {\n          let contentStackForString: InkObject[] = [];\n          let contentToRetain: InkObject[] = [];\n\n          let outputCountConsumed = 0;\n          for (let i = this.state.outputStream.length - 1; i >= 0; --i) {\n            let obj = this.state.outputStream[i];\n\n            outputCountConsumed++;\n\n            // var command = obj as ControlCommand;\n            let command = asOrNull(obj, ControlCommand);\n            if (\n              command &&\n              command.commandType == ControlCommand.CommandType.BeginString\n            ) {\n              break;\n            }\n            if (obj instanceof Tag) {\n              contentToRetain.push(obj);\n            }\n            if (obj instanceof StringValue) {\n              contentStackForString.push(obj);\n            }\n          }\n\n          // Consume the content that was produced for this string\n          this.state.PopFromOutputStream(outputCountConsumed);\n\n          // Rescue the tags that we want actually to keep on the output stack\n          // rather than consume as part of the string we're building.\n          // At the time of writing, this only applies to Tag objects generated\n          // by choices, which are pushed to the stack during string generation.\n          for (let rescuedTag of contentToRetain)\n            this.state.PushToOutputStream(rescuedTag);\n\n          // The C# version uses a Stack for contentStackForString, but we're\n          // using a simple array, so we need to reverse it before using it\n          contentStackForString = contentStackForString.reverse();\n\n          // Build string out of the content we collected\n          let sb = new StringBuilder();\n          for (let c of contentStackForString) {\n            sb.Append(c.toString());\n          }\n\n          // Return to expression evaluation (from content mode)\n          this.state.inExpressionEvaluation = true;\n          this.state.PushEvaluationStack(new StringValue(sb.toString()));\n          break;\n        }\n\n        case ControlCommand.CommandType.ChoiceCount:\n          let choiceCount = this.state.generatedChoices.length;\n          this.state.PushEvaluationStack(new IntValue(choiceCount));\n          break;\n\n        case ControlCommand.CommandType.Turns:\n          this.state.PushEvaluationStack(\n            new IntValue(this.state.currentTurnIndex + 1)\n          );\n          break;\n\n        case ControlCommand.CommandType.TurnsSince:\n        case ControlCommand.CommandType.ReadCount:\n          let target = this.state.PopEvaluationStack();\n          if (!(target instanceof DivertTargetValue)) {\n            let extraNote = \"\";\n            if (target instanceof IntValue)\n              extraNote =\n                \". Did you accidentally pass a read count ('knot_name') instead of a target ('-> knot_name')?\";\n            this.Error(\n              \"TURNS_SINCE / READ_COUNT expected a divert target (knot, stitch, label name), but saw \" +\n                target +\n                extraNote\n            );\n            break;\n          }\n\n          // var divertTarget = target as DivertTargetValue;\n          let divertTarget = asOrThrows(target, DivertTargetValue);\n          // var container = ContentAtPath (divertTarget.targetPath).correctObj as Container;\n          let container = asOrNull(\n            this.ContentAtPath(divertTarget.targetPath).correctObj,\n            Container\n          );\n\n          let eitherCount;\n          if (container != null) {\n            if (\n              evalCommand.commandType == ControlCommand.CommandType.TurnsSince\n            )\n              eitherCount = this.state.TurnsSinceForContainer(container);\n            else eitherCount = this.state.VisitCountForContainer(container);\n          } else {\n            if (\n              evalCommand.commandType == ControlCommand.CommandType.TurnsSince\n            )\n              eitherCount = -1;\n            else eitherCount = 0;\n\n            this.Warning(\n              \"Failed to find container for \" +\n                evalCommand.toString() +\n                \" lookup at \" +\n                divertTarget.targetPath.toString()\n            );\n          }\n\n          this.state.PushEvaluationStack(new IntValue(eitherCount));\n          break;\n\n        case ControlCommand.CommandType.Random: {\n          let maxInt = asOrNull(this.state.PopEvaluationStack(), IntValue);\n          let minInt = asOrNull(this.state.PopEvaluationStack(), IntValue);\n\n          if (minInt == null || minInt instanceof IntValue === false)\n            return this.Error(\n              \"Invalid value for minimum parameter of RANDOM(min, max)\"\n            );\n\n          if (maxInt == null || minInt instanceof IntValue === false)\n            return this.Error(\n              \"Invalid value for maximum parameter of RANDOM(min, max)\"\n            );\n\n          // Originally a primitive type, but here, can be null.\n          // TODO: Replace by default value?\n          if (maxInt.value === null) {\n            return throwNullException(\"maxInt.value\");\n          }\n          if (minInt.value === null) {\n            return throwNullException(\"minInt.value\");\n          }\n\n          // This code is differs a bit from the reference implementation, since\n          // JavaScript has no true integers. Hence integer arithmetics and\n          // interger overflows don't apply here. A loss of precision can\n          // happen with big numbers however.\n          //\n          // The case where 'randomRange' is lower than zero is handled below,\n          // so there's no need to test against Number.MIN_SAFE_INTEGER.\n          let randomRange = maxInt.value - minInt.value + 1;\n          if (!isFinite(randomRange) || randomRange > Number.MAX_SAFE_INTEGER) {\n            randomRange = Number.MAX_SAFE_INTEGER;\n            this.Error(\n              \"RANDOM was called with a range that exceeds the size that ink numbers can use.\"\n            );\n          }\n          if (randomRange <= 0)\n            this.Error(\n              \"RANDOM was called with minimum as \" +\n                minInt.value +\n                \" and maximum as \" +\n                maxInt.value +\n                \". The maximum must be larger\"\n            );\n\n          let resultSeed = this.state.storySeed + this.state.previousRandom;\n          let random = new PRNG(resultSeed);\n\n          let nextRandom = random.next();\n          let chosenValue = (nextRandom % randomRange) + minInt.value;\n          this.state.PushEvaluationStack(new IntValue(chosenValue));\n\n          // Next random number (rather than keeping the Random object around)\n          this.state.previousRandom = nextRandom;\n          break;\n        }\n\n        case ControlCommand.CommandType.SeedRandom:\n          let seed = asOrNull(this.state.PopEvaluationStack(), IntValue);\n          if (seed == null || seed instanceof IntValue === false)\n            return this.Error(\"Invalid value passed to SEED_RANDOM\");\n\n          // Originally a primitive type, but here, can be null.\n          // TODO: Replace by default value?\n          if (seed.value === null) {\n            return throwNullException(\"minInt.value\");\n          }\n\n          this.state.storySeed = seed.value;\n          this.state.previousRandom = 0;\n\n          this.state.PushEvaluationStack(new Void());\n          break;\n\n        case ControlCommand.CommandType.VisitIndex:\n          let count =\n            this.state.VisitCountForContainer(\n              this.state.currentPointer.container\n            ) - 1; // index not count\n          this.state.PushEvaluationStack(new IntValue(count));\n          break;\n\n        case ControlCommand.CommandType.SequenceShuffleIndex:\n          let shuffleIndex = this.NextSequenceShuffleIndex();\n          this.state.PushEvaluationStack(new IntValue(shuffleIndex));\n          break;\n\n        case ControlCommand.CommandType.StartThread:\n          // Handled in main step function\n          break;\n\n        case ControlCommand.CommandType.Done:\n          // We may exist in the context of the initial\n          // act of creating the thread, or in the context of\n          // evaluating the content.\n          if (this.state.callStack.canPopThread) {\n            this.state.callStack.PopThread();\n          }\n\n          // In normal flow - allow safe exit without warning\n          else {\n            this.state.didSafeExit = true;\n\n            // Stop flow in current thread\n            this.state.currentPointer = Pointer.Null;\n          }\n\n          break;\n\n        // Force flow to end completely\n        case ControlCommand.CommandType.End:\n          this.state.ForceEnd();\n          break;\n\n        case ControlCommand.CommandType.ListFromInt:\n          // var intVal = state.PopEvaluationStack () as IntValue;\n          let intVal = asOrNull(this.state.PopEvaluationStack(), IntValue);\n          // var listNameVal = state.PopEvaluationStack () as StringValue;\n          let listNameVal = asOrThrows(\n            this.state.PopEvaluationStack(),\n            StringValue\n          );\n\n          if (intVal === null) {\n            throw new StoryException(\n              \"Passed non-integer when creating a list element from a numerical value.\"\n            );\n          }\n\n          let generatedListValue = null;\n\n          if (this.listDefinitions === null) {\n            return throwNullException(\"this.listDefinitions\");\n          }\n          let foundListDef = this.listDefinitions.TryListGetDefinition(\n            listNameVal.value,\n            null\n          );\n          if (foundListDef.exists) {\n            // Originally a primitive type, but here, can be null.\n            // TODO: Replace by default value?\n            if (intVal.value === null) {\n              return throwNullException(\"minInt.value\");\n            }\n\n            let foundItem = foundListDef.result!.TryGetItemWithValue(\n              intVal.value,\n              InkListItem.Null\n            );\n            if (foundItem.exists) {\n              generatedListValue = new ListValue(\n                foundItem.result!,\n                intVal.value\n              );\n            }\n          } else {\n            throw new StoryException(\n              \"Failed to find LIST called \" + listNameVal.value\n            );\n          }\n\n          if (generatedListValue == null) generatedListValue = new ListValue();\n\n          this.state.PushEvaluationStack(generatedListValue);\n          break;\n\n        case ControlCommand.CommandType.ListRange:\n          let max = asOrNull(this.state.PopEvaluationStack(), Value);\n          let min = asOrNull(this.state.PopEvaluationStack(), Value);\n\n          // var targetList = state.PopEvaluationStack () as ListValue;\n          let targetList = asOrNull(this.state.PopEvaluationStack(), ListValue);\n\n          if (targetList === null || min === null || max === null)\n            throw new StoryException(\n              \"Expected list, minimum and maximum for LIST_RANGE\"\n            );\n\n          if (targetList.value === null) {\n            return throwNullException(\"targetList.value\");\n          }\n          let result = targetList.value.ListWithSubRange(\n            min.valueObject,\n            max.valueObject\n          );\n\n          this.state.PushEvaluationStack(new ListValue(result));\n          break;\n\n        case ControlCommand.CommandType.ListRandom: {\n          let listVal = this.state.PopEvaluationStack() as ListValue;\n          if (listVal === null)\n            throw new StoryException(\"Expected list for LIST_RANDOM\");\n\n          let list = listVal.value;\n\n          let newList: InkList | null = null;\n\n          if (list === null) {\n            throw throwNullException(\"list\");\n          }\n          if (list.Count == 0) {\n            newList = new InkList();\n          } else {\n            // Generate a random index for the element to take\n            let resultSeed = this.state.storySeed + this.state.previousRandom;\n            let random = new PRNG(resultSeed);\n\n            let nextRandom = random.next();\n            let listItemIndex = nextRandom % list.Count;\n\n            // This bit is a little different from the original\n            // C# code, since iterators do not work in the same way.\n            // First, we iterate listItemIndex - 1 times, calling next().\n            // The listItemIndex-th time is made outside of the loop,\n            // in order to retrieve the value.\n            let listEnumerator = list.entries();\n            for (let i = 0; i <= listItemIndex - 1; i++) {\n              listEnumerator.next();\n            }\n            let value = listEnumerator.next().value;\n            let randomItem: KeyValuePair<InkListItem, number> = {\n              Key: InkListItem.fromSerializedKey(value[0]),\n              Value: value[1],\n            };\n\n            // Origin list is simply the origin of the one element\n            if (randomItem.Key.originName === null) {\n              return throwNullException(\"randomItem.Key.originName\");\n            }\n            newList = new InkList(randomItem.Key.originName, this);\n            newList.Add(randomItem.Key, randomItem.Value);\n\n            this.state.previousRandom = nextRandom;\n          }\n\n          this.state.PushEvaluationStack(new ListValue(newList));\n          break;\n        }\n\n        default:\n          this.Error(\"unhandled ControlCommand: \" + evalCommand);\n          break;\n      }\n\n      return true;\n    }\n\n    // Variable assignment\n    else if (contentObj instanceof VariableAssignment) {\n      let varAss = contentObj;\n      let assignedVal = this.state.PopEvaluationStack();\n\n      this.state.variablesState.Assign(varAss, assignedVal);\n\n      return true;\n    }\n\n    // Variable reference\n    else if (contentObj instanceof VariableReference) {\n      let varRef = contentObj;\n      let foundValue = null;\n\n      // Explicit read count value\n      if (varRef.pathForCount != null) {\n        let container = varRef.containerForCount;\n        let count = this.state.VisitCountForContainer(container);\n        foundValue = new IntValue(count);\n      }\n\n      // Normal variable reference\n      else {\n        foundValue = this.state.variablesState.GetVariableWithName(varRef.name);\n\n        if (foundValue == null) {\n          this.Warning(\n            \"Variable not found: '\" +\n              varRef.name +\n              \"'. Using default value of 0 (false). This can happen with temporary variables if the declaration hasn't yet been hit. Globals are always given a default value on load if a value doesn't exist in the save state.\"\n          );\n          foundValue = new IntValue(0);\n        }\n      }\n\n      this.state.PushEvaluationStack(foundValue);\n\n      return true;\n    }\n\n    // Native function call\n    else if (contentObj instanceof NativeFunctionCall) {\n      let func = contentObj;\n      let funcParams = this.state.PopEvaluationStack(func.numberOfParameters);\n      let result = func.Call(funcParams);\n      this.state.PushEvaluationStack(result);\n      return true;\n    }\n\n    // No control content, must be ordinary content\n    return false;\n  }\n\n  public ChoosePathString(\n    path: string,\n    resetCallstack = true,\n    args: any[] = []\n  ) {\n    this.IfAsyncWeCant(\"call ChoosePathString right now\");\n    if (this.onChoosePathString !== null) this.onChoosePathString(path, args);\n\n    if (resetCallstack) {\n      this.ResetCallstack();\n    } else {\n      if (this.state.callStack.currentElement.type == PushPopType.Function) {\n        let funcDetail = \"\";\n        let container =\n          this.state.callStack.currentElement.currentPointer.container;\n        if (container != null) {\n          funcDetail = \"(\" + container.path.toString() + \") \";\n        }\n        throw new Error(\n          \"Story was running a function \" +\n            funcDetail +\n            \"when you called ChoosePathString(\" +\n            path +\n            \") - this is almost certainly not not what you want! Full stack trace: \\n\" +\n            this.state.callStack.callStackTrace\n        );\n      }\n    }\n\n    this.state.PassArgumentsToEvaluationStack(args);\n    this.ChoosePath(new Path(path));\n  }\n\n  public IfAsyncWeCant(activityStr: string) {\n    if (this._asyncContinueActive)\n      throw new Error(\n        \"Can't \" +\n          activityStr +\n          \". Story is in the middle of a ContinueAsync(). Make more ContinueAsync() calls or a single Continue() call beforehand.\"\n      );\n  }\n\n  public ChoosePath(p: Path, incrementingTurnIndex: boolean = true) {\n    this.state.SetChosenPath(p, incrementingTurnIndex);\n\n    // Take a note of newly visited containers for read counts etc\n    this.VisitChangedContainersDueToDivert();\n  }\n\n  public ChooseChoiceIndex(choiceIdx: number) {\n    choiceIdx = choiceIdx;\n    let choices = this.currentChoices;\n    this.Assert(\n      choiceIdx >= 0 && choiceIdx < choices.length,\n      \"choice out of range\"\n    );\n\n    let choiceToChoose = choices[choiceIdx];\n    if (this.onMakeChoice !== null) this.onMakeChoice(choiceToChoose);\n\n    if (choiceToChoose.threadAtGeneration === null) {\n      return throwNullException(\"choiceToChoose.threadAtGeneration\");\n    }\n    if (choiceToChoose.targetPath === null) {\n      return throwNullException(\"choiceToChoose.targetPath\");\n    }\n\n    this.state.callStack.currentThread = choiceToChoose.threadAtGeneration;\n\n    this.ChoosePath(choiceToChoose.targetPath);\n  }\n\n  public HasFunction(functionName: string) {\n    try {\n      return this.KnotContainerWithName(functionName) != null;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  public EvaluateFunction(\n    functionName: string,\n    args: any[] = [],\n    returnTextOutput: boolean = false\n  ): Story.EvaluateFunctionTextOutput | any {\n    // EvaluateFunction behaves slightly differently than the C# version.\n    // In C#, you can pass a (second) parameter `out textOutput` to get the\n    // text outputted by the function. This is not possible in js. Instead,\n    // we maintain the regular signature (functionName, args), plus an\n    // optional third parameter returnTextOutput. If set to true, we will\n    // return both the textOutput and the returned value, as an object.\n\n    if (this.onEvaluateFunction !== null)\n      this.onEvaluateFunction(functionName, args);\n\n    this.IfAsyncWeCant(\"evaluate a function\");\n\n    if (functionName == null) {\n      throw new Error(\"Function is null\");\n    } else if (functionName == \"\" || functionName.trim() == \"\") {\n      throw new Error(\"Function is empty or white space.\");\n    }\n\n    let funcContainer = this.KnotContainerWithName(functionName);\n    if (funcContainer == null) {\n      throw new Error(\"Function doesn't exist: '\" + functionName + \"'\");\n    }\n\n    let outputStreamBefore: InkObject[] = [];\n    outputStreamBefore.push(...this.state.outputStream);\n    this._state.ResetOutput();\n\n    this.state.StartFunctionEvaluationFromGame(funcContainer, args);\n\n    // Evaluate the function, and collect the string output\n    let stringOutput = new StringBuilder();\n    while (this.canContinue) {\n      stringOutput.Append(this.Continue());\n    }\n    let textOutput = stringOutput.toString();\n\n    this._state.ResetOutput(outputStreamBefore);\n\n    let result = this.state.CompleteFunctionEvaluationFromGame();\n    if (this.onCompleteEvaluateFunction != null)\n      this.onCompleteEvaluateFunction(functionName, args, textOutput, result);\n\n    return returnTextOutput ? { returned: result, output: textOutput } : result;\n  }\n\n  public EvaluateExpression(exprContainer: Container) {\n    let startCallStackHeight = this.state.callStack.elements.length;\n\n    this.state.callStack.Push(PushPopType.Tunnel);\n\n    this._temporaryEvaluationContainer = exprContainer;\n\n    this.state.GoToStart();\n\n    let evalStackHeight = this.state.evaluationStack.length;\n\n    this.Continue();\n\n    this._temporaryEvaluationContainer = null;\n\n    // Should have fallen off the end of the Container, which should\n    // have auto-popped, but just in case we didn't for some reason,\n    // manually pop to restore the state (including currentPath).\n    if (this.state.callStack.elements.length > startCallStackHeight) {\n      this.state.PopCallStack();\n    }\n\n    let endStackHeight = this.state.evaluationStack.length;\n    if (endStackHeight > evalStackHeight) {\n      return this.state.PopEvaluationStack();\n    } else {\n      return null;\n    }\n  }\n\n  public allowExternalFunctionFallbacks: boolean = false;\n\n  public CallExternalFunction(\n    funcName: string | null,\n    numberOfArguments: number\n  ) {\n    if (funcName === null) {\n      return throwNullException(\"funcName\");\n    }\n    let funcDef = this._externals.get(funcName);\n    let fallbackFunctionContainer = null;\n\n    let foundExternal = typeof funcDef !== \"undefined\";\n\n    if (\n      foundExternal &&\n      !funcDef!.lookAheadSafe &&\n      this._stateSnapshotAtLastNewline !== null\n    ) {\n      this._sawLookaheadUnsafeFunctionAfterNewline = true;\n      return;\n    }\n\n    if (!foundExternal) {\n      if (this.allowExternalFunctionFallbacks) {\n        fallbackFunctionContainer = this.KnotContainerWithName(funcName);\n        this.Assert(\n          fallbackFunctionContainer !== null,\n          \"Trying to call EXTERNAL function '\" +\n            funcName +\n            \"' which has not been bound, and fallback ink function could not be found.\"\n        );\n\n        // Divert direct into fallback function and we're done\n        this.state.callStack.Push(\n          PushPopType.Function,\n          undefined,\n          this.state.outputStream.length\n        );\n        this.state.divertedPointer = Pointer.StartOf(fallbackFunctionContainer);\n        return;\n      } else {\n        this.Assert(\n          false,\n          \"Trying to call EXTERNAL function '\" +\n            funcName +\n            \"' which has not been bound (and ink fallbacks disabled).\"\n        );\n      }\n    }\n\n    // Pop arguments\n    let args: any[] = [];\n    for (let i = 0; i < numberOfArguments; ++i) {\n      // var poppedObj = state.PopEvaluationStack () as Value;\n      let poppedObj = asOrThrows(this.state.PopEvaluationStack(), Value);\n      let valueObj = poppedObj.valueObject;\n      args.push(valueObj);\n    }\n\n    // Reverse arguments from the order they were popped,\n    // so they're the right way round again.\n    args.reverse();\n\n    // Run the function!\n    let funcResult = funcDef!.function(args);\n\n    // Convert return value (if any) to the a type that the ink engine can use\n    let returnObj = null;\n    if (funcResult != null) {\n      returnObj = Value.Create(funcResult);\n      this.Assert(\n        returnObj !== null,\n        \"Could not create ink value from returned object of type \" +\n          typeof funcResult\n      );\n    } else {\n      returnObj = new Void();\n    }\n\n    this.state.PushEvaluationStack(returnObj);\n  }\n\n  public BindExternalFunctionGeneral(\n    funcName: string,\n    func: Story.ExternalFunction,\n    lookaheadSafe: boolean = true\n  ) {\n    this.IfAsyncWeCant(\"bind an external function\");\n    this.Assert(\n      !this._externals.has(funcName),\n      \"Function '\" + funcName + \"' has already been bound.\"\n    );\n    this._externals.set(funcName, {\n      function: func,\n      lookAheadSafe: lookaheadSafe,\n    });\n  }\n\n  public TryCoerce(value: any) {\n    // We're skipping type coercition in this implementation. First of, js\n    // is loosely typed, so it's not that important. Secondly, there is no\n    // clean way (AFAIK) for the user to describe what type of parameters\n    // they expect.\n    return value;\n  }\n\n  public BindExternalFunction(\n    funcName: string,\n    func: Story.ExternalFunction,\n    lookaheadSafe: boolean = false\n  ) {\n    this.Assert(func != null, \"Can't bind a null function\");\n\n    this.BindExternalFunctionGeneral(\n      funcName,\n      (args: any) => {\n        this.Assert(\n          args.length >= func.length,\n          \"External function expected \" + func.length + \" arguments\"\n        );\n\n        let coercedArgs = [];\n        for (let i = 0, l = args.length; i < l; i++) {\n          coercedArgs[i] = this.TryCoerce(args[i]);\n        }\n        return func.apply(null, coercedArgs);\n      },\n      lookaheadSafe\n    );\n  }\n\n  public UnbindExternalFunction(funcName: string) {\n    this.IfAsyncWeCant(\"unbind an external a function\");\n    this.Assert(\n      this._externals.has(funcName),\n      \"Function '\" + funcName + \"' has not been bound.\"\n    );\n    this._externals.delete(funcName);\n  }\n\n  public ValidateExternalBindings(): void;\n  public ValidateExternalBindings(\n    c: Container | null,\n    missingExternals: Set<string>\n  ): void;\n  public ValidateExternalBindings(\n    o: InkObject | null,\n    missingExternals: Set<string>\n  ): void;\n  public ValidateExternalBindings() {\n    let c: Container | null = null;\n    let o: InkObject | null = null;\n    let missingExternals: Set<string> = arguments[1] || new Set();\n\n    if (arguments[0] instanceof Container) {\n      c = arguments[0];\n    }\n\n    if (arguments[0] instanceof InkObject) {\n      o = arguments[0];\n    }\n\n    if (c === null && o === null) {\n      this.ValidateExternalBindings(\n        this._mainContentContainer,\n        missingExternals\n      );\n      this._hasValidatedExternals = true;\n\n      // No problem! Validation complete\n      if (missingExternals.size == 0) {\n        this._hasValidatedExternals = true;\n      } else {\n        let message = \"Error: Missing function binding for external\";\n        message += missingExternals.size > 1 ? \"s\" : \"\";\n        message += \": '\";\n        message += Array.from(missingExternals).join(\"', '\");\n        message += \"' \";\n        message += this.allowExternalFunctionFallbacks\n          ? \", and no fallback ink function found.\"\n          : \" (ink fallbacks disabled)\";\n\n        this.Error(message);\n      }\n    } else if (c != null) {\n      for (let innerContent of c.content) {\n        let container = innerContent as Container;\n        if (container == null || !container.hasValidName)\n          this.ValidateExternalBindings(innerContent, missingExternals);\n      }\n      for (let [, value] of c.namedContent) {\n        this.ValidateExternalBindings(\n          asOrNull(value, InkObject),\n          missingExternals\n        );\n      }\n    } else if (o != null) {\n      let divert = asOrNull(o, Divert);\n      if (divert && divert.isExternal) {\n        let name = divert.targetPathString;\n        if (name === null) {\n          return throwNullException(\"name\");\n        }\n        if (!this._externals.has(name)) {\n          if (this.allowExternalFunctionFallbacks) {\n            let fallbackFound =\n              this.mainContentContainer.namedContent.has(name);\n            if (!fallbackFound) {\n              missingExternals.add(name);\n            }\n          } else {\n            missingExternals.add(name);\n          }\n        }\n      }\n    }\n  }\n\n  public ObserveVariable(\n    variableName: string,\n    observer: Story.VariableObserver\n  ) {\n    this.IfAsyncWeCant(\"observe a new variable\");\n\n    if (this._variableObservers === null) this._variableObservers = new Map();\n\n    if (!this.state.variablesState.GlobalVariableExistsWithName(variableName))\n      throw new Error(\n        \"Cannot observe variable '\" +\n          variableName +\n          \"' because it wasn't declared in the ink story.\"\n      );\n\n    if (this._variableObservers.has(variableName)) {\n      this._variableObservers.get(variableName)!.push(observer);\n    } else {\n      this._variableObservers.set(variableName, [observer]);\n    }\n  }\n\n  public ObserveVariables(\n    variableNames: string[],\n    observers: Story.VariableObserver[]\n  ) {\n    for (let i = 0, l = variableNames.length; i < l; i++) {\n      this.ObserveVariable(variableNames[i], observers[i]);\n    }\n  }\n\n  public RemoveVariableObserver(\n    observer?: Story.VariableObserver,\n    specificVariableName?: string\n  ) {\n    // A couple of things to know about this method:\n    //\n    // 1. Since `RemoveVariableObserver` is exposed to the JavaScript world,\n    //    optionality is marked as `undefined` rather than `null`.\n    //    To keep things simple, null-checks are performed using regular\n    //    equality operators, where undefined == null.\n    //\n    // 2. Since C# delegates are translated to arrays of functions,\n    //    -= becomes a call to splice and null-checks are replaced by\n    //    emptiness-checks.\n    //\n    this.IfAsyncWeCant(\"remove a variable observer\");\n\n    if (this._variableObservers === null) return;\n\n    if (specificVariableName != null) {\n      if (this._variableObservers.has(specificVariableName)) {\n        if (observer != null) {\n          let variableObservers =\n            this._variableObservers.get(specificVariableName);\n          if (variableObservers != null) {\n            variableObservers.splice(variableObservers.indexOf(observer), 1);\n            if (variableObservers.length === 0) {\n              this._variableObservers.delete(specificVariableName);\n            }\n          }\n        } else {\n          this._variableObservers.delete(specificVariableName);\n        }\n      }\n    } else if (observer != null) {\n      let keys = this._variableObservers.keys();\n      for (let varName of keys) {\n        let variableObservers = this._variableObservers.get(varName);\n        if (variableObservers != null) {\n          variableObservers.splice(variableObservers.indexOf(observer), 1);\n          if (variableObservers.length === 0) {\n            this._variableObservers.delete(varName);\n          }\n        }\n      }\n    }\n  }\n\n  public VariableStateDidChangeEvent(\n    variableName: string,\n    newValueObj: InkObject\n  ) {\n    if (this._variableObservers === null) return;\n\n    let observers = this._variableObservers.get(variableName);\n    if (typeof observers !== \"undefined\") {\n      if (!(newValueObj instanceof Value)) {\n        throw new Error(\n          \"Tried to get the value of a variable that isn't a standard type\"\n        );\n      }\n      // var val = newValueObj as Value;\n      let val = asOrThrows(newValueObj, Value);\n\n      for (let observer of observers) {\n        observer(variableName, val.valueObject);\n      }\n    }\n  }\n\n  get globalTags() {\n    return this.TagsAtStartOfFlowContainerWithPathString(\"\");\n  }\n\n  public TagsForContentAtPath(path: string) {\n    return this.TagsAtStartOfFlowContainerWithPathString(path);\n  }\n\n  public TagsAtStartOfFlowContainerWithPathString(pathString: string) {\n    let path = new Path(pathString);\n\n    let flowContainer = this.ContentAtPath(path).container;\n    if (flowContainer === null) {\n      return throwNullException(\"flowContainer\");\n    }\n    while (true) {\n      let firstContent: InkObject = flowContainer.content[0];\n      if (firstContent instanceof Container) flowContainer = firstContent;\n      else break;\n    }\n\n    let inTag = false;\n    let tags: string[] | null = null;\n\n    for (let c of flowContainer.content) {\n      // var tag = c as Runtime.Tag;\n      let command = asOrNull(c, ControlCommand);\n\n      if (command != null) {\n        if (command.commandType == ControlCommand.CommandType.BeginTag) {\n          inTag = true;\n        } else if (command.commandType == ControlCommand.CommandType.EndTag) {\n          inTag = false;\n        }\n      } else if (inTag) {\n        let str = asOrNull(c, StringValue);\n        if (str !== null) {\n          if (tags === null) tags = [];\n          if (str.value !== null) tags.push(str.value);\n        } else {\n          this.Error(\n            \"Tag contained non-text content. Only plain text is allowed when using globalTags or TagsAtContentPath. If you want to evaluate dynamic content, you need to use story.Continue().\"\n          );\n        }\n      } else {\n        break;\n      }\n    }\n\n    return tags;\n  }\n\n  public BuildStringOfHierarchy() {\n    let sb = new StringBuilder();\n\n    this.mainContentContainer.BuildStringOfHierarchy(\n      sb,\n      0,\n      this.state.currentPointer.Resolve()\n    );\n\n    return sb.toString();\n  }\n\n  public BuildStringOfContainer(container: Container) {\n    let sb = new StringBuilder();\n    container.BuildStringOfHierarchy(\n      sb,\n      0,\n      this.state.currentPointer.Resolve()\n    );\n    return sb.toString();\n  }\n\n  public NextContent() {\n    this.state.previousPointer = this.state.currentPointer.copy();\n\n    if (!this.state.divertedPointer.isNull) {\n      this.state.currentPointer = this.state.divertedPointer.copy();\n      this.state.divertedPointer = Pointer.Null;\n\n      this.VisitChangedContainersDueToDivert();\n\n      if (!this.state.currentPointer.isNull) {\n        return;\n      }\n    }\n\n    let successfulPointerIncrement = this.IncrementContentPointer();\n\n    if (!successfulPointerIncrement) {\n      let didPop = false;\n\n      if (this.state.callStack.CanPop(PushPopType.Function)) {\n        this.state.PopCallStack(PushPopType.Function);\n\n        if (this.state.inExpressionEvaluation) {\n          this.state.PushEvaluationStack(new Void());\n        }\n\n        didPop = true;\n      } else if (this.state.callStack.canPopThread) {\n        this.state.callStack.PopThread();\n\n        didPop = true;\n      } else {\n        this.state.TryExitFunctionEvaluationFromGame();\n      }\n\n      if (didPop && !this.state.currentPointer.isNull) {\n        this.NextContent();\n      }\n    }\n  }\n\n  public IncrementContentPointer() {\n    let successfulIncrement = true;\n\n    let pointer = this.state.callStack.currentElement.currentPointer.copy();\n    pointer.index++;\n\n    if (pointer.container === null) {\n      return throwNullException(\"pointer.container\");\n    }\n    while (pointer.index >= pointer.container.content.length) {\n      successfulIncrement = false;\n\n      // Container nextAncestor = pointer.container.parent as Container;\n      let nextAncestor = asOrNull(pointer.container.parent, Container);\n      if (nextAncestor instanceof Container === false) {\n        break;\n      }\n\n      let indexInAncestor = nextAncestor!.content.indexOf(pointer.container);\n      if (indexInAncestor == -1) {\n        break;\n      }\n\n      pointer = new Pointer(nextAncestor, indexInAncestor);\n\n      pointer.index++;\n\n      successfulIncrement = true;\n      if (pointer.container === null) {\n        return throwNullException(\"pointer.container\");\n      }\n    }\n\n    if (!successfulIncrement) pointer = Pointer.Null;\n\n    this.state.callStack.currentElement.currentPointer = pointer.copy();\n\n    return successfulIncrement;\n  }\n\n  public TryFollowDefaultInvisibleChoice() {\n    let allChoices = this._state.currentChoices;\n\n    let invisibleChoices = allChoices.filter((c) => c.isInvisibleDefault);\n\n    if (\n      invisibleChoices.length == 0 ||\n      allChoices.length > invisibleChoices.length\n    )\n      return false;\n\n    let choice = invisibleChoices[0];\n\n    if (choice.targetPath === null) {\n      return throwNullException(\"choice.targetPath\");\n    }\n\n    if (choice.threadAtGeneration === null) {\n      return throwNullException(\"choice.threadAtGeneration\");\n    }\n\n    this.state.callStack.currentThread = choice.threadAtGeneration;\n\n    if (this._stateSnapshotAtLastNewline !== null) {\n      this.state.callStack.currentThread = this.state.callStack.ForkThread();\n    }\n\n    this.ChoosePath(choice.targetPath, false);\n\n    return true;\n  }\n\n  public NextSequenceShuffleIndex() {\n    // var numElementsIntVal = state.PopEvaluationStack () as IntValue;\n    let numElementsIntVal = asOrNull(this.state.PopEvaluationStack(), IntValue);\n    if (!(numElementsIntVal instanceof IntValue)) {\n      this.Error(\"expected number of elements in sequence for shuffle index\");\n      return 0;\n    }\n\n    let seqContainer = this.state.currentPointer.container;\n    if (seqContainer === null) {\n      return throwNullException(\"seqContainer\");\n    }\n\n    // Originally a primitive type, but here, can be null.\n    // TODO: Replace by default value?\n    if (numElementsIntVal.value === null) {\n      return throwNullException(\"numElementsIntVal.value\");\n    }\n    let numElements = numElementsIntVal.value;\n\n    // var seqCountVal = state.PopEvaluationStack () as IntValue;\n    let seqCountVal = asOrThrows(this.state.PopEvaluationStack(), IntValue);\n    let seqCount = seqCountVal.value;\n\n    // Originally a primitive type, but here, can be null.\n    // TODO: Replace by default value?\n    if (seqCount === null) {\n      return throwNullException(\"seqCount\");\n    }\n\n    let loopIndex = seqCount / numElements;\n    let iterationIndex = seqCount % numElements;\n\n    let seqPathStr = seqContainer.path.toString();\n    let sequenceHash = 0;\n    for (let i = 0, l = seqPathStr.length; i < l; i++) {\n      sequenceHash += seqPathStr.charCodeAt(i) || 0;\n    }\n    let randomSeed = sequenceHash + loopIndex + this.state.storySeed;\n    let random = new PRNG(Math.floor(randomSeed));\n\n    let unpickedIndices = [];\n    for (let i = 0; i < numElements; ++i) {\n      unpickedIndices.push(i);\n    }\n\n    for (let i = 0; i <= iterationIndex; ++i) {\n      let chosen = random.next() % unpickedIndices.length;\n      let chosenIndex = unpickedIndices[chosen];\n      unpickedIndices.splice(chosen, 1);\n\n      if (i == iterationIndex) {\n        return chosenIndex;\n      }\n    }\n\n    throw new Error(\"Should never reach here\");\n  }\n\n  public Error(message: string, useEndLineNumber = false): never {\n    let e = new StoryException(message);\n    e.useEndLineNumber = useEndLineNumber;\n    throw e;\n  }\n\n  public Warning(message: string) {\n    this.AddError(message, true);\n  }\n\n  public AddError(\n    message: string,\n    isWarning = false,\n    useEndLineNumber = false\n  ) {\n    let dm = this.currentDebugMetadata;\n\n    let errorTypeStr = isWarning ? \"WARNING\" : \"ERROR\";\n\n    if (dm != null) {\n      let lineNum = useEndLineNumber ? dm.endLineNumber : dm.startLineNumber;\n      message =\n        \"RUNTIME \" +\n        errorTypeStr +\n        \": '\" +\n        dm.fileName +\n        \"' line \" +\n        lineNum +\n        \": \" +\n        message;\n    } else if (!this.state.currentPointer.isNull) {\n      message =\n        \"RUNTIME \" +\n        errorTypeStr +\n        \": (\" +\n        this.state.currentPointer +\n        \"): \" +\n        message;\n    } else {\n      message = \"RUNTIME \" + errorTypeStr + \": \" + message;\n    }\n\n    this.state.AddError(message, isWarning);\n\n    // In a broken state don't need to know about any other errors.\n    if (!isWarning) this.state.ForceEnd();\n  }\n\n  public Assert(condition: boolean, message: string | null = null) {\n    if (condition == false) {\n      if (message == null) {\n        message = \"Story assert\";\n      }\n\n      throw new Error(message + \" \" + this.currentDebugMetadata);\n    }\n  }\n\n  get currentDebugMetadata(): DebugMetadata | null {\n    let dm: DebugMetadata | null;\n\n    let pointer = this.state.currentPointer;\n    if (!pointer.isNull && pointer.Resolve() !== null) {\n      dm = pointer.Resolve()!.debugMetadata;\n      if (dm !== null) {\n        return dm;\n      }\n    }\n\n    for (let i = this.state.callStack.elements.length - 1; i >= 0; --i) {\n      pointer = this.state.callStack.elements[i].currentPointer;\n      if (!pointer.isNull && pointer.Resolve() !== null) {\n        dm = pointer.Resolve()!.debugMetadata;\n        if (dm !== null) {\n          return dm;\n        }\n      }\n    }\n\n    for (let i = this.state.outputStream.length - 1; i >= 0; --i) {\n      let outputObj = this.state.outputStream[i];\n      dm = outputObj.debugMetadata;\n      if (dm !== null) {\n        return dm;\n      }\n    }\n\n    return null;\n  }\n\n  get mainContentContainer() {\n    if (this._temporaryEvaluationContainer) {\n      return this._temporaryEvaluationContainer;\n    } else {\n      return this._mainContentContainer;\n    }\n  }\n\n  /**\n   * `_mainContentContainer` is almost guaranteed to be set in the\n   * constructor, unless the json is malformed.\n   */\n  private _mainContentContainer!: Container;\n  private _listDefinitions: ListDefinitionsOrigin | null = null;\n\n  private _externals: Map<string, Story.ExternalFunctionDef>;\n  private _variableObservers: Map<string, Story.VariableObserver[]> | null =\n    null;\n  private _hasValidatedExternals: boolean = false;\n\n  private _temporaryEvaluationContainer: Container | null = null;\n\n  /**\n   * `state` is almost guaranteed to be set in the constructor, unless\n   * using the compiler-specific constructor which will likely not be used in\n   * the real world.\n   */\n  private _state!: StoryState;\n\n  private _asyncContinueActive: boolean = false;\n  private _stateSnapshotAtLastNewline: StoryState | null = null;\n  private _sawLookaheadUnsafeFunctionAfterNewline: boolean = false;\n\n  private _recursiveContinueCount: number = 0;\n\n  private _asyncSaving: boolean = false;\n\n  private _profiler: any | null = null; // TODO: Profiler\n}\n\nexport namespace Story {\n  export enum OutputStateChange {\n    NoChange = 0,\n    ExtendedBeyondNewline = 1,\n    NewlineRemoved = 2,\n  }\n\n  export interface EvaluateFunctionTextOutput {\n    returned: any;\n    output: string;\n  }\n\n  export interface ExternalFunctionDef {\n    function: ExternalFunction;\n    lookAheadSafe: boolean;\n  }\n\n  export type VariableObserver = (variableName: string, newValue: any) => void;\n  export type ExternalFunction = (...args: any) => any;\n}\n","import { AuthorWarning } from \"./AuthorWarning\";\nimport { ConstantDeclaration } from \"./Declaration/ConstantDeclaration\";\nimport { Container as RuntimeContainer } from \"../../../engine/Container\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../engine/ControlCommand\";\nimport { ErrorHandler } from \"../../../engine/Error\";\nimport { ErrorType } from \"../ErrorType\";\nimport { Expression } from \"./Expression/Expression\";\nimport { ExternalDeclaration } from \"./Declaration/ExternalDeclaration\";\nimport { FlowBase } from \"./Flow/FlowBase\";\nimport { FlowLevel } from \"./Flow/FlowLevel\";\nimport { IncludedFile } from \"./IncludedFile\";\nimport { ListDefinition } from \"./List/ListDefinition\";\nimport { ListElementDefinition } from \"./List/ListElementDefinition\";\nimport { ParsedObject } from \"./Object\";\nimport { Story as RuntimeStory } from \"../../../engine/Story\";\nimport { SymbolType } from \"./SymbolType\";\nimport { Text } from \"./Text\";\nimport { VariableAssignment as RuntimeVariableAssignment } from \"../../../engine/VariableAssignment\";\nimport { Identifier } from \"./Identifier\";\nimport { asOrNull } from \"../../../engine/TypeAssertion\";\nimport { ClosestFlowBase } from \"./Flow/ClosestFlowBase\";\nimport { FunctionCall } from \"./FunctionCall\";\nimport { Path } from \"./Path\";\nimport { VariableAssignment } from \"./Variable/VariableAssignment\";\n\nexport class Story extends FlowBase {\n  public static readonly IsReservedKeyword = (name?: string): boolean => {\n    switch (name) {\n      case \"true\":\n      case \"false\":\n      case \"not\":\n      case \"return\":\n      case \"else\":\n      case \"VAR\":\n      case \"CONST\":\n      case \"temp\":\n      case \"LIST\":\n      case \"function\":\n        return true;\n    }\n\n    return false;\n  };\n\n  private _errorHandler: ErrorHandler | null = null;\n  private _hadError: boolean = false;\n  private _hadWarning: boolean = false;\n  private _dontFlattenContainers: Set<RuntimeContainer> = new Set();\n  private _listDefs: Map<string, ListDefinition> = new Map();\n\n  get flowLevel(): FlowLevel {\n    return FlowLevel.Story;\n  }\n\n  get hadError(): boolean {\n    return this._hadError;\n  }\n\n  get hadWarning(): boolean {\n    return this._hadWarning;\n  }\n\n  public constants: Map<string, Expression> = new Map();\n  public externals: Map<string, ExternalDeclaration> = new Map();\n\n  // Build setting for exporting:\n  // When true, the visit count for *all* knots, stitches, choices,\n  // and gathers is counted. When false, only those that are direclty\n  // referenced by the ink are recorded. Use this flag to allow game-side\n  // querying of  arbitrary knots/stitches etc.\n  // Storing all counts is more robust and future proof (updates to the story file\n  // that reference previously uncounted visits are possible, but generates a much\n  // larger safe file, with a lot of potentially redundant counts.\n  public countAllVisits: boolean = false;\n\n  constructor(toplevelObjects: ParsedObject[], isInclude: boolean = false) {\n    // Don't do anything much on construction, leave it lightweight until\n    // the ExportRuntime method is called.\n    super(null, toplevelObjects, null, false, isInclude);\n  }\n\n  get typeName(): string {\n    return \"Story\";\n  }\n\n  // Before this function is called, we have IncludedFile objects interspersed\n  // in our content wherever an include statement was.\n  // So that the include statement can be added in a sensible place (e.g. the\n  // top of the file) without side-effects of jumping into a knot that was\n  // defined in that include, we separate knots and stitches from anything\n  // else defined at the top scope of the included file.\n  //\n  // Algorithm: For each IncludedFile we find, split its contents into\n  // knots/stiches and any other content. Insert the normal content wherever\n  // the include statement was, and append the knots/stitches to the very\n  // end of the main story.\n  public PreProcessTopLevelObjects(topLevelContent: ParsedObject[]): void {\n    super.PreProcessTopLevelObjects(topLevelContent);\n\n    const flowsFromOtherFiles = [];\n\n    // Inject included files\n    for (let obj of topLevelContent) {\n      if (obj instanceof IncludedFile) {\n        const file: IncludedFile = obj;\n\n        // Remove the IncludedFile itself\n        const posOfObj = topLevelContent.indexOf(obj);\n        topLevelContent.splice(posOfObj, 1);\n\n        // When an included story fails to load, the include\n        // line itself is still valid, so we have to handle it here\n        if (file.includedStory) {\n          const nonFlowContent: ParsedObject[] = [];\n          const subStory = file.includedStory;\n          // Allow empty file\n          if (subStory.content != null) {\n            for (const subStoryObj of subStory.content) {\n              if (subStoryObj instanceof FlowBase) {\n                flowsFromOtherFiles.push(subStoryObj);\n              } else {\n                nonFlowContent.push(subStoryObj);\n              }\n            }\n\n            // Add newline on the end of the include\n            nonFlowContent.push(new Text(\"\\n\"));\n\n            // Add contents of the file in its place\n            topLevelContent.splice(posOfObj, 0, ...nonFlowContent);\n\n            // Skip past the content of this sub story\n            // (since it will already have recursively included\n            //  any lines from other files)\n          }\n        }\n\n        // Include object has been removed, with possible content inserted,\n        // and position of 'i' will have been determined already.\n        continue;\n      }\n    }\n\n    // Add the flows we collected from the included files to the\n    // end of our list of our content\n    topLevelContent.splice(0, 0, ...flowsFromOtherFiles);\n  }\n\n  public readonly ExportRuntime = (\n    errorHandler: ErrorHandler | null = null\n  ): RuntimeStory | null => {\n    this._errorHandler = errorHandler;\n\n    // Find all constants before main export begins, so that VariableReferences know\n    // whether to generate a runtime variable reference or the literal value\n    this.constants = new Map();\n    for (const constDecl of this.FindAll(ConstantDeclaration)()) {\n      // Check for duplicate definitions\n      const existingDefinition: Expression = this.constants.get(\n        constDecl.constantName!\n      ) as any;\n\n      if (existingDefinition) {\n        if (!existingDefinition.Equals(constDecl.expression)) {\n          const errorMsg = `CONST '${constDecl.constantName}' has been redefined with a different value. Multiple definitions of the same CONST are valid so long as they contain the same value. Initial definition was on ${existingDefinition.debugMetadata}.`;\n          this.Error(errorMsg, constDecl, false);\n        }\n      }\n\n      this.constants.set(constDecl.constantName!, constDecl.expression);\n    }\n\n    // List definitions are treated like constants too - they should be usable\n    // from other variable declarations.\n    this._listDefs = new Map();\n    for (const listDef of this.FindAll<ListDefinition>(ListDefinition)()) {\n      if (listDef.identifier?.name) {\n        this._listDefs.set(listDef.identifier?.name, listDef);\n      }\n    }\n\n    this.externals = new Map();\n\n    // Resolution of weave point names has to come first, before any runtime code generation\n    // since names have to be ready before diverts start getting created.\n    // (It used to be done in the constructor for a weave, but didn't allow us to generate\n    // errors when name resolution failed.)\n    this.ResolveWeavePointNaming();\n\n    // Get default implementation of runtimeObject, which calls ContainerBase's generation method\n    const rootContainer = this.runtimeObject as RuntimeContainer;\n\n    // Export initialisation of global variables\n    // TODO: We *could* add this as a declarative block to the story itself...\n    const variableInitialisation = new RuntimeContainer();\n    variableInitialisation.AddContent(RuntimeControlCommand.EvalStart());\n\n    // Global variables are those that are local to the story and marked as global\n    const runtimeLists = [];\n    for (const [key, value] of this.variableDeclarations) {\n      if (value.isGlobalDeclaration) {\n        if (value.listDefinition) {\n          this._listDefs.set(key, value.listDefinition);\n          variableInitialisation.AddContent(\n            value.listDefinition.runtimeObject!\n          );\n\n          runtimeLists.push(value.listDefinition.runtimeListDefinition);\n        } else {\n          if (!value.expression) {\n            throw new Error();\n          }\n          value.expression.GenerateIntoContainer(variableInitialisation);\n        }\n\n        const runtimeVarAss = new RuntimeVariableAssignment(key, true);\n        runtimeVarAss.isGlobal = true;\n        variableInitialisation.AddContent(runtimeVarAss);\n      }\n    }\n\n    variableInitialisation.AddContent(RuntimeControlCommand.EvalEnd());\n    variableInitialisation.AddContent(RuntimeControlCommand.End());\n\n    if (this.variableDeclarations.size > 0) {\n      variableInitialisation.name = \"global decl\";\n      rootContainer.AddToNamedContentOnly(variableInitialisation);\n    }\n\n    // Signal that it's safe to exit without error, even if there are no choices generated\n    // (this only happens at the end of top level content that isn't in any particular knot)\n    rootContainer.AddContent(RuntimeControlCommand.Done());\n\n    // Replace runtimeObject with Story object instead of the Runtime.Container generated by Parsed.ContainerBase\n    const runtimeStory = new RuntimeStory(rootContainer, runtimeLists);\n\n    this.runtimeObject = runtimeStory;\n\n    if (this.hadError) {\n      return null;\n    }\n\n    // Optimisation step - inline containers that can be\n    this.FlattenContainersIn(rootContainer);\n\n    // Now that the story has been fulled parsed into a hierarchy,\n    // and the derived runtime hierarchy has been built, we can\n    // resolve referenced symbols such as variables and paths.\n    // e.g. for paths \" -> knotName --> stitchName\" into an INKPath (knotName.stitchName)\n    // We don't make any assumptions that the INKPath follows the same\n    // conventions as the script format, so we resolve to actual objects before\n    // translating into an INKPath. (This also allows us to choose whether\n    // we want the paths to be absolute)\n    this.ResolveReferences(this);\n\n    if (this.hadError) {\n      return null;\n    }\n\n    runtimeStory.ResetState();\n\n    return runtimeStory;\n  };\n\n  public readonly ResolveList = (listName: string): ListDefinition | null => {\n    let list: ListDefinition | null | undefined = this._listDefs.get(listName);\n    if (!list) {\n      return null;\n    }\n\n    return list;\n  };\n\n  public readonly ResolveListItem = (\n    listName: string | null,\n    itemName: string,\n    source: ParsedObject | null = null\n  ): ListElementDefinition | null => {\n    let listDef: ListDefinition | null | undefined = null;\n\n    // Search a specific list if we know its name (i.e. the form listName.itemName)\n    if (listName) {\n      if (!(listDef = this._listDefs.get(listName))) {\n        return null;\n      }\n\n      return listDef.ItemNamed(itemName);\n    } else {\n      // Otherwise, try to search all lists\n\n      let foundItem: ListElementDefinition | null = null;\n      let originalFoundList: ListDefinition | null = null;\n\n      for (const [, value] of this._listDefs.entries()) {\n        const itemInThisList = value.ItemNamed(itemName);\n        if (itemInThisList) {\n          if (foundItem) {\n            this.Error(\n              `Ambiguous item name '${itemName}' found in multiple sets, including ${\n                originalFoundList!.identifier\n              } and ${value!.identifier}`,\n              source,\n              false\n            );\n          } else {\n            foundItem = itemInThisList;\n            originalFoundList = value!;\n          }\n        }\n      }\n\n      return foundItem;\n    }\n  };\n\n  public readonly FlattenContainersIn = (container: RuntimeContainer): void => {\n    // Need to create a collection to hold the inner containers\n    // because otherwise we'd end up modifying during iteration\n    const innerContainers = new Set<RuntimeContainer>();\n    if (container.content) {\n      for (const c of container.content) {\n        const innerContainer = asOrNull(c, RuntimeContainer);\n        if (innerContainer) {\n          innerContainers.add(innerContainer);\n        }\n      }\n    }\n\n    // Can't flatten the named inner containers, but we can at least\n    // iterate through their children\n    if (container.namedContent) {\n      for (const [, value] of container.namedContent) {\n        const namedInnerContainer = asOrNull(value, RuntimeContainer);\n        if (namedInnerContainer) {\n          innerContainers.add(namedInnerContainer);\n        }\n      }\n    }\n\n    for (const innerContainer of innerContainers) {\n      this.TryFlattenContainer(innerContainer);\n      this.FlattenContainersIn(innerContainer);\n    }\n  };\n\n  public readonly TryFlattenContainer = (container: RuntimeContainer): void => {\n    if (\n      (container.namedContent && container.namedContent.size > 0) ||\n      container.hasValidName ||\n      this._dontFlattenContainers.has(container)\n    ) {\n      return;\n    }\n\n    // Inline all the content in container into the parent\n    const parentContainer = asOrNull(container.parent, RuntimeContainer);\n    if (parentContainer) {\n      let contentIdx = parentContainer.content.indexOf(container);\n      parentContainer.content.splice(contentIdx, 1);\n\n      const dm = container.ownDebugMetadata;\n\n      if (container.content) {\n        for (const innerContent of container.content) {\n          innerContent.parent = null;\n          if (dm !== null && innerContent.ownDebugMetadata === null) {\n            innerContent.debugMetadata = dm;\n          }\n\n          parentContainer.InsertContent(innerContent, contentIdx);\n          contentIdx += 1;\n        }\n      }\n    }\n  };\n\n  public readonly Error = (\n    message: string,\n    source: ParsedObject | null | undefined,\n    isWarning: boolean | null | undefined\n  ) => {\n    let errorType: ErrorType = isWarning ? ErrorType.Warning : ErrorType.Error;\n\n    let sb = \"\";\n    if (source instanceof AuthorWarning) {\n      sb += \"TODO: \";\n      errorType = ErrorType.Author;\n    } else if (isWarning) {\n      sb += \"WARNING: \";\n    } else {\n      sb += \"ERROR: \";\n    }\n\n    if (\n      source &&\n      source.debugMetadata !== null &&\n      source.debugMetadata.startLineNumber >= 1\n    ) {\n      if (source.debugMetadata.fileName != null) {\n        sb += `'${source.debugMetadata.fileName}' `;\n      }\n\n      sb += `line ${source.debugMetadata.startLineNumber}: `;\n    }\n\n    sb += message;\n\n    message = sb;\n\n    if (this._errorHandler !== null) {\n      this._errorHandler(message, errorType);\n    } else {\n      throw new Error(message);\n    }\n\n    this._hadError = errorType === ErrorType.Error;\n    this._hadWarning = errorType === ErrorType.Warning;\n  };\n\n  public readonly ResetError = (): void => {\n    this._hadError = false;\n    this._hadWarning = false;\n  };\n\n  public readonly IsExternal = (namedFuncTarget: string): boolean =>\n    this.externals.has(namedFuncTarget);\n\n  public readonly AddExternal = (decl: ExternalDeclaration): void => {\n    if (this.externals.has(decl.name!)) {\n      this.Error(\n        `Duplicate EXTERNAL definition of '${decl.name}'`,\n        decl,\n        false\n      );\n    } else if (decl.name) {\n      this.externals.set(decl.name, decl);\n    }\n  };\n\n  public readonly DontFlattenContainer = (\n    container: RuntimeContainer\n  ): void => {\n    this._dontFlattenContainers.add(container);\n  };\n\n  public readonly NameConflictError = (\n    obj: ParsedObject,\n    name: string,\n    existingObj: ParsedObject,\n    typeNameToPrint: string\n  ): void => {\n    obj.Error(\n      `${typeNameToPrint} '${name}': name has already been used for a ${existingObj.typeName.toLowerCase()} on ${\n        existingObj.debugMetadata\n      }`\n    );\n  };\n\n  // Check given symbol type against everything that's of a higher priority in the ordered SymbolType enum (above).\n  // When the given symbol type level is reached, we early-out / return.\n  public readonly CheckForNamingCollisions = (\n    obj: ParsedObject,\n    identifier: Identifier,\n    symbolType: SymbolType,\n    typeNameOverride: string = \"\"\n  ): void => {\n    const typeNameToPrint: string = typeNameOverride || obj.typeName;\n    if (Story.IsReservedKeyword(identifier?.name)) {\n      obj.Error(\n        `'${identifier}' cannot be used for the name of a ${typeNameToPrint.toLowerCase()} because it's a reserved keyword`\n      );\n      return;\n    } else if (FunctionCall.IsBuiltIn(identifier?.name || \"\")) {\n      obj.Error(\n        `'${identifier}' cannot be used for the name of a ${typeNameToPrint.toLowerCase()} because it's a built in function`\n      );\n\n      return;\n    }\n\n    // Top level knots\n    const maybeKnotOrFunction = this.ContentWithNameAtLevel(\n      identifier?.name || \"\",\n      FlowLevel.Knot\n    );\n\n    const knotOrFunction = asOrNull(maybeKnotOrFunction, FlowBase);\n\n    if (\n      knotOrFunction &&\n      (knotOrFunction !== obj || symbolType === SymbolType.Arg)\n    ) {\n      this.NameConflictError(\n        obj,\n        identifier?.name || \"\",\n        knotOrFunction,\n        typeNameToPrint\n      );\n      return;\n    }\n\n    if (symbolType < SymbolType.List) {\n      return;\n    }\n\n    // Lists\n    for (const [key, value] of this._listDefs) {\n      if (\n        identifier?.name === key &&\n        obj !== value &&\n        value.variableAssignment !== obj\n      ) {\n        this.NameConflictError(obj, identifier?.name, value, typeNameToPrint);\n      }\n\n      // We don't check for conflicts between individual elements in\n      // different lists because they are namespaced.\n      if (!(obj instanceof ListElementDefinition)) {\n        for (const item of value.itemDefinitions) {\n          if (identifier?.name === item.name) {\n            this.NameConflictError(\n              obj,\n              identifier?.name || \"\",\n              item,\n              typeNameToPrint\n            );\n          }\n        }\n      }\n    }\n\n    // Don't check for VAR->VAR conflicts because that's handled separately\n    // (necessary since checking looks up in a dictionary)\n    if (symbolType <= SymbolType.Var) {\n      return;\n    }\n\n    // Global variable collision\n    const varDecl: VariableAssignment | null =\n      (identifier?.name && this.variableDeclarations.get(identifier?.name)) ||\n      null;\n    if (\n      varDecl &&\n      varDecl !== obj &&\n      varDecl.isGlobalDeclaration &&\n      varDecl.listDefinition == null\n    ) {\n      this.NameConflictError(\n        obj,\n        identifier?.name || \"\",\n        varDecl,\n        typeNameToPrint\n      );\n    }\n\n    if (symbolType < SymbolType.SubFlowAndWeave) {\n      return;\n    }\n\n    // Stitches, Choices and Gathers\n    const path = new Path(identifier);\n    const targetContent = path.ResolveFromContext(obj);\n    if (targetContent && targetContent !== obj) {\n      this.NameConflictError(\n        obj,\n        identifier?.name || \"\",\n        targetContent,\n        typeNameToPrint\n      );\n      return;\n    }\n\n    if (symbolType < SymbolType.Arg) {\n      return;\n    }\n\n    // Arguments to the current flow\n    if (symbolType !== SymbolType.Arg) {\n      let flow: FlowBase | null = asOrNull(obj, FlowBase);\n      if (!flow) {\n        flow = ClosestFlowBase(obj);\n      }\n\n      if (flow && flow.hasParameters && flow.args) {\n        for (const arg of flow.args) {\n          if (arg.identifier?.name === identifier?.name) {\n            obj.Error(\n              `${typeNameToPrint} '${identifier}': name has already been used for a argument to ${flow.identifier} on ${flow.debugMetadata}`\n            );\n\n            return;\n          }\n        }\n      }\n    }\n  };\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../../engine/ControlCommand\";\nimport { Expression } from \"./Expression\";\nimport { ParsedObject } from \"../Object\";\nimport { Text } from \"../Text\";\nimport { asOrNull } from \"../../../../engine/TypeAssertion\";\n\nexport class StringExpression extends Expression {\n  get isSingleString() {\n    if (this.content.length !== 1) {\n      return false;\n    }\n\n    const c = this.content[0];\n    if (!(c instanceof Text)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  constructor(content: ParsedObject[]) {\n    super();\n\n    this.AddContent(content);\n  }\n\n  get typeName(): string {\n    return \"String\";\n  }\n\n  public readonly GenerateIntoContainer = (\n    container: RuntimeContainer\n  ): void => {\n    container.AddContent(RuntimeControlCommand.BeginString());\n\n    for (const c of this.content) {\n      container.AddContent(c.runtimeObject);\n    }\n\n    container.AddContent(RuntimeControlCommand.EndString());\n  };\n\n  public readonly toString = (): string => {\n    let sb = \"\";\n    for (const c of this.content) {\n      sb += c;\n    }\n\n    return sb;\n  };\n\n  // Equals override necessary in order to check for CONST multiple definition equality\n  public Equals(obj: ParsedObject): boolean {\n    const otherStr = asOrNull(obj, StringExpression);\n    if (otherStr === null) {\n      return false;\n    }\n\n    // Can only compare direct equality on single strings rather than\n    // complex string expressions that contain dynamic logic\n    if (!this.isSingleString || !otherStr.isSingleString) {\n      return false;\n    }\n\n    const thisTxt = this.toString();\n    const otherTxt = otherStr.toString();\n    return thisTxt === otherTxt;\n  }\n}\n","import { ParsedObject } from \"./Object\";\nimport { ControlCommand } from \"../../../engine/ControlCommand\";\nimport { InkObject as RuntimeObject } from \"../../../engine/Object\";\n\nexport class Tag extends ParsedObject {\n  public isStart: boolean;\n  public inChoice: boolean;\n\n  constructor(isStart: boolean, inChoice: boolean = false) {\n    super();\n    this.isStart = isStart;\n    this.inChoice = inChoice;\n  }\n  get typeName(): string {\n    return \"Tag\";\n  }\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    if (this.isStart) {\n      return ControlCommand.BeginTag();\n    } else {\n      return ControlCommand.EndTag();\n    }\n  };\n\n  public readonly toString = () => {\n    if (this.isStart) {\n      return \"#StartTag\";\n    } else {\n      return \"#EndTag\";\n    }\n  };\n}\n\nimport { Tag as RuntimeTag } from \"../../../engine/Tag\";\nimport { Wrap } from \"./Wrap\";\nexport class LegacyTag extends Wrap<RuntimeTag> {\n  constructor(tag: RuntimeTag) {\n    super(tag);\n  }\n  get typeName(): string {\n    return \"Tag\";\n  }\n}\n","import { IFileHandler } from \"../IFileHandler\";\n\n// This class replaces upstream's DefaultFileHandler. It doesn't perform any\n// resolution and warns the user about providing a proper file handler when\n// INCLUDE statements are parsed. Since the JavaScript parser can be executed in\n// different environments, we let the user decide which FileHandler is best for\n// their use-case. See PosixFileHandler and JsonFileHandler.\nexport class DefaultFileHandler implements IFileHandler {\n  constructor(public readonly rootPath?: string) {}\n\n  readonly ResolveInkFilename = (): string => {\n    throw Error(\n      \"Can't resolve filename because no FileHandler was provided when instantiating the parser / compiler.\"\n    );\n  };\n\n  readonly LoadInkFileContents = (): string => {\n    throw Error(\n      \"Can't load ink content because no FileHandler was provided when instantiating the parser / compiler.\"\n    );\n  };\n}\n","import { Argument } from \"./ParsedHierarchy/Argument\";\nimport { AuthorWarning } from \"./ParsedHierarchy/AuthorWarning\";\nimport { BinaryExpression } from \"./ParsedHierarchy/Expression/BinaryExpression\";\nimport { CharacterRange } from \"./CharacterRange\";\nimport { CharacterSet } from \"./CharacterSet\";\nimport { Choice } from \"./ParsedHierarchy/Choice\";\nimport { CommentEliminator } from \"./CommentEliminator\";\nimport { Conditional } from \"./ParsedHierarchy/Conditional/Conditional\";\nimport { ConditionalSingleBranch } from \"./ParsedHierarchy/Conditional/ConditionalSingleBranch\";\nimport { ContentList } from \"./ParsedHierarchy/ContentList\";\nimport { ConstantDeclaration } from \"./ParsedHierarchy/Declaration/ConstantDeclaration\";\nimport { CustomFlags } from \"./CustomFlags\";\nimport { DebugMetadata } from \"../../engine/DebugMetadata\";\nimport { Divert } from \"./ParsedHierarchy/Divert/Divert\";\nimport { DivertTarget } from \"./ParsedHierarchy/Divert/DivertTarget\";\nimport { Expression } from \"./ParsedHierarchy/Expression/Expression\";\nimport { ErrorHandler } from \"../../engine/Error\";\nimport { ExternalDeclaration } from \"./ParsedHierarchy/Declaration/ExternalDeclaration\";\nimport { FlowDecl } from \"./FlowDecl\";\nimport { FunctionCall } from \"./ParsedHierarchy/FunctionCall\";\nimport { Gather } from \"./ParsedHierarchy/Gather/Gather\";\nimport { Glue } from \"./ParsedHierarchy/Glue\";\nimport { Glue as RuntimeGlue } from \"../../engine/Glue\";\nimport { IFileHandler } from \"../IFileHandler\";\nimport { IncDecExpression } from \"./ParsedHierarchy/Expression/IncDecExpression\";\nimport { IncludedFile } from \"./ParsedHierarchy/IncludedFile\";\nimport { InfixOperator } from \"./InfixOperator\";\nimport { Knot } from \"./ParsedHierarchy/Knot\";\nimport { List } from \"./ParsedHierarchy/List/List\";\nimport { ListDefinition } from \"./ParsedHierarchy/List/ListDefinition\";\nimport { ListElementDefinition } from \"./ParsedHierarchy/List/ListElementDefinition\";\nimport { MultipleConditionExpression } from \"./ParsedHierarchy/Expression/MultipleConditionExpression\";\nimport { ParsedObject } from \"./ParsedHierarchy/Object\";\nimport { Path } from \"./ParsedHierarchy/Path\";\nimport { ReturnType } from \"./ParsedHierarchy/ReturnType\";\nimport { Sequence } from \"./ParsedHierarchy/Sequence/Sequence\";\nimport { SequenceType } from \"./ParsedHierarchy/Sequence/SequenceType\";\nimport { StatementLevel } from \"./StatementLevel\";\nimport { Stitch } from \"./ParsedHierarchy/Stitch\";\nimport { Story } from \"./ParsedHierarchy/Story\";\nimport { StringExpression } from \"./ParsedHierarchy/Expression/StringExpression\";\nimport {\n  StringParser,\n  SpecificParseRule,\n  ParseRule,\n  ParseRuleReturn,\n  ParseSuccess,\n} from \"./StringParser/StringParser\";\nimport { StringParserElement } from \"./StringParser/StringParserElement\";\nimport { Tag } from \"./ParsedHierarchy/Tag\";\nimport { Text } from \"./ParsedHierarchy/Text\";\nimport { TunnelOnwards } from \"./ParsedHierarchy/TunnelOnwards\";\nimport { VariableAssignment } from \"./ParsedHierarchy/Variable/VariableAssignment\";\nimport { VariableReference } from \"./ParsedHierarchy/Variable/VariableReference\";\nimport { UnaryExpression } from \"./ParsedHierarchy/Expression/UnaryExpression\";\nimport { asOrNull, filterUndef } from \"../../engine/TypeAssertion\";\nimport { Identifier } from \"./ParsedHierarchy/Identifier\";\nimport { NumberExpression } from \"./ParsedHierarchy/Expression/NumberExpression\";\nimport { ErrorType } from \"./ErrorType\";\nimport { DefaultFileHandler } from \"../FileHandler/DefaultFileHandler\";\n\nexport class InkParser extends StringParser {\n  /**\n   * Begin base InkParser section.\n   */\n\n  get fileHandler(): IFileHandler {\n    if (!this._fileHandler) {\n      throw new Error(\"No FileHandler defined\");\n    }\n    return this._fileHandler;\n  }\n\n  set fileHandler(value: IFileHandler) {\n    this._fileHandler = value;\n  }\n\n  constructor(\n    str: string,\n    filename: string | null = null,\n    externalErrorHandler: ErrorHandler | null = null,\n    rootParser: InkParser | null = null,\n    fileHandler: IFileHandler | null = null\n  ) {\n    super(str);\n\n    this._filename = filename;\n    this.RegisterExpressionOperators();\n    this.GenerateStatementLevelRules();\n\n    this.errorHandler = this.OnStringParserError;\n\n    this._externalErrorHandler = externalErrorHandler;\n\n    if (fileHandler === null) {\n      this._fileHandler = new DefaultFileHandler();\n    } else {\n      this._fileHandler = fileHandler;\n    }\n\n    if (rootParser === null) {\n      this._rootParser = this;\n      this._openFilenames = [];\n\n      if (this._filename !== null) {\n        const fullRootInkPath = this.fileHandler.ResolveInkFilename(\n          this._filename\n        );\n        this._openFilenames.push(fullRootInkPath);\n      }\n    } else {\n      this._rootParser = rootParser;\n    }\n  }\n\n  // Main entry point\n  // NOTE: This method is named Parse() in upstream.\n  public readonly ParseStory = (): Story => {\n    const topLevelContent: ParsedObject[] = this.StatementsAtLevel(\n      StatementLevel.Top\n    );\n\n    // Note we used to return null if there were any errors, but this would mean\n    // that include files would return completely empty rather than attempting to\n    // continue with errors. Returning an empty include files meant that anything\n    // that *did* compile successfully would otherwise be ignored, generating way\n    // more errors than necessary.\n    return new Story(topLevelContent, this._rootParser !== this);\n  };\n\n  public readonly SeparatedList = <T extends ParseRule>(\n    mainRule: SpecificParseRule<T>,\n    separatorRule: ParseRule\n  ): ParseRuleReturn[] | null => {\n    const firstElement: ParseRuleReturn = this.Parse(mainRule);\n    if (firstElement === null) {\n      return null;\n    }\n\n    const allElements = [];\n    allElements.push(firstElement);\n\n    do {\n      const nextElementRuleId: number = this.BeginRule();\n      let sep = separatorRule();\n      if (sep === null) {\n        this.FailRule(nextElementRuleId);\n        break;\n      }\n\n      const nextElement = this.Parse(mainRule);\n      if (nextElement === null) {\n        this.FailRule(nextElementRuleId);\n        break;\n      }\n\n      this.SucceedRule(nextElementRuleId);\n      allElements.push(nextElement);\n    } while (true);\n\n    return allElements;\n  };\n\n  public PreProcessInputString(str: string): string {\n    const commentEliminator = new CommentEliminator(str);\n    return commentEliminator.Process();\n  }\n\n  public readonly CreateDebugMetadata = (\n    stateAtStart: StringParserElement | null,\n    stateAtEnd: StringParserElement\n  ): DebugMetadata => {\n    const md = new DebugMetadata();\n    md.startLineNumber = (stateAtStart?.lineIndex || 0) + 1;\n    md.endLineNumber = stateAtEnd.lineIndex + 1;\n    md.startCharacterNumber = (stateAtStart?.characterInLineIndex || 0) + 1;\n    md.endCharacterNumber = stateAtEnd.characterInLineIndex + 1;\n    md.fileName = this._filename;\n\n    return md;\n  };\n\n  public readonly RuleDidSucceed = (\n    result: ParseRuleReturn,\n    stateAtStart: StringParserElement | null,\n    stateAtEnd: StringParserElement\n  ): void => {\n    // Apply DebugMetadata based on the state at the start of the rule\n    // (i.e. use line number as it was at the start of the rule)\n    const parsedObj = asOrNull(result, ParsedObject);\n    if (parsedObj) {\n      parsedObj.debugMetadata = this.CreateDebugMetadata(\n        stateAtStart,\n        stateAtEnd\n      );\n    }\n\n    // A list of objects that doesn't already have metadata?\n    const parsedListObjs: ParsedObject[] | null = Array.isArray(result)\n      ? (result as ParsedObject[])\n      : null;\n    if (parsedListObjs !== null) {\n      for (const parsedListObj of parsedListObjs) {\n        const singleObj = asOrNull(parsedListObj, ParsedObject);\n        if (!singleObj) continue;\n        if (!parsedListObj.hasOwnDebugMetadata) {\n          parsedListObj.debugMetadata = this.CreateDebugMetadata(\n            stateAtStart,\n            stateAtEnd\n          );\n        }\n      }\n    }\n\n    const id = asOrNull(result, Identifier);\n    if (id != null) {\n      id.debugMetadata = this.CreateDebugMetadata(stateAtStart, stateAtEnd);\n    }\n  };\n\n  get parsingStringExpression(): boolean {\n    return this.GetFlag(Number(CustomFlags.ParsingString));\n  }\n\n  set parsingStringExpression(value: boolean) {\n    this.SetFlag(Number(CustomFlags.ParsingString), value);\n  }\n\n  get tagActive(): boolean {\n    return this.GetFlag(Number(CustomFlags.TagActive));\n  }\n\n  set tagActive(value: boolean) {\n    this.SetFlag(Number(CustomFlags.TagActive), value);\n  }\n\n  public readonly OnStringParserError = (\n    message: string,\n    index: number,\n    lineIndex: number = 0,\n    isWarning: boolean = false\n  ): void => {\n    const warningType: string = isWarning ? \"WARNING:\" : \"ERROR:\";\n    let fullMessage: string = warningType;\n\n    if (this._filename !== null) {\n      fullMessage += ` '${this._filename}'`;\n    }\n\n    fullMessage += ` line ${lineIndex + 1}: ${message}`;\n\n    if (this._externalErrorHandler !== null) {\n      this._externalErrorHandler(\n        fullMessage,\n        isWarning ? ErrorType.Warning : ErrorType.Error\n      );\n    } else {\n      throw new Error(fullMessage);\n    }\n  };\n\n  public readonly AuthorWarning = (): AuthorWarning | null => {\n    this.Whitespace();\n\n    const identifier = this.Parse(\n      this.IdentifierWithMetadata\n    ) as unknown as Identifier | null;\n    if (identifier === null || identifier.name !== \"TODO\") {\n      return null;\n    }\n\n    this.Whitespace();\n    this.ParseString(\":\");\n    this.Whitespace();\n\n    const message = this.ParseUntilCharactersFromString(\"\\n\\r\");\n\n    if (message) {\n      return new AuthorWarning(message);\n    }\n\n    return null;\n  };\n\n  /**\n   * End base InkParser section.\n   */\n\n  /**\n   * Begin CharacterRanges section.\n   */\n\n  public static readonly LatinBasic: CharacterRange = CharacterRange.Define(\n    \"\\u0041\",\n    \"\\u007A\",\n    new CharacterSet().AddRange(\"\\u005B\", \"\\u0060\")\n  );\n\n  public static readonly LatinExtendedA: CharacterRange = CharacterRange.Define(\n    \"\\u0100\",\n    \"\\u017F\"\n    // no excludes here\n  );\n\n  public static readonly LatinExtendedB: CharacterRange = CharacterRange.Define(\n    \"\\u0180\",\n    \"\\u024F\"\n    // no excludes here\n  );\n\n  public static readonly Greek: CharacterRange = CharacterRange.Define(\n    \"\\u0370\",\n    \"\\u03FF\",\n    new CharacterSet()\n      .AddRange(\"\\u0378\", \"\\u0385\")\n      .AddCharacters(\"\\u0374\\u0375\\u0378\\u0387\\u038B\\u038D\\u03A2\")\n  );\n\n  public static readonly Cyrillic: CharacterRange = CharacterRange.Define(\n    \"\\u0400\",\n    \"\\u04FF\",\n    new CharacterSet().AddRange(\"\\u0482\", \"\\u0489\")\n  );\n\n  public static readonly Armenian: CharacterRange = CharacterRange.Define(\n    \"\\u0530\",\n    \"\\u058F\",\n    new CharacterSet()\n      .AddCharacters(\"\\u0530\")\n      .AddRange(\"\\u0557\", \"\\u0560\")\n      .AddRange(\"\\u0588\", \"\\u058E\")\n  );\n\n  public static readonly Hebrew: CharacterRange = CharacterRange.Define(\n    \"\\u0590\",\n    \"\\u05FF\",\n    new CharacterSet()\n  );\n\n  public static readonly Arabic: CharacterRange = CharacterRange.Define(\n    \"\\u0600\",\n    \"\\u06FF\",\n    new CharacterSet()\n  );\n\n  public static readonly Korean: CharacterRange = CharacterRange.Define(\n    \"\\uAC00\",\n    \"\\uD7AF\",\n    new CharacterSet()\n  );\n\n  private readonly ExtendIdentifierCharacterRanges = (\n    identifierCharSet: CharacterSet\n  ): void => {\n    const characterRanges = InkParser.ListAllCharacterRanges();\n    for (const charRange of characterRanges) {\n      identifierCharSet.AddCharacters(charRange.ToCharacterSet());\n    }\n  };\n\n  /// <summary>\n  /// Gets an array of <see cref=\"CharacterRange\" /> representing all of the currently supported\n  /// non-ASCII character ranges that can be used in identifier names.\n  /// </summary>\n  /// <returns>\n  /// An array of <see cref=\"CharacterRange\" /> representing all of the currently supported\n  /// non-ASCII character ranges that can be used in identifier names.\n  /// </returns>\n  public static readonly ListAllCharacterRanges = (): CharacterRange[] => [\n    InkParser.LatinBasic,\n    InkParser.LatinExtendedA,\n    InkParser.LatinExtendedB,\n    InkParser.Arabic,\n    InkParser.Armenian,\n    InkParser.Cyrillic,\n    InkParser.Greek,\n    InkParser.Hebrew,\n    InkParser.Korean,\n  ];\n\n  /**\n   * End CharacterRanges section.\n   */\n\n  /**\n   * Begin Choices section.\n   */\n\n  public _parsingChoice: boolean = false;\n\n  public readonly Choice = (): Choice | null => {\n    let onceOnlyChoice: boolean = true;\n    let bullets = this.Interleave<string>(\n      this.OptionalExclude(this.Whitespace),\n      this.String(\"*\")\n    );\n\n    if (!bullets) {\n      bullets = this.Interleave<string>(\n        this.OptionalExclude(this.Whitespace),\n        this.String(\"+\")\n      );\n\n      if (bullets === null) {\n        return null;\n      }\n\n      onceOnlyChoice = false;\n    }\n\n    // Optional name for the choice\n    const optionalName: Identifier = this.Parse(\n      this.BracketedName\n    ) as Identifier;\n\n    this.Whitespace();\n\n    // Optional condition for whether the choice should be shown to the player\n    const conditionExpr: Expression = this.Parse(\n      this.ChoiceCondition\n    ) as Expression;\n\n    this.Whitespace();\n\n    // Ordinarily we avoid parser state variables like these, since\n    // nesting would require us to store them in a stack. But since you should\n    // never be able to nest choices within choice content, it's fine here.\n    if (this._parsingChoice) {\n      throw new Error(\n        \"Already parsing a choice - shouldn't have nested choices\"\n      );\n    }\n\n    this._parsingChoice = true;\n\n    let startContent: ContentList | null = null;\n    const startTextAndLogic = this.Parse(\n      this.MixedTextAndLogic\n    ) as ParsedObject[];\n    if (startTextAndLogic) {\n      startContent = new ContentList(startTextAndLogic);\n    }\n\n    let optionOnlyContent: ContentList | null = null;\n    let innerContent: ContentList | null = null;\n\n    // Check for a the weave style format:\n    //   * \"Hello[.\"],\" he said.\n    const hasWeaveStyleInlineBrackets: boolean = this.ParseString(\"[\") !== null;\n    if (hasWeaveStyleInlineBrackets) {\n      this.EndTagIfNecessary(startContent);\n\n      const optionOnlyTextAndLogic = this.Parse(\n        this.MixedTextAndLogic\n      ) as ParsedObject[];\n\n      if (optionOnlyTextAndLogic !== null) {\n        optionOnlyContent = new ContentList(optionOnlyTextAndLogic);\n      }\n\n      this.Expect(this.String(\"]\"), \"closing ']' for weave-style option\");\n\n      this.EndTagIfNecessary(optionOnlyContent);\n\n      let innerTextAndLogic = this.Parse(\n        this.MixedTextAndLogic\n      ) as ParsedObject[];\n      if (innerTextAndLogic !== null) {\n        innerContent = new ContentList(innerTextAndLogic);\n      }\n    }\n\n    this.Whitespace();\n\n    this.EndTagIfNecessary(innerContent ?? startContent);\n\n    // Finally, now we know we're at the end of the main choice body, parse\n    // any diverts separately.\n    const diverts: ParsedObject[] = this.Parse(\n      this.MultiDivert\n    ) as ParsedObject[];\n\n    this._parsingChoice = false;\n\n    this.Whitespace();\n\n    // Completely empty choice without even an empty divert?\n    const emptyContent: boolean =\n      !startContent && !innerContent && !optionOnlyContent;\n\n    if (emptyContent && diverts === null) {\n      this.Warning(\n        \"Choice is completely empty. Interpretting as a default fallback choice. Add a divert arrow to remove this warning: * ->\"\n      );\n    }\n\n    if (!startContent && hasWeaveStyleInlineBrackets && !optionOnlyContent) {\n      // * [] some text\n      this.Warning(\n        \"Blank choice - if you intended a default fallback choice, use the `* ->` syntax\"\n      );\n    }\n\n    if (!innerContent) {\n      innerContent = new ContentList();\n    }\n\n    this.EndTagIfNecessary(innerContent);\n\n    // Normal diverts on the end of a choice - simply add to the normal content\n    if (diverts !== null) {\n      for (const divObj of diverts) {\n        // may be TunnelOnwards\n        const div = asOrNull(divObj, Divert);\n\n        // Empty divert serves no purpose other than to say\n        // \"this choice is intentionally left blank\"\n        // (as an invisible default choice)\n        if (div && div.isEmpty) {\n          continue;\n        }\n\n        innerContent.AddContent(divObj);\n      }\n    }\n\n    // Terminate main content with a newline since this is the end of the line\n    // Note that this will be redundant if the diverts above definitely take\n    // the flow away permanently.\n    innerContent.AddContent(new Text(\"\\n\"));\n\n    const choice = new Choice(startContent!, optionOnlyContent!, innerContent);\n    if (optionalName) choice.identifier = optionalName;\n    choice.indentationDepth = bullets.length;\n    choice.hasWeaveStyleInlineBrackets = hasWeaveStyleInlineBrackets;\n    choice.condition = conditionExpr;\n    choice.onceOnly = onceOnlyChoice;\n    choice.isInvisibleDefault = emptyContent;\n    return choice;\n  };\n\n  public readonly ChoiceCondition = (): Expression | null => {\n    const conditions = this.Interleave<Expression>(\n      this.ChoiceSingleCondition,\n      this.ChoiceConditionsSpace\n    );\n\n    if (conditions === null) {\n      return null;\n    } else if (conditions.length === 1) {\n      return conditions[0];\n    }\n\n    return new MultipleConditionExpression(conditions);\n  };\n\n  public readonly ChoiceConditionsSpace = (): typeof ParseSuccess => {\n    // Both optional\n    // Newline includes initial end of line whitespace\n    this.Newline();\n    this.Whitespace();\n\n    return ParseSuccess;\n  };\n\n  public readonly ChoiceSingleCondition = (): Expression | null => {\n    if (this.ParseString(\"{\") === null) {\n      return null;\n    }\n\n    const condExpr = this.Expect(\n      this.Expression,\n      \"choice condition inside { }\"\n    ) as Expression;\n\n    this.DisallowIncrement(condExpr);\n    this.Expect(this.String(\"}\"), \"closing '}' for choice condition\");\n\n    return condExpr;\n  };\n\n  public readonly Gather = (): Gather | null => {\n    const gatherDashCountObj: number = this.Parse(this.GatherDashes) as number;\n    if (gatherDashCountObj === null) {\n      return null;\n    }\n\n    const gatherDashCount: number = Number(gatherDashCountObj);\n\n    // Optional name for the gather\n    const optionalName: Identifier = this.Parse(\n      this.BracketedName\n    ) as Identifier;\n\n    const gather = new Gather(optionalName, gatherDashCount);\n\n    // Optional newline before gather's content begins\n    this.Newline();\n\n    return gather;\n  };\n\n  public readonly GatherDashes = (): number | null => {\n    this.Whitespace();\n\n    let gatherDashCount: number = 0;\n    while (this.ParseDashNotArrow() !== null) {\n      gatherDashCount += 1;\n      this.Whitespace();\n    }\n\n    if (gatherDashCount === 0) {\n      return null;\n    }\n\n    return gatherDashCount as number;\n  };\n\n  public readonly ParseDashNotArrow = () => {\n    const ruleId = this.BeginRule();\n\n    if (\n      this.ParseString(\"->\") === null &&\n      this.ParseSingleCharacter() === \"-\"\n    ) {\n      return this.SucceedRule(ruleId);\n    }\n\n    return this.FailRule(ruleId);\n  };\n\n  public readonly BracketedName = (): Identifier | null => {\n    if (this.ParseString(\"(\") === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const name = this.Parse(this.IdentifierWithMetadata) as Identifier | null;\n    if (name === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    this.Expect(this.String(\")\"), \"closing ')' for bracketed name\");\n\n    return name;\n  };\n\n  /**\n   * End Choices section.\n   */\n\n  /**\n   * Begin Conditional section.\n   */\n\n  public readonly InnerConditionalContent = (\n    initialQueryExpression: Expression\n  ): Conditional | null => {\n    if (initialQueryExpression === undefined) {\n      const initialQueryExpression = this.Parse(this.ConditionExpression);\n      const conditional = this.Parse(() =>\n        this.InnerConditionalContent(initialQueryExpression as Expression)\n      ) as Conditional;\n\n      if (conditional === null) {\n        return null;\n      }\n\n      return conditional;\n    }\n\n    let alternatives: ConditionalSingleBranch[] | null;\n    const canBeInline: boolean = initialQueryExpression !== null;\n    const isInline: boolean = this.Parse(this.Newline) === null;\n\n    if (isInline && !canBeInline) {\n      return null;\n    }\n\n    if (isInline) {\n      // Inline innards\n      alternatives = this.InlineConditionalBranches();\n    } else {\n      // Multiline innards\n      alternatives = this.MultilineConditionalBranches();\n\n      if (alternatives === null) {\n        // Allow single piece of content within multi-line expression, e.g.:\n        // { true:\n        //    Some content that isn't preceded by '-'\n        // }\n        if (initialQueryExpression) {\n          let soleContent: ParsedObject[] = this.StatementsAtLevel(\n            StatementLevel.InnerBlock\n          );\n          if (soleContent !== null) {\n            const soleBranch = new ConditionalSingleBranch(soleContent);\n            alternatives = [soleBranch];\n\n            // Also allow a final \"- else:\" clause\n            const elseBranch = this.Parse(\n              this.SingleMultilineCondition\n            ) as ConditionalSingleBranch;\n            if (elseBranch) {\n              if (!elseBranch.isElse) {\n                this.ErrorWithParsedObject(\n                  \"Expected an '- else:' clause here rather than an extra condition\",\n                  elseBranch\n                );\n\n                elseBranch.isElse = true;\n              }\n\n              alternatives.push(elseBranch);\n            }\n          }\n        }\n\n        // Still null?\n        if (alternatives === null) {\n          return null;\n        }\n      } else if (\n        alternatives.length === 1 &&\n        alternatives[0].isElse &&\n        initialQueryExpression\n      ) {\n        // Empty true branch - didn't get parsed, but should insert one for semantic correctness,\n        // and to make sure that any evaluation stack values get tidied up correctly.\n        const emptyTrueBranch = new ConditionalSingleBranch(null);\n        emptyTrueBranch.isTrueBranch = true;\n        alternatives.unshift(emptyTrueBranch);\n      }\n\n      // Like a switch statement\n      // { initialQueryExpression:\n      //    ... match the expression\n      // }\n      if (initialQueryExpression) {\n        let earlierBranchesHaveOwnExpression: boolean = false;\n        for (let ii = 0; ii < alternatives.length; ++ii) {\n          const branch = alternatives[ii];\n          const isLast: boolean = ii === alternatives.length - 1;\n\n          // Matching equality with initial query expression\n          // We set this flag even for the \"else\" clause so that\n          // it knows to tidy up the evaluation stack at the end\n\n          // Match query\n          if (branch.ownExpression) {\n            branch.matchingEquality = true;\n            earlierBranchesHaveOwnExpression = true;\n          } else if (earlierBranchesHaveOwnExpression && isLast) {\n            // Else (final branch)\n            branch.matchingEquality = true;\n            branch.isElse = true;\n          } else {\n            // Binary condition:\n            // { trueOrFalse:\n            //    - when true\n            //    - when false\n            // }\n            if (!isLast && alternatives.length > 2) {\n              this.ErrorWithParsedObject(\n                \"Only final branch can be an 'else'. Did you miss a ':'?\",\n                branch\n              );\n            } else {\n              if (ii === 0) {\n                branch.isTrueBranch = true;\n              } else {\n                branch.isElse = true;\n              }\n            }\n          }\n        }\n      } else {\n        // No initial query, so just a multi-line conditional. e.g.:\n        // {\n        //   - x > 3:  greater than three\n        //   - x == 3: equal to three\n        //   - x < 3:  less than three\n        // }\n\n        for (let ii = 0; ii < alternatives.length; ++ii) {\n          const alt = alternatives[ii];\n          const isLast: boolean = ii === alternatives.length - 1;\n\n          if (alt.ownExpression === null) {\n            if (isLast) {\n              alt.isElse = true;\n            } else {\n              if (alt.isElse) {\n                // Do we ALSO have a valid \"else\" at the end? Let's report the error there.\n                const finalClause = alternatives[alternatives.length - 1];\n                if (finalClause.isElse) {\n                  this.ErrorWithParsedObject(\n                    \"Multiple 'else' cases. Can have a maximum of one, at the end.\",\n                    finalClause\n                  );\n                } else {\n                  this.ErrorWithParsedObject(\n                    \"'else' case in conditional should always be the final one\",\n                    alt\n                  );\n                }\n              } else {\n                this.ErrorWithParsedObject(\n                  \"Branch doesn't have condition. Are you missing a ':'? \",\n                  alt\n                );\n              }\n            }\n          }\n        }\n\n        if (\n          alternatives.length === 1 &&\n          alternatives[0].ownExpression === null\n        ) {\n          this.ErrorWithParsedObject(\n            \"Condition block with no conditions\",\n            alternatives[0]\n          );\n        }\n      }\n    }\n\n    // TODO: Come up with water-tight error conditions... it's quite a flexible system!\n    // e.g.\n    //   - inline conditionals must have exactly 1 or 2 alternatives\n    //   - multiline expression shouldn't have mixed existence of branch-conditions?\n    if (alternatives === null) {\n      return null;\n    }\n\n    for (const branch of alternatives) {\n      branch.isInline = isInline;\n    }\n\n    const cond = new Conditional(initialQueryExpression, alternatives);\n\n    return cond;\n  };\n\n  public readonly InlineConditionalBranches = ():\n    | ConditionalSingleBranch[]\n    | null => {\n    const listOfLists = this.Interleave<ParsedObject[]>(\n      this.MixedTextAndLogic,\n      this.Exclude(this.String(\"|\")),\n      null,\n      false\n    );\n\n    if (listOfLists === null || listOfLists.length === 0) {\n      return null;\n    }\n\n    const result: ConditionalSingleBranch[] = [];\n\n    if (listOfLists.length > 2) {\n      this.Error(\n        \"Expected one or two alternatives separated by '|' in inline conditional\"\n      );\n    } else {\n      const trueBranch = new ConditionalSingleBranch(listOfLists[0]);\n      trueBranch.isTrueBranch = true;\n      result.push(trueBranch);\n\n      if (listOfLists.length > 1) {\n        const elseBranch = new ConditionalSingleBranch(listOfLists[1]);\n        elseBranch.isElse = true;\n        result.push(elseBranch);\n      }\n    }\n\n    return result;\n  };\n\n  public readonly MultilineConditionalBranches = ():\n    | ConditionalSingleBranch[]\n    | null => {\n    this.MultilineWhitespace();\n\n    const multipleConditions = this.OneOrMore(this.SingleMultilineCondition);\n    if (multipleConditions === null) {\n      return null;\n    }\n\n    this.MultilineWhitespace();\n\n    return multipleConditions as ConditionalSingleBranch[];\n  };\n\n  public readonly SingleMultilineCondition =\n    (): ConditionalSingleBranch | null => {\n      this.Whitespace();\n\n      if (\n        // Make sure we're not accidentally parsing a divert\n        this.ParseString(\"->\") !== null ||\n        this.ParseString(\"-\") === null\n      ) {\n        return null;\n      }\n\n      this.Whitespace();\n\n      let expr: Expression | null = null;\n      const isElse: boolean = this.Parse(this.ElseExpression) !== null;\n\n      if (!isElse) {\n        expr = this.Parse(this.ConditionExpression) as Expression;\n      }\n\n      let content: ParsedObject[] = this.StatementsAtLevel(\n        StatementLevel.InnerBlock\n      );\n      if (expr === null && content === null) {\n        this.Error(\"expected content for the conditional branch following '-'\");\n\n        // Recover\n        content = [new Text(\"\")];\n      }\n\n      // Allow additional multiline whitespace, if the statements were empty (valid)\n      // then their surrounding multiline whitespacce needs to be handled manually.\n      // e.g.\n      // { x:\n      //   - 1:    // intentionally left blank, but newline needs to be parsed\n      //   - 2: etc\n      // }\n      this.MultilineWhitespace();\n\n      const branch = new ConditionalSingleBranch(content);\n      branch.ownExpression = expr;\n      branch.isElse = isElse;\n\n      return branch;\n    };\n\n  public readonly ConditionExpression = (): ParsedObject | null => {\n    const expr = this.Parse(this.Expression) as ParsedObject;\n    if (expr === null) {\n      return null;\n    }\n\n    this.DisallowIncrement(expr);\n\n    this.Whitespace();\n\n    if (this.ParseString(\":\") === null) {\n      return null;\n    }\n\n    return expr;\n  };\n\n  public readonly ElseExpression = (): typeof ParseSuccess | null => {\n    if (this.ParseString(\"else\") === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    if (this.ParseString(\":\") === null) {\n      return null;\n    }\n\n    return ParseSuccess;\n  };\n\n  /**\n   * End Conditional section.\n   */\n\n  /**\n   * Begin Content section.\n   */\n\n  public _nonTextPauseCharacters: CharacterSet | null = null;\n  public _nonTextEndCharacters: CharacterSet | null = null;\n  public _notTextEndCharactersChoice: CharacterSet | null = null;\n  public _notTextEndCharactersString: CharacterSet | null = null;\n\n  public readonly TrimEndWhitespace = (\n    mixedTextAndLogicResults: ParsedObject[],\n    terminateWithSpace: boolean\n  ): void => {\n    // Trim whitespace from end\n    if (mixedTextAndLogicResults.length > 0) {\n      const lastObjIdx = mixedTextAndLogicResults.length - 1;\n      const lastObj = mixedTextAndLogicResults[lastObjIdx];\n      if (lastObj instanceof Text) {\n        const textObj: Text = lastObj;\n        textObj.text = textObj.text.replace(new RegExp(/[ \\t]+$/g), \"\");\n\n        if (terminateWithSpace) {\n          textObj.text += \" \";\n        } else if (textObj.text.length === 0) {\n          // No content left at all? trim the whole object\n          mixedTextAndLogicResults.splice(lastObjIdx, 1);\n\n          // Recurse in case there's more whitespace\n          this.TrimEndWhitespace(mixedTextAndLogicResults, false);\n        }\n      }\n    }\n  };\n\n  public readonly LineOfMixedTextAndLogic = (): ParsedObject[] | null => {\n    // Consume any whitespace at the start of the line\n    // (Except for escaped whitespace)\n    this.Parse(this.Whitespace);\n\n    let result: ParsedObject[] = this.Parse(\n      this.MixedTextAndLogic\n    ) as ParsedObject[];\n\n    if (!result || !result.length) {\n      return null;\n    }\n\n    // Warn about accidentally writing \"return\" without \"~\"\n    const firstText = result[0] as Text;\n    if (firstText && firstText.text && firstText.text.startsWith(\"return\")) {\n      this.Warning(\n        \"Do you need a '~' before 'return'? If not, perhaps use a glue: <> (since it's lowercase) or rewrite somehow?\"\n      );\n    }\n\n    if (result.length === 0) {\n      return null;\n    }\n\n    const lastObj = result[result.length - 1];\n    if (!(lastObj instanceof Divert)) {\n      this.TrimEndWhitespace(result, false);\n    }\n\n    this.EndTagIfNecessary(result);\n\n    // If the line doens't actually contain any normal text content\n    // but is in fact entirely a tag, then let's not append\n    // a newline, since we want the tag (or tags) to be associated\n    // with the line below rather than being completely independent.\n    let lineIsPureTag =\n      result.length > 0 && result[0] instanceof Tag && result[0].isStart;\n\n    if (!lineIsPureTag) {\n      result.push(new Text(\"\\n\"));\n    }\n\n    this.Expect(this.EndOfLine, \"end of line\", this.SkipToNextLine);\n    return result;\n  };\n\n  public readonly MixedTextAndLogic = (): ParsedObject[] | null => {\n    // Check for disallowed \"~\" within this context\n    const disallowedTilde = this.ParseObject(this.Spaced(this.String(\"~\")));\n    if (disallowedTilde !== null) {\n      this.Error(\n        \"You shouldn't use a '~' here - tildas are for logic that's on its own line. To do inline logic, use { curly braces } instead\"\n      );\n    }\n\n    // Either, or both interleaved\n    let results: ParsedObject[] = this.Interleave<ParsedObject>(\n      this.Optional(this.ContentText),\n      this.Optional(this.InlineLogicOrGlueOrStartTag)\n    );\n\n    // Terminating divert?\n    // (When parsing content for the text of a choice, diverts aren't allowed.\n    //  The divert on the end of the body of a choice is handled specially.)\n    if (!this._parsingChoice) {\n      const diverts: ParsedObject[] = this.Parse(\n        this.MultiDivert\n      ) as ParsedObject[];\n      if (diverts !== null) {\n        // May not have had any results at all if there's *only* a divert!\n        if (results === null) {\n          results = [];\n        }\n\n        // End previously active tag if necessary\n        this.EndTagIfNecessary(results);\n\n        this.TrimEndWhitespace(results, true);\n\n        results.push(...diverts);\n      }\n    }\n\n    if (!results) {\n      return null;\n    }\n\n    return results;\n  };\n\n  public readonly ContentText = () => {\n    return this.ContentTextAllowingEscapeChar();\n  };\n\n  public readonly ContentTextAllowingEscapeChar = (): Text | null => {\n    let sb: string | null = null;\n\n    do {\n      let str = this.Parse(this.ContentTextNoEscape);\n      const gotEscapeChar: boolean = this.ParseString(\"\\\\\") !== null;\n\n      if (gotEscapeChar || str !== null) {\n        if (sb === null) {\n          sb = \"\";\n        }\n\n        if (str !== null) {\n          sb += String(str);\n        }\n\n        if (gotEscapeChar) {\n          const c: string = this.ParseSingleCharacter();\n          sb += c;\n        }\n      } else {\n        break;\n      }\n    } while (true);\n\n    if (sb !== null) {\n      return new Text(sb);\n    }\n\n    return null;\n  };\n\n  // Content text is an unusual parse rule compared with most since it's\n  // less about saying \"this is is the small selection of stuff that we parse\"\n  // and more \"we parse ANYTHING except this small selection of stuff\".\n  public readonly ContentTextNoEscape = (): string | null => {\n    // Eat through text, pausing at the following characters, and\n    // attempt to parse the nonTextRule.\n    // \"-\": possible start of divert or start of gather\n    // \"<\": possible start of glue\n    if (this._nonTextPauseCharacters === null) {\n      this._nonTextPauseCharacters = new CharacterSet(\"-<\");\n    }\n\n    // If we hit any of these characters, we stop *immediately* without bothering to even check the nonTextRule\n    // \"{\" for start of logic\n    // \"|\" for mid logic branch\n    if (this._nonTextEndCharacters === null) {\n      this._nonTextEndCharacters = new CharacterSet(\"{}|\\n\\r\\\\#\");\n      this._notTextEndCharactersChoice = new CharacterSet(\n        this._nonTextEndCharacters\n      );\n      this._notTextEndCharactersChoice.AddCharacters(\"[]\");\n      this._notTextEndCharactersString = new CharacterSet(\n        this._nonTextEndCharacters\n      );\n      this._notTextEndCharactersString.AddCharacters('\"');\n    }\n\n    // When the ParseUntil pauses, check these rules in case they evaluate successfully\n    const nonTextRule: ParseRule = () =>\n      this.OneOf([\n        this.ParseDivertArrow,\n        this.ParseThreadArrow,\n        this.EndOfLine,\n        this.Glue,\n      ]);\n\n    let endChars: CharacterSet | null = null;\n    if (this.parsingStringExpression) {\n      endChars = this._notTextEndCharactersString;\n    } else if (this._parsingChoice) {\n      endChars = this._notTextEndCharactersChoice;\n    } else {\n      endChars = this._nonTextEndCharacters;\n    }\n\n    const pureTextContent: string = this.ParseUntil(\n      nonTextRule,\n      this._nonTextPauseCharacters,\n      endChars\n    );\n\n    if (pureTextContent !== null) {\n      return pureTextContent;\n    }\n\n    return null;\n  };\n\n  /**\n   * End Content section.\n   */\n\n  /**\n   * Begin Divert section.\n   */\n\n  public readonly MultiDivert = (): ParsedObject[] | null => {\n    this.Whitespace();\n\n    let diverts: ParsedObject[] = [];\n\n    // Try single thread first\n    const threadDivert = this.Parse(this.StartThread) as ParsedObject;\n    if (threadDivert) {\n      diverts = [threadDivert];\n\n      return diverts;\n    }\n\n    // Normal diverts and tunnels\n    const arrowsAndDiverts = this.Interleave<ParsedObject>(\n      this.ParseDivertArrowOrTunnelOnwards,\n      this.DivertIdentifierWithArguments\n    );\n\n    if (!arrowsAndDiverts) {\n      return null;\n    }\n\n    diverts = [];\n\n    this.EndTagIfNecessary(diverts);\n\n    // Possible patterns:\n    //  ->                   -- explicit gather\n    //  ->->                 -- tunnel onwards\n    //  -> div               -- normal divert\n    //  ->-> div             -- tunnel onwards, followed by override divert\n    //  -> div ->            -- normal tunnel\n    //  -> div ->->          -- tunnel then tunnel continue\n    //  -> div -> div        -- tunnel then divert\n    //  -> div -> div ->     -- tunnel then tunnel\n    //  -> div -> div ->->\n    //  -> div -> div ->-> div    (etc)\n\n    // Look at the arrows and diverts\n    for (let ii = 0; ii < arrowsAndDiverts.length; ++ii) {\n      const isArrow: boolean = ii % 2 === 0;\n\n      // Arrow string\n      if (isArrow) {\n        // Tunnel onwards\n        if ((arrowsAndDiverts[ii] as any) === \"->->\") {\n          const tunnelOnwardsPlacementValid: boolean =\n            ii === 0 ||\n            ii === arrowsAndDiverts.length - 1 ||\n            ii === arrowsAndDiverts.length - 2;\n\n          if (!tunnelOnwardsPlacementValid) {\n            this.Error(\n              \"Tunnel onwards '->->' must only come at the begining or the start of a divert\"\n            );\n          }\n\n          const tunnelOnwards = new TunnelOnwards();\n          if (ii < arrowsAndDiverts.length - 1) {\n            const tunnelOnwardDivert = asOrNull(\n              arrowsAndDiverts[ii + 1],\n              Divert\n            );\n            tunnelOnwards.divertAfter = tunnelOnwardDivert;\n          }\n\n          diverts.push(tunnelOnwards);\n\n          // Not allowed to do anything after a tunnel onwards.\n          // If we had anything left it would be caused in the above Error for\n          // the positioning of a ->->\n          break;\n        }\n      } else {\n        // Divert\n        const divert = arrowsAndDiverts[ii] as Divert;\n        // More to come? (further arrows) Must be tunnelling.\n        if (ii < arrowsAndDiverts.length - 1) {\n          divert.isTunnel = true;\n        }\n\n        diverts.push(divert);\n      }\n    }\n\n    // Single -> (used for default choices)\n    if (diverts.length === 0 && arrowsAndDiverts.length === 1) {\n      const gatherDivert = new Divert(null);\n      gatherDivert.isEmpty = true;\n      diverts.push(gatherDivert);\n\n      if (!this._parsingChoice) {\n        this.Error(\"Empty diverts (->) are only valid on choices\");\n      }\n    }\n\n    return diverts;\n  };\n\n  public readonly StartThread = (): Divert | null => {\n    this.Whitespace();\n\n    if (this.ParseThreadArrow() === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const divert = this.Expect(\n      this.DivertIdentifierWithArguments,\n      \"target for new thread\",\n      () => new Divert(null)\n    ) as Divert;\n\n    divert.isThread = true;\n\n    return divert;\n  };\n\n  public readonly DivertIdentifierWithArguments = (): Divert | null => {\n    this.Whitespace();\n\n    const targetComponents: Identifier[] = this.Parse(\n      this.DotSeparatedDivertPathComponents\n    ) as Identifier[];\n\n    if (!targetComponents) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const optionalArguments = this.Parse(\n      this.ExpressionFunctionCallArguments\n    ) as Expression[];\n\n    this.Whitespace();\n\n    const targetPath = new Path(targetComponents);\n\n    return new Divert(targetPath, optionalArguments);\n  };\n\n  public readonly SingleDivert = (): Divert | null => {\n    const diverts = this.Parse(this.MultiDivert) as ParsedObject[];\n    if (!diverts) {\n      return null;\n    }\n\n    // Ideally we'd report errors if we get the\n    // wrong kind of divert, but unfortunately we\n    // have to hack around the fact that sequences use\n    // a very similar syntax.\n    // i.e. if you have a multi-divert at the start\n    // of a sequence, it initially tries to parse it\n    // as a divert target (part of an expression of\n    // a conditional) and gives errors. So instead\n    // we just have to blindly reject it as a single\n    // divert, and give a slightly less nice error\n    // when you DO use a multi divert as a divert taret.\n\n    if (diverts.length !== 1) {\n      return null;\n    }\n\n    const singleDivert = diverts[0];\n    if (singleDivert instanceof TunnelOnwards) {\n      return null;\n    }\n\n    const divert = diverts[0] as Divert;\n    if (divert.isTunnel) {\n      return null;\n    }\n\n    return divert;\n  };\n\n  public readonly DotSeparatedDivertPathComponents = (): Identifier[] =>\n    this.Interleave<Identifier>(\n      this.Spaced(this.IdentifierWithMetadata),\n      this.Exclude(this.String(\".\"))\n    );\n\n  public readonly ParseDivertArrowOrTunnelOnwards = (): string | null => {\n    let numArrows: number = 0;\n    while (this.ParseString(\"->\") !== null) {\n      numArrows += 1;\n    }\n\n    if (numArrows === 0) {\n      return null;\n    } else if (numArrows === 1) {\n      return \"->\";\n    } else if (numArrows === 2) {\n      return \"->->\";\n    }\n\n    this.Error(\n      \"Unexpected number of arrows in divert. Should only have '->' or '->->'\"\n    );\n\n    return \"->->\";\n  };\n\n  public readonly ParseDivertArrow = () => this.ParseString(\"->\");\n\n  public readonly ParseThreadArrow = () => this.ParseString(\"<-\");\n\n  /**\n   * End Divert section.\n   */\n\n  /**\n   * Begin Expressions section.\n   */\n\n  public _binaryOperators: InfixOperator[] = [];\n  public _maxBinaryOpLength: number = 0;\n\n  public readonly TempDeclarationOrAssignment = (): ParsedObject | null => {\n    this.Whitespace();\n\n    const isNewDeclaration: boolean = this.ParseTempKeyword();\n\n    this.Whitespace();\n\n    let varIdentifier: Identifier | null = null;\n    if (isNewDeclaration) {\n      varIdentifier = this.Expect(\n        this.IdentifierWithMetadata,\n        \"variable name\"\n      ) as Identifier;\n    } else {\n      varIdentifier = this.Parse(this.IdentifierWithMetadata) as Identifier;\n    }\n\n    if (varIdentifier === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    // += -=\n    const isIncrement: boolean = this.ParseString(\"+\") !== null;\n    const isDecrement: boolean = this.ParseString(\"-\") !== null;\n\n    if (isIncrement && isDecrement) {\n      this.Error(\"Unexpected sequence '+-'\");\n    }\n\n    if (this.ParseString(\"=\") === null) {\n      // Definitely in an assignment expression?\n      if (isNewDeclaration) {\n        this.Error(\"Expected '='\");\n      }\n\n      return null;\n    }\n\n    const assignedExpression: Expression = this.Expect(\n      this.Expression,\n      \"value expression to be assigned\"\n    ) as Expression;\n\n    if (isIncrement || isDecrement) {\n      const result = new IncDecExpression(\n        varIdentifier,\n        assignedExpression,\n        isIncrement\n      );\n      return result;\n    }\n\n    const result = new VariableAssignment({\n      variableIdentifier: varIdentifier,\n      assignedExpression,\n      isTemporaryNewDeclaration: isNewDeclaration,\n    });\n\n    return result;\n  };\n\n  public readonly DisallowIncrement = (expr: ParsedObject): void => {\n    if (expr instanceof IncDecExpression) {\n      this.Error(\n        \"Can't use increment/decrement here. It can only be used on a ~ line\"\n      );\n    }\n  };\n\n  public readonly ParseTempKeyword = () => {\n    const ruleId = this.BeginRule();\n\n    if (this.Parse(this.Identifier) === \"temp\") {\n      this.SucceedRule(ruleId);\n      return true;\n    }\n\n    this.FailRule(ruleId);\n    return false;\n  };\n\n  public readonly ReturnStatement = (): ReturnType | null => {\n    this.Whitespace();\n\n    const returnOrDone = this.Parse(this.Identifier);\n    if (returnOrDone !== \"return\") {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const expr = this.Parse(this.Expression) as Expression;\n\n    const returnObj = new ReturnType(expr);\n\n    return returnObj;\n  };\n\n  // Pratt Parser\n  // aka \"Top down operator precedence parser\"\n  // http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/\n  // Algorithm overview:\n  // The two types of precedence are handled in two different ways:\n  //   ((((a . b) . c) . d) . e)\t\t\t#1\n  //   (a . (b . (c . (d . e))))\t\t\t#2\n  // Where #1 is automatically handled by successive loops within the main 'while' in this function,\n  // so long as continuing operators have lower (or equal) precedence (e.g. imagine some series of \"*\"s then \"+\" above.\n  // ...and #2 is handled by recursion of the right hand term in the binary expression parser.\n  // (see link for advice on how to extend for postfix and mixfix operators)\n  public readonly Expression = (\n    minimumPrecedence: number = 0\n  ): Expression | null => {\n    this.Whitespace();\n\n    // First parse a unary expression e.g. \"-a\" or parethensised \"(1 + 2)\"\n    let expr = this.ExpressionUnary();\n    if (expr === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    // Attempt to parse (possibly multiple) continuing infix expressions (e.g. 1 + 2 + 3)\n    while (true) {\n      const ruleId = this.BeginRule();\n\n      // Operator\n      const infixOp = this.ParseInfixOperator();\n      if (infixOp !== null && infixOp.precedence > minimumPrecedence) {\n        // Expect right hand side of operator\n        const expectationMessage = `right side of '${infixOp.type}' expression`;\n        const multiaryExpr = this.Expect(\n          () => this.ExpressionInfixRight(expr, infixOp),\n          expectationMessage\n        );\n\n        if (multiaryExpr === null) {\n          // Fail for operator and right-hand side of multiary expression\n          this.FailRule(ruleId);\n\n          return null;\n        }\n\n        expr = this.SucceedRule(ruleId, multiaryExpr) as Expression;\n\n        continue;\n      }\n\n      this.FailRule(ruleId);\n      break;\n    }\n\n    this.Whitespace();\n\n    return expr;\n  };\n\n  public readonly ExpressionUnary = (): Expression | null => {\n    // Divert target is a special case - it can't have any other operators\n    // applied to it, and we also want to check for it first so that we don't\n    // confuse \"->\" for subtraction.\n    const divertTarget = this.Parse(this.ExpressionDivertTarget) as Expression;\n    if (divertTarget !== null) {\n      return divertTarget;\n    }\n\n    let prefixOp: Expression = this.OneOf([\n      this.String(\"-\"),\n      this.String(\"!\"),\n    ]) as Expression;\n\n    // Don't parse like the string rules above, in case its actually\n    // a variable that simply starts with \"not\", e.g. \"notable\".\n    // This rule uses the Identifier rule, which will scan as much text\n    // as possible before returning.\n    if (prefixOp === null) {\n      prefixOp = this.Parse(this.ExpressionNot) as Expression;\n    }\n\n    this.Whitespace();\n\n    // - Since we allow numbers at the start of variable names, variable names are checked before literals\n    // - Function calls before variable names in case we see parentheses\n    let expr = this.OneOf([\n      this.ExpressionList,\n      this.ExpressionParen,\n      this.ExpressionFunctionCall,\n      this.ExpressionVariableName,\n      this.ExpressionLiteral,\n    ]) as Expression | null;\n\n    // Only recurse immediately if we have one of the (usually optional) unary ops\n    if (expr === null && prefixOp !== null) {\n      expr = this.ExpressionUnary();\n    }\n\n    if (expr === null) {\n      return null;\n    } else if (prefixOp !== null) {\n      expr = UnaryExpression.WithInner(expr, prefixOp as any) as Expression;\n    }\n\n    this.Whitespace();\n\n    const postfixOp = this.OneOf([this.String(\"++\"), this.String(\"--\")]);\n\n    if (postfixOp !== null) {\n      const isInc: boolean = postfixOp === \"++\";\n\n      if (!(expr instanceof VariableReference)) {\n        this.Error(\n          `can only increment and decrement variables, but saw '${expr}'.`\n        );\n\n        // Drop down and succeed without the increment after reporting error\n      } else {\n        const varRef = expr as VariableReference;\n        expr = new IncDecExpression(varRef.identifier, isInc);\n      }\n    }\n\n    return expr;\n  };\n\n  public readonly ExpressionNot = (): string | null => {\n    const id = this.Identifier();\n    if (id === \"not\") {\n      return id;\n    }\n\n    return null;\n  };\n\n  public readonly ExpressionLiteral = (): Expression =>\n    this.OneOf([\n      this.ExpressionFloat,\n      this.ExpressionInt,\n      this.ExpressionBool,\n      this.ExpressionString,\n    ]) as Expression;\n\n  public readonly ExpressionDivertTarget = (): Expression | null => {\n    this.Whitespace();\n\n    const divert = this.Parse(this.SingleDivert) as Divert;\n    if (!divert || (divert && divert.isThread)) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    return new DivertTarget(divert);\n  };\n\n  public readonly ExpressionInt = (): NumberExpression | null => {\n    const intOrNull: number = this.ParseInt() as number;\n    if (intOrNull === null) {\n      return null;\n    }\n\n    return new NumberExpression(intOrNull, \"int\");\n  };\n\n  public readonly ExpressionFloat = (): NumberExpression | null => {\n    const floatOrNull: number = this.ParseFloat() as number;\n    if (floatOrNull === null) {\n      return null;\n    }\n\n    return new NumberExpression(floatOrNull, \"float\");\n  };\n\n  public readonly ExpressionString = (): StringExpression | null => {\n    const openQuote = this.ParseString('\"');\n    if (openQuote === null) {\n      return null;\n    }\n\n    // Set custom parser state flag so that within the text parser,\n    // it knows to treat the quote character (\") as an end character\n    this.parsingStringExpression = true;\n\n    let textAndLogic: ParsedObject[] = this.Parse(\n      this.MixedTextAndLogic\n    ) as ParsedObject[];\n\n    this.Expect(this.String('\"'), \"close quote for string expression\");\n\n    this.parsingStringExpression = false;\n\n    if (textAndLogic === null) {\n      textAndLogic = [new Text(\"\")];\n    } else if (textAndLogic.find((c) => c instanceof Divert)) {\n      this.Error(\"String expressions cannot contain diverts (->)\");\n    }\n\n    return new StringExpression(textAndLogic);\n  };\n\n  public readonly ExpressionBool = (): NumberExpression | null => {\n    const id = this.Parse(this.Identifier);\n    if (id === \"true\") {\n      return new NumberExpression(true, \"bool\");\n    } else if (id === \"false\") {\n      return new NumberExpression(false, \"bool\");\n    }\n\n    return null;\n  };\n\n  public readonly ExpressionFunctionCall = (): Expression | null => {\n    const iden = this.Parse(this.IdentifierWithMetadata);\n    if (iden === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const args = this.Parse(this.ExpressionFunctionCallArguments);\n    if (args === null) {\n      return null;\n    }\n\n    return new FunctionCall(iden as Identifier, args as any);\n  };\n\n  public readonly ExpressionFunctionCallArguments = (): Expression[] | null => {\n    if (this.ParseString(\"(\") === null) {\n      return null;\n    }\n\n    // \"Exclude\" requires the rule to succeed, but causes actual comma string to be excluded from the list of results\n    const commas: ParseRule = this.Exclude(this.String(\",\"));\n    let args = this.Interleave<Expression>(this.Expression, commas);\n    if (args === null) {\n      args = [];\n    }\n\n    this.Whitespace();\n\n    this.Expect(this.String(\")\"), \"closing ')' for function call\");\n\n    return args;\n  };\n\n  public readonly ExpressionVariableName = (): Expression | null => {\n    const path = this.Interleave<Identifier>(\n      this.IdentifierWithMetadata,\n      this.Exclude(this.Spaced(this.String(\".\")))\n    );\n\n    if (path === null || Story.IsReservedKeyword(path[0].name)) {\n      return null;\n    }\n\n    return new VariableReference(path);\n  };\n\n  public readonly ExpressionParen = (): Expression | null => {\n    if (this.ParseString(\"(\") === null) {\n      return null;\n    }\n\n    const innerExpr = this.Parse(this.Expression) as Expression;\n    if (innerExpr === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    this.Expect(this.String(\")\"), \"closing parenthesis ')' for expression\");\n\n    return innerExpr;\n  };\n\n  public readonly ExpressionInfixRight = (\n    left: Expression | null,\n    op: InfixOperator\n  ) => {\n    if (!left) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const right = this.Parse(() =>\n      this.Expression(op.precedence)\n    ) as Expression;\n    if (right) {\n      // We assume that the character we use for the operator's type is the same\n      // as that used internally by e.g. Runtime.Expression.Add, Runtime.Expression.Multiply etc\n      const expr = new BinaryExpression(left, right, op.type);\n      return expr;\n    }\n\n    return null;\n  };\n\n  private readonly ParseInfixOperator = (): InfixOperator | null => {\n    for (const op of this._binaryOperators) {\n      const ruleId: number = this.BeginRule();\n\n      if (this.ParseString(op.type) !== null) {\n        if (op.requireWhitespace) {\n          if (this.Whitespace() === null) {\n            this.FailRule(ruleId);\n\n            continue;\n          }\n        }\n\n        return this.SucceedRule(ruleId, op) as InfixOperator;\n      }\n\n      this.FailRule(ruleId);\n    }\n\n    return null;\n  };\n\n  public readonly ExpressionList = (): List | null => {\n    this.Whitespace();\n\n    if (this.ParseString(\"(\") === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    // When list has:\n    //  - 0 elements (null list) - this is okay, it's an empty list: \"()\"\n    //  - 1 element - it could be confused for a single non-list related\n    //    identifier expression in brackets, but this is a useless thing\n    //    to do, so we reserve that syntax for a list with one item.\n    //  - 2 or more elements - normal!\n    const memberNames: Identifier[] = this.SeparatedList(\n      this.ListMember,\n      this.Spaced(this.String(\",\"))\n    ) as Identifier[];\n\n    this.Whitespace();\n\n    // May have failed to parse the inner list - the parentheses may\n    // be for a normal expression\n    if (this.ParseString(\")\") === null) {\n      return null;\n    }\n    return new List(memberNames);\n  };\n\n  public readonly ListMember = (): Identifier | null => {\n    this.Whitespace();\n\n    let identifier: Identifier = this.Parse(\n      this.IdentifierWithMetadata\n    ) as Identifier;\n    if (identifier === null) {\n      return null;\n    }\n\n    const dot = this.ParseString(\".\");\n    if (dot !== null) {\n      const identifier2: Identifier = this.Expect(\n        this.IdentifierWithMetadata,\n        `element name within the set ${identifier}`\n      ) as Identifier;\n\n      identifier.name += `.${identifier2?.name}`;\n    }\n\n    this.Whitespace();\n\n    return identifier;\n  };\n\n  public readonly RegisterExpressionOperators = () => {\n    // These will be tried in order, so we need \"<=\" before \"<\"\n    // for correctness\n\n    this.RegisterBinaryOperator(\"&&\", 1);\n    this.RegisterBinaryOperator(\"||\", 1);\n    this.RegisterBinaryOperator(\"and\", 1, true);\n    this.RegisterBinaryOperator(\"or\", 1, true);\n    this.RegisterBinaryOperator(\"==\", 2);\n    this.RegisterBinaryOperator(\">=\", 2);\n    this.RegisterBinaryOperator(\"<=\", 2);\n    this.RegisterBinaryOperator(\"<\", 2);\n    this.RegisterBinaryOperator(\">\", 2);\n    this.RegisterBinaryOperator(\"!=\", 2);\n\n    // (apples, oranges) + cabbages has (oranges, cabbages) === true\n    this.RegisterBinaryOperator(\"?\", 3);\n    this.RegisterBinaryOperator(\"has\", 3, true);\n    this.RegisterBinaryOperator(\"!?\", 3);\n    this.RegisterBinaryOperator(\"hasnt\", 3, true);\n    this.RegisterBinaryOperator(\"^\", 3);\n\n    this.RegisterBinaryOperator(\"+\", 4);\n    this.RegisterBinaryOperator(\"-\", 5);\n    this.RegisterBinaryOperator(\"*\", 6);\n    this.RegisterBinaryOperator(\"/\", 7);\n\n    this.RegisterBinaryOperator(\"%\", 8);\n    this.RegisterBinaryOperator(\"mod\", 8, true);\n  };\n\n  public readonly RegisterBinaryOperator = (\n    op: string,\n    precedence: number,\n    requireWhitespace: boolean = false\n  ): void => {\n    const infix = new InfixOperator(op, precedence, requireWhitespace);\n    this._binaryOperators.push(infix);\n    this._maxBinaryOpLength = Math.max(this._maxBinaryOpLength, op.length);\n  };\n\n  /**\n   * End Expressions section.\n   */\n\n  /**\n   * Begin Include section.\n   */\n\n  private _rootParser: InkParser;\n  private _openFilenames: string[] = [];\n\n  public readonly IncludeStatement = () => {\n    this.Whitespace();\n\n    if (this.ParseString(\"INCLUDE\") === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    let filename: string = this.Expect(\n      () => this.ParseUntilCharactersFromString(\"\\n\\r\"),\n      \"filename for include statement\"\n    ) as string;\n\n    filename = filename.replace(new RegExp(/[ \\t]+$/g), \"\");\n\n    // Working directory should already have been set up relative to the root ink file.\n    const fullFilename = this.fileHandler.ResolveInkFilename(filename);\n\n    if (this.FilenameIsAlreadyOpen(fullFilename)) {\n      this.Error(\n        `Recursive INCLUDE detected: '${fullFilename}' is already open.`\n      );\n      this.ParseUntilCharactersFromString(\"\\r\\n\");\n      return new IncludedFile(null);\n    } else {\n      this.AddOpenFilename(fullFilename);\n    }\n\n    let includedStory: Story | null = null;\n    let includedString: string = \"\";\n    try {\n      includedString =\n        this._rootParser.fileHandler.LoadInkFileContents(fullFilename);\n    } catch (err) {\n      this.Error(`Failed to load: '${filename}'.\\nError:${err}`);\n    }\n\n    if (includedString) {\n      const parser: InkParser = new InkParser(\n        includedString,\n        filename,\n        this._externalErrorHandler,\n        this._rootParser,\n        this.fileHandler\n      );\n\n      includedStory = parser.ParseStory();\n    }\n\n    this.RemoveOpenFilename(fullFilename);\n\n    // Return valid IncludedFile object even if there were errors when parsing.\n    // We don't want to attempt to re-parse the include line as something else,\n    // and we want to include the bits that *are* valid, so we don't generate\n    // more errors than necessary.\n    return new IncludedFile(includedStory);\n  };\n\n  public readonly FilenameIsAlreadyOpen = (fullFilename: string): boolean =>\n    this._rootParser._openFilenames.includes(fullFilename);\n\n  public readonly AddOpenFilename = (fullFilename: string): void => {\n    this._rootParser._openFilenames.push(fullFilename);\n  };\n\n  public readonly RemoveOpenFilename = (fullFilename: string) => {\n    this._rootParser._openFilenames.splice(\n      this._rootParser._openFilenames.indexOf(fullFilename),\n      1\n    );\n  };\n\n  /**\n   * End Include section.\n   */\n\n  /**\n   * Begin Knot section.\n   */\n\n  public readonly KnotDefinition = (): Knot | null => {\n    const knotDecl: FlowDecl = this.Parse(this.KnotDeclaration) as FlowDecl;\n    if (knotDecl === null) {\n      return null;\n    }\n\n    this.Expect(\n      this.EndOfLine,\n      \"end of line after knot name definition\",\n      this.SkipToNextLine\n    );\n\n    const innerKnotStatements: ParseRule = (): ParsedObject[] =>\n      this.StatementsAtLevel(StatementLevel.Knot);\n\n    const content = this.Expect(\n      innerKnotStatements,\n      \"at least one line within the knot\",\n      this.KnotStitchNoContentRecoveryRule\n    ) as ParsedObject[];\n\n    return new Knot(knotDecl.name, content, knotDecl.args, knotDecl.isFunction);\n  };\n\n  public readonly KnotDeclaration = (): FlowDecl | null => {\n    this.Whitespace();\n\n    if (this.KnotTitleEquals() === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const identifier: Identifier = this.Parse(\n      this.IdentifierWithMetadata\n    ) as Identifier;\n    let knotName: Identifier;\n\n    const isFunc: boolean = identifier?.name === \"function\";\n    if (isFunc) {\n      this.Expect(this.Whitespace, \"whitespace after the 'function' keyword\");\n\n      knotName = this.Parse(this.IdentifierWithMetadata) as Identifier;\n    } else {\n      knotName = identifier;\n    }\n\n    if (knotName === null) {\n      this.Error(`Expected the name of the ${isFunc ? \"function\" : \"knot\"}`);\n      knotName = new Identifier(\"\"); // prevent later null ref\n    }\n\n    this.Whitespace();\n\n    const parameterNames: Argument[] = this.Parse(\n      this.BracketedKnotDeclArguments\n    ) as Argument[];\n\n    this.Whitespace();\n\n    // Optional equals after name\n    this.Parse(this.KnotTitleEquals);\n\n    return new FlowDecl(knotName, parameterNames, isFunc);\n  };\n\n  public readonly KnotTitleEquals = (): string | null => {\n    // 2+ \"=\" starts a knot\n    const multiEquals = this.ParseCharactersFromString(\"=\");\n    if (multiEquals === null || multiEquals.length <= 1) {\n      return null;\n    }\n\n    return multiEquals;\n  };\n\n  public readonly StitchDefinition = (): ParseRuleReturn => {\n    const decl = this.Parse(this.StitchDeclaration) as FlowDecl;\n    if (decl === null) {\n      return null;\n    }\n\n    this.Expect(\n      this.EndOfLine,\n      \"end of line after stitch name\",\n      this.SkipToNextLine\n    );\n\n    const innerStitchStatements: ParseRule = () =>\n      this.StatementsAtLevel(StatementLevel.Stitch);\n\n    const content = this.Expect(\n      innerStitchStatements,\n      \"at least one line within the stitch\",\n      this.KnotStitchNoContentRecoveryRule\n    ) as ParsedObject[];\n\n    return new Stitch(decl.name, content, decl.args, decl.isFunction);\n  };\n\n  public readonly StitchDeclaration = (): FlowDecl | null => {\n    this.Whitespace();\n\n    // Single \"=\" to define a stitch\n    if (this.ParseString(\"=\") === null) {\n      return null;\n    }\n\n    // If there's more than one \"=\", that's actually a knot definition (or divert), so this rule should fail\n    if (this.ParseString(\"=\") !== null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    // Stitches aren't allowed to be functions, but we parse it anyway and report the error later\n    const isFunc: boolean = this.ParseString(\"function\") !== null;\n    if (isFunc) {\n      this.Whitespace();\n    }\n\n    const stitchName: Identifier = this.Parse(\n      this.IdentifierWithMetadata\n    ) as Identifier;\n    if (stitchName === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const flowArgs: Argument[] = this.Parse(\n      this.BracketedKnotDeclArguments\n    ) as Argument[];\n\n    this.Whitespace();\n\n    return new FlowDecl(stitchName, flowArgs, isFunc);\n  };\n\n  public readonly KnotStitchNoContentRecoveryRule = (): ParseRuleReturn => {\n    // Jump ahead to the next knot or the end of the file\n    this.ParseUntil(this.KnotDeclaration, new CharacterSet(\"=\"), null);\n\n    const recoveredFlowContent: ParsedObject[] = [new Text(\"<ERROR IN FLOW>\")];\n\n    return recoveredFlowContent;\n  };\n\n  public readonly BracketedKnotDeclArguments = (): Argument[] | null => {\n    if (this.ParseString(\"(\") === null) {\n      return null;\n    }\n\n    let flowArguments = this.Interleave<Argument>(\n      this.Spaced(this.FlowDeclArgument),\n      this.Exclude(this.String(\",\"))\n    );\n\n    this.Expect(this.String(\")\"), \"closing ')' for parameter list\");\n\n    // If no parameters, create an empty list so that this method is type safe and\n    // doesn't attempt to return the ParseSuccess object\n    if (flowArguments === null) {\n      flowArguments = [];\n    }\n\n    return flowArguments;\n  };\n\n  public readonly FlowDeclArgument = (): Argument | null => {\n    // Possible forms:\n    //  name\n    //  -> name      (variable divert target argument\n    //  ref name\n    //  ref -> name  (variable divert target by reference)\n    const firstIden = this.Parse(this.IdentifierWithMetadata) as Identifier;\n    this.Whitespace();\n\n    const divertArrow = this.ParseDivertArrow();\n\n    this.Whitespace();\n\n    const secondIden = this.Parse(this.IdentifierWithMetadata) as Identifier;\n\n    if (firstIden == null && secondIden === null) {\n      return null;\n    }\n\n    const flowArg = new Argument();\n    if (divertArrow !== null) {\n      flowArg.isDivertTarget = true;\n    }\n\n    // Passing by reference\n    if (firstIden !== null && firstIden.name === \"ref\") {\n      if (secondIden === null) {\n        this.Error(\"Expected an parameter name after 'ref'\");\n      }\n\n      flowArg.identifier = secondIden;\n      flowArg.isByReference = true;\n    } else {\n      // Simple argument name\n      if (flowArg.isDivertTarget) {\n        flowArg.identifier = secondIden;\n      } else {\n        flowArg.identifier = firstIden;\n      }\n\n      if (flowArg.identifier === null) {\n        this.Error(\"Expected an parameter name\");\n      }\n\n      flowArg.isByReference = false;\n    }\n\n    return flowArg;\n  };\n\n  public readonly ExternalDeclaration = (): ExternalDeclaration | null => {\n    this.Whitespace();\n\n    const external = this.Parse(\n      this.IdentifierWithMetadata\n    ) as Identifier | null;\n    if (external === null || external.name != \"EXTERNAL\") {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const funcIdentifier: Identifier =\n      (this.Expect(\n        this.IdentifierWithMetadata,\n        \"name of external function\"\n      ) as Identifier | null) || new Identifier(\"\");\n\n    this.Whitespace();\n\n    let parameterNames = this.Expect(\n      this.BracketedKnotDeclArguments,\n      `declaration of arguments for EXTERNAL, even if empty, i.e. 'EXTERNAL ${funcIdentifier}()'`\n    ) as Argument[];\n\n    if (parameterNames === null) {\n      parameterNames = [];\n    }\n\n    const argNames = parameterNames\n      .map((arg) => arg.identifier?.name)\n      .filter(filterUndef);\n\n    return new ExternalDeclaration(funcIdentifier, argNames);\n  };\n\n  /**\n   * End Knot section.\n   */\n\n  /**\n   * Start Logic section.\n   */\n\n  private _identifierCharSet: CharacterSet | null = null;\n\n  get identifierCharSet(): CharacterSet {\n    if (this._identifierCharSet === null) {\n      (this._identifierCharSet = new CharacterSet())\n        .AddRange(\"A\", \"Z\")\n        .AddRange(\"a\", \"z\")\n        .AddRange(\"0\", \"9\")\n        .Add(\"_\");\n\n      // Enable non-ASCII characters for story identifiers.\n      this.ExtendIdentifierCharacterRanges(this._identifierCharSet);\n    }\n\n    return this._identifierCharSet;\n  }\n\n  public readonly LogicLine = (): ParsedObject | null => {\n    this.Whitespace();\n\n    if (this.ParseString(\"~\") === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    // Some example lines we need to be able to distinguish between:\n    // ~ temp x = 5  -- var decl + assign\n    // ~ temp x      -- var decl\n    // ~ x = 5       -- var assign\n    // ~ x           -- expr (not var decl or assign)\n    // ~ f()         -- expr\n    // We don't treat variable decl/assign as an expression since we don't want an assignment\n    // to have a return value, or to be used in compound expressions.\n    const afterTilde: ParseRule = () =>\n      this.OneOf([\n        this.ReturnStatement,\n        this.TempDeclarationOrAssignment,\n        this.Expression,\n      ]);\n\n    let result = this.Expect(\n      afterTilde,\n      \"expression after '~'\",\n      this.SkipToNextLine\n    ) as ParsedObject;\n\n    // Prevent further errors, already reported expected expression and have skipped to next line.\n    if (result === null) {\n      return new ContentList();\n    }\n\n    // Parse all expressions, but tell the writer off if they did something useless like:\n    //  ~ 5 + 4\n    // And even:\n    //  ~ false && myFunction()\n    // ...since it's bad practice, and won't do what they expect if\n    // they're expecting C's lazy evaluation.\n    if (\n      result instanceof Expression &&\n      !(result instanceof FunctionCall || result instanceof IncDecExpression)\n    ) {\n      this.Error(\n        \"Logic following a '~' can't be that type of expression. It can only be something like:\\n\\t~ return\\n\\t~ var x = blah\\n\\t~ x++\\n\\t~ myFunction()\"\n      );\n    }\n\n    // Line is pure function call? e.g.\n    //  ~ f()\n    // Add extra pop to make sure we tidy up after ourselves.\n    // We no longer need anything on the evaluation stack.\n    const funCall = asOrNull(result, FunctionCall);\n    if (funCall) {\n      funCall.shouldPopReturnedValue = true;\n    }\n\n    // If the expression contains a function call, then it could produce a text side effect,\n    // in which case it needs a newline on the end. e.g.\n    //  ~ printMyName()\n    //  ~ x = 1 + returnAValueAndAlsoPrintStuff()\n    // If no text gets printed, then the extra newline will have to be culled later.\n    // Multiple newlines on the output will be removed, so there will be no \"leak\" for\n    // long running calculations. It's disappointingly messy though :-/\n    if (result.Find(FunctionCall)() !== null) {\n      result = new ContentList(result as any, new Text(\"\\n\"));\n    }\n\n    this.Expect(this.EndOfLine, \"end of line\", this.SkipToNextLine);\n\n    return result as ParsedObject;\n  };\n\n  public readonly VariableDeclaration = (): ParsedObject | null => {\n    this.Whitespace();\n\n    const id = this.Parse(this.Identifier);\n    if (id !== \"VAR\") {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const varName = this.Expect(\n      this.IdentifierWithMetadata,\n      \"variable name\"\n    ) as Identifier;\n\n    this.Whitespace();\n\n    this.Expect(\n      this.String(\"=\"),\n      \"the '=' for an assignment of a value, e.g. '= 5' (initial values are mandatory)\"\n    );\n\n    this.Whitespace();\n\n    const definition = this.Expect(this.Expression, \"initial value for \");\n\n    const expr = definition as Expression;\n\n    if (expr) {\n      const check =\n        expr instanceof NumberExpression ||\n        expr instanceof StringExpression ||\n        expr instanceof DivertTarget ||\n        expr instanceof VariableReference ||\n        expr instanceof List;\n\n      if (!check) {\n        this.Error(\n          \"initial value for a variable must be a number, constant, list or divert target\"\n        );\n      }\n\n      if (this.Parse(this.ListElementDefinitionSeparator) !== null) {\n        this.Error(\n          \"Unexpected ','. If you're trying to declare a new list, use the LIST keyword, not VAR\"\n        );\n      } else if (expr instanceof StringExpression) {\n        // Ensure string expressions are simple\n        const strExpr = expr as StringExpression;\n        if (!strExpr.isSingleString) {\n          this.Error(\"Constant strings cannot contain any logic.\");\n        }\n      }\n\n      const result = new VariableAssignment({\n        assignedExpression: expr,\n        isGlobalDeclaration: true,\n        variableIdentifier: varName,\n      });\n\n      return result;\n    }\n\n    return null;\n  };\n\n  public readonly ListDeclaration = (): VariableAssignment | null => {\n    this.Whitespace();\n\n    const id = this.Parse(this.Identifier);\n    if (id != \"LIST\") {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const varName = this.Expect(\n      this.IdentifierWithMetadata,\n      \"list name\"\n    ) as Identifier;\n\n    this.Whitespace();\n\n    this.Expect(\n      this.String(\"=\"),\n      \"the '=' for an assignment of the list definition\"\n    );\n\n    this.Whitespace();\n\n    const definition = this.Expect(\n      this.ListDefinition,\n      \"list item names\"\n    ) as ListDefinition;\n\n    if (definition) {\n      definition.identifier = new Identifier(varName.name);\n      return new VariableAssignment({\n        variableIdentifier: varName,\n        listDef: definition,\n      });\n    }\n\n    return null;\n  };\n\n  public readonly ListDefinition = (): ListDefinition | null => {\n    this.AnyWhitespace();\n\n    const allElements = this.SeparatedList(\n      this.ListElementDefinition,\n      this.ListElementDefinitionSeparator\n    ) as ListElementDefinition[];\n\n    if (allElements === null) {\n      return null;\n    }\n\n    return new ListDefinition(allElements);\n  };\n\n  public readonly ListElementDefinitionSeparator = (): string | null => {\n    this.AnyWhitespace();\n\n    if (this.ParseString(\",\") === null) {\n      return null;\n    }\n\n    this.AnyWhitespace();\n\n    return \",\";\n  };\n\n  public readonly ListElementDefinition = () => {\n    const inInitialList = this.ParseString(\"(\") !== null;\n    let needsToCloseParen = inInitialList;\n\n    this.Whitespace();\n\n    const name = this.Parse(this.IdentifierWithMetadata) as Identifier | null;\n    if (name === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    if (inInitialList) {\n      if (this.ParseString(\")\") != null) {\n        needsToCloseParen = false;\n        this.Whitespace();\n      }\n    }\n\n    let elementValue: number | null = null;\n    if (this.ParseString(\"=\") !== null) {\n      this.Whitespace();\n\n      const elementValueNum = this.Expect(\n        this.ExpressionInt,\n        \"value to be assigned to list item\"\n      ) as NumberExpression;\n\n      if (elementValueNum !== null) {\n        elementValue = elementValueNum.value as number;\n      }\n\n      if (needsToCloseParen) {\n        this.Whitespace();\n\n        if (this.ParseString(\")\") !== null) {\n          needsToCloseParen = false;\n        }\n      }\n    }\n\n    if (needsToCloseParen) {\n      this.Error(\"Expected closing ')'\");\n    }\n\n    return new ListElementDefinition(name, inInitialList, elementValue);\n  };\n\n  public readonly ConstDeclaration = (): ParsedObject | null => {\n    this.Whitespace();\n\n    const id = this.Parse(this.Identifier);\n    if (id !== \"CONST\") {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const varName = this.Expect(\n      this.IdentifierWithMetadata,\n      \"constant name\"\n    ) as Identifier;\n\n    this.Whitespace();\n\n    this.Expect(\n      this.String(\"=\"),\n      \"the '=' for an assignment of a value, e.g. '= 5' (initial values are mandatory)\"\n    );\n\n    this.Whitespace();\n\n    const expr = this.Expect(\n      this.Expression,\n      \"initial value for \"\n    ) as Expression;\n\n    const check =\n      expr instanceof NumberExpression ||\n      expr instanceof DivertTarget ||\n      expr instanceof StringExpression;\n\n    if (!check) {\n      this.Error(\n        \"initial value for a constant must be a number or divert target\"\n      );\n    } else if (expr instanceof StringExpression) {\n      // Ensure string expressions are simple\n      const strExpr = expr as StringExpression;\n      if (!strExpr.isSingleString) {\n        this.Error(\"Constant strings cannot contain any logic.\");\n      }\n    }\n\n    const result = new ConstantDeclaration(varName, expr);\n\n    return result;\n  };\n\n  public readonly InlineLogicOrGlueOrStartTag = (): ParsedObject =>\n    this.OneOf([this.InlineLogic, this.Glue, this.StartTag]) as ParsedObject;\n\n  public readonly Glue = (): Glue | null => {\n    // Don't want to parse whitespace, since it might be important\n    // surrounding the glue.\n    const glueStr = this.ParseString(\"<>\");\n    if (glueStr !== null) {\n      return new Glue(new RuntimeGlue());\n    }\n\n    return null;\n  };\n\n  public readonly InlineLogic = () => {\n    if (this.ParseString(\"{\") === null) {\n      return null;\n    }\n\n    let wasParsingString = this.parsingStringExpression;\n    let wasTagActive = this.tagActive;\n\n    this.Whitespace();\n\n    const logic = this.Expect(\n      this.InnerLogic,\n      \"some kind of logic, conditional or sequence within braces: { ... }\"\n    ) as ParsedObject;\n\n    if (logic === null) {\n      this.parsingStringExpression = wasParsingString;\n      return null;\n    }\n\n    this.DisallowIncrement(logic);\n\n    let contentList = asOrNull(logic, ContentList);\n    if (!contentList) {\n      contentList = new ContentList(logic as any);\n    }\n\n    this.Whitespace();\n\n    this.Expect(this.String(\"}\"), \"closing brace '}' for inline logic\");\n\n    // Allow nested strings and logic\n    this.parsingStringExpression = wasParsingString;\n\n    // Difference between:\n    //\n    //     1) A thing # {image}.jpg\n    //     2) A {red #red|blue #blue} sequence.\n    //\n    //  When logic ends in (1) we still want tag to continue.\n    //  When logic ends in (2) we want to auto-end the tag.\n    //  Side note: we simply disallow tags within strings.\n    if (!wasTagActive) this.EndTagIfNecessary(contentList);\n\n    return contentList;\n  };\n\n  public readonly InnerLogic = (): ParsedObject | null => {\n    this.Whitespace();\n\n    // Explicitly try the combinations of inner logic\n    // that could potentially have conflicts first.\n\n    // Explicit sequence annotation?\n    const explicitSeqType: SequenceType = this.ParseObject(\n      this.SequenceTypeAnnotation\n    ) as SequenceType;\n\n    if (explicitSeqType !== null) {\n      const contentLists = this.Expect(\n        this.InnerSequenceObjects,\n        \"sequence elements (for cycle/stoping etc)\"\n      ) as ContentList[];\n\n      if (contentLists === null) {\n        return null;\n      }\n\n      return new Sequence(contentLists, explicitSeqType);\n    }\n\n    // Conditional with expression?\n    const initialQueryExpression = this.Parse(\n      this.ConditionExpression\n    ) as Expression;\n    if (initialQueryExpression) {\n      const conditional = this.Expect(\n        () => this.InnerConditionalContent(initialQueryExpression),\n        \"conditional content following query\"\n      ) as Conditional;\n\n      return conditional;\n    }\n\n    // Now try to evaluate each of the \"full\" rules in turn\n    const rules: ParseRule[] = [\n      // Conditional still necessary, since you can have a multi-line conditional\n      // without an initial query expression:\n      // {\n      //   - true:  this is true\n      //   - false: this is false\n      // }\n      this.InnerConditionalContent as ParseRule,\n      this.InnerSequence,\n      this.InnerExpression,\n    ];\n\n    let wasTagActiveAtStartOfScope = this.tagActive;\n\n    // Adapted from \"OneOf\" structuring rule except that in\n    // order for the rule to succeed, it has to maximally\n    // cover the entire string within the { }. Used to\n    // differentiate between:\n    //  {myVar}                 -- Expression (try first)\n    //  {my content is jolly}   -- sequence with single element\n    for (const rule of rules) {\n      const ruleId: number = this.BeginRule();\n\n      const result: ParsedObject = this.ParseObject(rule) as ParsedObject;\n      if (result) {\n        // Not yet at end?\n        if (this.Peek(this.Spaced(this.String(\"}\"))) === null) {\n          this.FailRule(ruleId);\n        } else {\n          // Full parse of content within braces\n          return this.SucceedRule(ruleId, result) as ParsedObject;\n        }\n      } else {\n        this.FailRule(ruleId);\n      }\n    }\n\n    return null;\n  };\n\n  public readonly InnerExpression = (): ParsedObject => {\n    const expr = this.Parse(this.Expression) as Expression;\n    if (expr) {\n      expr.outputWhenComplete = true;\n    }\n\n    return expr;\n  };\n\n  public readonly IdentifierWithMetadata = (): Identifier | null => {\n    const id = this.Identifier();\n    if (id === null) {\n      return null;\n    }\n    return new Identifier(id);\n  };\n\n  // Note: we allow identifiers that start with a number,\n  // but not if they *only* comprise numbers\n  public readonly Identifier = (): string | null => {\n    // Parse remaining characters (if any)\n    const name = this.ParseCharactersFromCharSet(this.identifierCharSet);\n    if (name === null) {\n      return null;\n    }\n\n    // Reject if it's just a number\n    let isNumberCharsOnly: boolean = true;\n    for (let c of name) {\n      if (!(c >= \"0\" && c <= \"9\")) {\n        isNumberCharsOnly = false;\n        break;\n      }\n    }\n\n    if (isNumberCharsOnly) {\n      return null;\n    }\n\n    return name;\n  };\n\n  /**\n   * End Logic section.\n   */\n\n  /**\n   * Begin Sequences section.\n   */\n\n  public _sequenceTypeSymbols: CharacterSet = new CharacterSet(\"!&~$\");\n\n  public readonly InnerSequence = (): Sequence | null => {\n    this.Whitespace();\n\n    // Default sequence type\n    let seqType: SequenceType = SequenceType.Stopping;\n\n    // Optional explicit sequence type\n    const parsedSeqType: SequenceType = this.Parse(\n      this.SequenceTypeAnnotation\n    ) as SequenceType;\n\n    if (parsedSeqType !== null) {\n      seqType = parsedSeqType;\n    }\n\n    const contentLists = this.Parse(this.InnerSequenceObjects) as ContentList[];\n    if (contentLists === null || contentLists.length <= 1) {\n      return null;\n    }\n\n    return new Sequence(contentLists, seqType);\n  };\n\n  public readonly SequenceTypeAnnotation = (): ParseRuleReturn => {\n    let annotation = this.Parse(\n      this.SequenceTypeSymbolAnnotation\n    ) as SequenceType;\n\n    if (annotation === null) {\n      annotation = this.Parse(this.SequenceTypeWordAnnotation) as SequenceType;\n    }\n\n    if (annotation === null) {\n      return null;\n    }\n\n    switch (annotation) {\n      case SequenceType.Once:\n      case SequenceType.Cycle:\n      case SequenceType.Stopping:\n      case SequenceType.Shuffle:\n      case SequenceType.Shuffle | SequenceType.Stopping:\n      case SequenceType.Shuffle | SequenceType.Once:\n        break;\n      default:\n        this.Error(`Sequence type combination not supported: ${annotation}`);\n        return SequenceType.Stopping;\n    }\n\n    return annotation;\n  };\n\n  public readonly SequenceTypeSymbolAnnotation = (): ParseRuleReturn => {\n    if (this._sequenceTypeSymbols === null) {\n      this._sequenceTypeSymbols = new CharacterSet(\"!&~$ \");\n    }\n\n    let sequenceType = 0 as SequenceType;\n    const sequenceAnnotations = this.ParseCharactersFromCharSet(\n      this._sequenceTypeSymbols\n    );\n\n    if (sequenceAnnotations === null) {\n      return null;\n    }\n\n    for (const symbolChar of sequenceAnnotations) {\n      switch (symbolChar) {\n        case \"!\":\n          sequenceType |= SequenceType.Once;\n          break;\n        case \"&\":\n          sequenceType |= SequenceType.Cycle;\n          break;\n        case \"~\":\n          sequenceType |= SequenceType.Shuffle;\n          break;\n        case \"$\":\n          sequenceType |= SequenceType.Stopping;\n          break;\n      }\n    }\n\n    if (sequenceType === (0 as SequenceType)) {\n      return null;\n    }\n\n    return sequenceType;\n  };\n\n  public readonly SequenceTypeWordAnnotation = (): ParseRuleReturn => {\n    const sequenceTypes = this.Interleave<SequenceType | null>(\n      this.SequenceTypeSingleWord,\n      this.Exclude(this.Whitespace)\n    );\n\n    if (sequenceTypes === null || sequenceTypes.length === 0) {\n      return null;\n    }\n\n    if (this.ParseString(\":\") === null) {\n      return null;\n    }\n\n    let combinedSequenceType = 0 as SequenceType;\n    for (const seqType of sequenceTypes) {\n      combinedSequenceType |= seqType!;\n    }\n\n    return combinedSequenceType;\n  };\n\n  public readonly SequenceTypeSingleWord = () => {\n    let seqType: SequenceType | null = null;\n\n    const word = this.Parse(this.IdentifierWithMetadata) as Identifier | null;\n\n    if (word !== null) {\n      switch (word.name) {\n        case \"once\":\n          seqType = SequenceType.Once;\n          break;\n        case \"cycle\":\n          seqType = SequenceType.Cycle;\n          break;\n        case \"shuffle\":\n          seqType = SequenceType.Shuffle;\n          break;\n        case \"stopping\":\n          seqType = SequenceType.Stopping;\n          break;\n      }\n    }\n\n    if (seqType === null) {\n      return null;\n    }\n\n    return seqType;\n  };\n\n  public readonly InnerSequenceObjects = (): ContentList[] => {\n    const multiline = this.Parse(this.Newline) !== null;\n\n    let result: ContentList[] | null = null;\n    if (multiline) {\n      result = this.Parse(this.InnerMultilineSequenceObjects) as ContentList[];\n    } else {\n      result = this.Parse(this.InnerInlineSequenceObjects) as ContentList[];\n    }\n\n    return result;\n  };\n\n  public readonly InnerInlineSequenceObjects = (): ContentList[] | null => {\n    const interleavedContentAndPipes = this.Interleave<ParsedObject>(\n      this.Optional(this.MixedTextAndLogic),\n      this.String(\"|\"),\n      null,\n      false\n    );\n\n    if (interleavedContentAndPipes === null) {\n      return null;\n    }\n\n    const result = [];\n\n    // The content and pipes won't necessarily be perfectly interleaved in the sense that\n    // the content can be missing, but in that case it's intended that there's blank content.\n    let justHadContent: boolean = false;\n    for (const contentOrPipe of interleavedContentAndPipes) {\n      // Pipe/separator\n      if ((contentOrPipe as any) === \"|\") {\n        // Expected content, saw pipe - need blank content now\n        if (!justHadContent) {\n          // Add blank content\n          result.push(new ContentList());\n        }\n\n        justHadContent = false;\n      } else {\n        // Real content\n        const content = contentOrPipe as any;\n        if (content === null) {\n          this.Error(\n            `Expected content, but got ${contentOrPipe} (this is an ink compiler bug!)`\n          );\n        } else {\n          result.push(new ContentList(content));\n        }\n\n        justHadContent = true;\n      }\n    }\n\n    // Ended in a pipe? Need to insert final blank content\n    if (!justHadContent) {\n      result.push(new ContentList());\n    }\n\n    return result;\n  };\n\n  public readonly InnerMultilineSequenceObjects = (): ContentList[] | null => {\n    this.MultilineWhitespace();\n\n    const contentLists = this.OneOrMore(\n      this.SingleMultilineSequenceElement\n    ) as ContentList[];\n    if (contentLists === null) {\n      return null;\n    }\n\n    return contentLists;\n  };\n\n  public readonly SingleMultilineSequenceElement = () => {\n    this.Whitespace();\n\n    // Make sure we're not accidentally parsing a divert\n    if (this.ParseString(\"->\") !== null) {\n      return null;\n    }\n\n    if (this.ParseString(\"-\") === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const content: ParsedObject[] = this.StatementsAtLevel(\n      StatementLevel.InnerBlock\n    );\n\n    if (content === null) {\n      this.MultilineWhitespace();\n    } else {\n      // Add newline at the start of each branch\n      content.unshift(new Text(\"\\n\"));\n    }\n\n    return new ContentList(content);\n  };\n\n  /**\n   * End Sequences section.\n   */\n\n  /**\n   * Begin Statements section.\n   */\n\n  private _statementRulesAtLevel: ParseRule[][] = [];\n  private _statementBreakRulesAtLevel: ParseRule[][] = [];\n\n  public readonly StatementsAtLevel = (\n    level: StatementLevel\n  ): ParsedObject[] => {\n    // Check for error: Should not be allowed gather dashes within an inner block\n    if (level === StatementLevel.InnerBlock) {\n      const badGatherDashCount = this.Parse(this.GatherDashes) as ParsedObject;\n      if (badGatherDashCount !== null) {\n        this.Error(\n          \"You can't use a gather (the dashes) within the { curly braces } context. For multi-line sequences and conditions, you should only use one dash.\"\n        );\n      }\n    }\n\n    return this.Interleave<ParsedObject>(\n      this.Optional(this.MultilineWhitespace),\n      () => this.StatementAtLevel(level),\n      () => this.StatementsBreakForLevel(level)\n    );\n  };\n\n  public readonly StatementAtLevel = (level: StatementLevel): ParsedObject => {\n    const rulesAtLevel: ParseRule[] =\n      this._statementRulesAtLevel[level as number];\n    const statement = this.OneOf(rulesAtLevel) as ReturnType;\n\n    // For some statements, allow them to parse, but create errors, since\n    // writers may think they can use the statement, so it's useful to have\n    // the error message.\n    if (level === StatementLevel.Top) {\n      if (statement instanceof ReturnType) {\n        this.Error(\"should not have return statement outside of a knot\");\n      }\n    }\n\n    return statement;\n  };\n\n  public readonly StatementsBreakForLevel = (\n    level: StatementLevel\n  ): ParseRuleReturn => {\n    this.Whitespace();\n\n    const breakRules: ParseRule[] =\n      this._statementBreakRulesAtLevel[level as number];\n    const breakRuleResult = this.OneOf(breakRules);\n    if (breakRuleResult === null) {\n      return null;\n    }\n\n    return breakRuleResult;\n  };\n\n  public readonly GenerateStatementLevelRules = () => {\n    const levels = Object.values(StatementLevel);\n\n    this._statementRulesAtLevel = \"f\"\n      .repeat(levels.length)\n      .split(\"f\")\n      .map(() => []);\n\n    this._statementBreakRulesAtLevel = \"f\"\n      .repeat(levels.length)\n      .split(\"f\")\n      .map(() => []);\n\n    for (const level of levels) {\n      const rulesAtLevel: ParseRule[] = [];\n      const breakingRules: ParseRule[] = [];\n\n      // Diverts can go anywhere\n      rulesAtLevel.push(this.Line(this.MultiDivert));\n\n      // Knots can only be parsed at Top/Global scope\n      if (level >= StatementLevel.Top) {\n        rulesAtLevel.push(this.KnotDefinition);\n      }\n\n      rulesAtLevel.push(this.Line(this.Choice));\n\n      rulesAtLevel.push(this.Line(this.AuthorWarning));\n\n      // Gather lines would be confused with multi-line block separators, like\n      // within a multi-line if statement\n      if (level > StatementLevel.InnerBlock) {\n        rulesAtLevel.push(this.Gather);\n      }\n\n      // Stitches (and gathers) can (currently) only go in Knots and top level\n      if (level >= StatementLevel.Knot) {\n        rulesAtLevel.push(this.StitchDefinition);\n      }\n\n      // Global variable declarations can go anywhere\n      rulesAtLevel.push(this.Line(this.ListDeclaration));\n      rulesAtLevel.push(this.Line(this.VariableDeclaration));\n      rulesAtLevel.push(this.Line(this.ConstDeclaration));\n      rulesAtLevel.push(this.Line(this.ExternalDeclaration));\n\n      // Global include can go anywhere\n      rulesAtLevel.push(this.Line(this.IncludeStatement));\n\n      // Normal logic / text can go anywhere\n      rulesAtLevel.push(this.LogicLine);\n      rulesAtLevel.push(this.LineOfMixedTextAndLogic);\n\n      // --------\n      // Breaking rules\n\n      // Break current knot with a new knot\n      if (level <= StatementLevel.Knot) {\n        breakingRules.push(this.KnotDeclaration);\n      }\n\n      // Break current stitch with a new stitch\n      if (level <= StatementLevel.Stitch) {\n        breakingRules.push(this.StitchDeclaration);\n      }\n\n      // Breaking an inner block (like a multi-line condition statement)\n      if (level <= StatementLevel.InnerBlock) {\n        breakingRules.push(this.ParseDashNotArrow);\n        breakingRules.push(this.String(\"}\"));\n      }\n\n      this._statementRulesAtLevel[level as number] = rulesAtLevel;\n      this._statementBreakRulesAtLevel[level as number] = breakingRules;\n    }\n  };\n\n  public readonly SkipToNextLine = (): typeof ParseSuccess => {\n    this.ParseUntilCharactersFromString(\"\\n\\r\");\n    this.ParseNewline();\n\n    return ParseSuccess;\n  };\n\n  // Modifier to turn a rule into one that expects a newline on the end.\n  // e.g. anywhere you can use \"MixedTextAndLogic\" as a rule, you can use\n  // \"Line(MixedTextAndLogic)\" to specify that it expects a newline afterwards.\n  public readonly Line =\n    (inlineRule: ParseRule): ParseRule =>\n    () => {\n      const result = this.ParseObject(inlineRule);\n      if (result === null) {\n        return null;\n      }\n\n      this.Expect(this.EndOfLine, \"end of line\", this.SkipToNextLine);\n\n      return result;\n    };\n\n  /**\n   * End Statements section.\n   */\n\n  /**\n   * Begin Tags section.\n   */\n\n  public readonly StartTag = (): ParsedObject | null => {\n    this.Whitespace();\n\n    if (this.ParseString(\"#\") === null) {\n      return null;\n    }\n\n    if (this.parsingStringExpression) {\n      this.Error(\n        \"Tags aren't allowed inside of strings. Please use \\\\# if you want a hash symbol.\"\n      );\n    }\n\n    let result: ParsedObject | null = null;\n    if (this.tagActive) {\n      let contentList = new ContentList();\n      contentList.AddContent(new Tag(/*isStart:*/ false));\n      contentList.AddContent(new Tag(/*isStart:*/ true));\n      result = contentList;\n    } else {\n      result = new Tag(/*isStart:*/ true);\n    }\n    this.tagActive = true;\n\n    this.Whitespace();\n\n    return result;\n  };\n\n  public EndTagIfNecessary(outputContentList: ParsedObject[] | null): void;\n  public EndTagIfNecessary(outputContentList: ContentList | null): void;\n  public EndTagIfNecessary(\n    outputContentList: ParsedObject[] | ContentList | null\n  ): void {\n    if (this.tagActive) {\n      if (outputContentList != null) {\n        if (outputContentList instanceof ContentList) {\n          outputContentList.AddContent(new Tag(/*isStart:*/ false));\n        } else {\n          outputContentList.push(new Tag(/*isStart:*/ false));\n        }\n      }\n      this.tagActive = false;\n    }\n  }\n\n  /**\n   * End Tags section.\n   */\n\n  /**\n   * Begin Whitespace section.\n   */\n\n  private _inlineWhitespaceChars: CharacterSet = new CharacterSet(\" \\t\");\n\n  // Handles both newline and endOfFile\n  public readonly EndOfLine = () => this.OneOf([this.Newline, this.EndOfFile]);\n\n  // Allow whitespace before the actual newline\n  public readonly Newline = (): typeof ParseSuccess | null => {\n    this.Whitespace();\n\n    const gotNewline: boolean = this.ParseNewline() !== null;\n\n    // Optional \\r, definite \\n to support Windows (\\r\\n) and Mac/Unix (\\n)\n\n    if (!gotNewline) {\n      return null;\n    }\n\n    return ParseSuccess;\n  };\n\n  public readonly EndOfFile = (): typeof ParseSuccess | null => {\n    this.Whitespace();\n\n    if (!this.endOfInput) return null;\n\n    return ParseSuccess;\n  };\n\n  // General purpose space, returns N-count newlines (fails if no newlines)\n  public readonly MultilineWhitespace = (): typeof ParseSuccess | null => {\n    let newlines: ParseRuleReturn[] | null = this.OneOrMore(this.Newline);\n    if (newlines === null) {\n      return null;\n    }\n\n    // Use content field of Token to say how many newlines there were\n    // (in most circumstances it's unimportant)\n    const numNewlines: number = newlines.length;\n    if (numNewlines >= 1) {\n      return ParseSuccess;\n    }\n\n    return null;\n  };\n\n  public readonly Whitespace = (): typeof ParseSuccess | null => {\n    const doneParsed = this.ParseCharactersFromCharSet(\n      this._inlineWhitespaceChars\n    );\n\n    if (doneParsed !== null) {\n      return ParseSuccess;\n    }\n\n    return null;\n  };\n\n  public readonly Spaced =\n    (rule: ParseRule): ParseRule =>\n    () => {\n      this.Whitespace();\n\n      const result = this.ParseObject(rule);\n      if (result === null) {\n        return null;\n      }\n\n      this.Whitespace();\n\n      return result;\n    };\n\n  public readonly AnyWhitespace = (): typeof ParseSuccess | null => {\n    let anyWhitespace: boolean = false;\n\n    while (this.OneOf([this.Whitespace, this.MultilineWhitespace]) !== null) {\n      anyWhitespace = true;\n    }\n\n    return anyWhitespace ? ParseSuccess : null;\n  };\n\n  public readonly MultiSpaced =\n    (rule: ParseRule): ParseRuleReturn =>\n    () => {\n      this.AnyWhitespace();\n\n      const result = this.ParseObject(rule);\n      if (result === null) {\n        return null;\n      }\n\n      this.AnyWhitespace();\n\n      return result;\n    };\n\n  private _filename: string | null = null;\n  private _externalErrorHandler: ErrorHandler | null = null;\n  private _fileHandler: IFileHandler | null = null;\n\n  /**\n   * End Whitespace section.\n   */\n}\n","import { IFileHandler } from \"../IFileHandler\";\n\nexport class JsonFileHandler implements IFileHandler {\n  constructor(public readonly fileHierarchy: Record<string, string>) {}\n\n  readonly ResolveInkFilename = (filename: string): string => {\n    if (Object.keys(this.fileHierarchy).includes(filename)) return filename;\n    throw new Error(\n      `Cannot locate ${filename}. Are you trying a relative import ? This is not yet implemented.`\n    );\n  };\n\n  readonly LoadInkFileContents = (filename: string): string => {\n    if (Object.keys(this.fileHierarchy).includes(filename)) {\n      return this.fileHierarchy[filename];\n    } else {\n      throw new Error(`Cannot open ${filename}.`);\n    }\n  };\n}\n","import { CompilerOptions } from \"./CompilerOptions\";\nimport { DebugSourceRange } from \"./DebugSourceRange\";\nimport { ErrorType } from \"./Parser/ErrorType\";\nimport { InkParser } from \"./Parser/InkParser\";\nimport { Story } from \"../engine/Story\";\nimport { Story as ParsedStory } from \"./Parser/ParsedHierarchy/Story\";\nimport { DebugMetadata } from \"../engine/DebugMetadata\";\nimport { StringValue } from \"../engine/Value\";\nimport { asOrNull } from \"../engine/TypeAssertion\";\n\nexport { CompilerOptions } from \"./CompilerOptions\";\nexport { InkParser } from \"./Parser/InkParser\";\nexport { StatementLevel } from \"./Parser/StatementLevel\";\nexport { JsonFileHandler } from \"./FileHandler/JsonFileHandler\";\nexport { InkList, Story } from \"../engine/Story\";\n\nexport class Compiler {\n  private _errors: string[] = [];\n  get errors(): string[] {\n    return this._errors;\n  }\n\n  private _warnings: string[] = [];\n  get warnings(): string[] {\n    return this._warnings;\n  }\n\n  private _authorMessages: string[] = [];\n  get authorMessages(): string[] {\n    return this._authorMessages;\n  }\n\n  private _inputString: string;\n  get inputString(): string {\n    return this._inputString;\n  }\n\n  private _options: CompilerOptions;\n  get options(): CompilerOptions {\n    return this._options;\n  }\n\n  private _parsedStory: ParsedStory | null = null;\n  get parsedStory(): ParsedStory {\n    if (!this._parsedStory) {\n      throw new Error();\n    }\n\n    return this._parsedStory;\n  }\n\n  private _runtimeStory: Story | null = null;\n  get runtimeStory(): Story {\n    if (!this._runtimeStory) {\n      throw new Error(\"Compilation failed.\");\n    }\n\n    return this._runtimeStory;\n  }\n\n  private _parser: InkParser | null = null;\n  get parser(): InkParser {\n    if (!this._parser) {\n      throw new Error();\n    }\n\n    return this._parser;\n  }\n\n  private _debugSourceRanges: DebugSourceRange[] = [];\n  get debugSourceRanges(): DebugSourceRange[] {\n    return this._debugSourceRanges;\n  }\n\n  constructor(inkSource: string, options: CompilerOptions | null = null) {\n    this._inputString = inkSource;\n    this._options = options || new CompilerOptions();\n  }\n\n  public readonly Compile = (): Story => {\n    this._parser = new InkParser(\n      this.inputString,\n      this.options.sourceFilename || null,\n      this.OnError,\n      null,\n      this.options.fileHandler\n    );\n\n    this._parsedStory = this.parser.ParseStory();\n\n    if (this.errors.length === 0) {\n      this.parsedStory.countAllVisits = this.options.countAllVisits;\n      this._runtimeStory = this.parsedStory.ExportRuntime(this.OnError);\n    } else {\n      this._runtimeStory = null;\n    }\n\n    return this.runtimeStory;\n  };\n\n  public readonly RetrieveDebugSourceForLatestContent = (): void => {\n    for (const outputObj of this.runtimeStory.state.outputStream) {\n      const textContent = asOrNull(outputObj, StringValue);\n      if (textContent !== null) {\n        const range = new DebugSourceRange(\n          textContent.value?.length || 0,\n          textContent.debugMetadata,\n          textContent.value || \"unknown\"\n        );\n\n        this.debugSourceRanges.push(range);\n      }\n    }\n  };\n\n  public readonly DebugMetadataForContentAtOffset = (\n    offset: number\n  ): DebugMetadata | null => {\n    let currOffset = 0;\n\n    let lastValidMetadata: DebugMetadata | null = null;\n    for (const range of this.debugSourceRanges) {\n      if (range.debugMetadata !== null) {\n        lastValidMetadata = range.debugMetadata;\n      }\n\n      if (offset >= currOffset && offset < currOffset + range.length) {\n        return lastValidMetadata;\n      }\n\n      currOffset += range.length;\n    }\n\n    return null;\n  };\n\n  public readonly OnError = (message: string, errorType: ErrorType) => {\n    switch (errorType) {\n      case ErrorType.Author:\n        this._authorMessages.push(message);\n        break;\n\n      case ErrorType.Warning:\n        this._warnings.push(message);\n        break;\n\n      case ErrorType.Error:\n        this._errors.push(message);\n        break;\n    }\n\n    if (this.options.errorHandler !== null) {\n      this.options.errorHandler(message, errorType);\n    }\n  };\n}\n"],"names":["ErrorType","CompilerOptions","_createClass","sourceFilename","arguments","length","undefined","pluginNames","countAllVisits","errorHandler","fileHandler","_classCallCheck","this","DebugSourceRange","debugMetadata","text","Argument","identifier","isByReference","isDivertTarget","key","get","asOrNull","obj","type","unsafeTypeAssertion","asOrThrows","Error","concat","asINamedContentOrNull","hasValidName","name","nullIfUndefined","isEquatable","_typeof","Equals","filterUndef","element","Debug","ParsedObject","_this","_alreadyHadError","_alreadyHadWarning","_debugMetadata","_runtimeObject","content","parent","GetType","typeName","AddContent","subContent","_step","_iterator","_createForOfIteratorHelper","Array","isArray","s","n","done","ss","value","hasOwnProperty","push","err","e","f","InsertContent","index","splice","Find","queryFunc","tObj","_step2","_iterator2","nestedResult","FindAll","foundSoFar","found","_step3","_iterator3","Warning","message","source","set","Boolean","ancestor","GenerateRuntimeObject","runtimeObject","path","result","reverse","context","_step4","_iterator4","ResolveReferences","_Error","_x","apply","toString","isWarning","AuthorWarning","_ParsedObject","_inherits","_super","_createSuper","warningMessage","call","Path","_components","_componentsString","_isRelative","componentsString","Component","head","tail","relative","slice","self","lastComponentIdx","i","l","isIndex","pathToAppend","p","upwardMoves","isParent","join","isRelative","substring","split","str","test","parseInt","otherPath","c","_p$_components","_toConsumableArray","parentId","indexOrName","otherComp","Assert","condition","console","warn","trace","AssertType","variable","NullException","_wrapNativeSuper","throwNullException","InkObject","_path","root","rootContentContainer","targetContent","ContentAtPath","dm","startLineNumber","comps","child","container","Container","namedChild","unshift","indexOf","nearestContainer","GetComponent","contentContainer","globalPath","ownPath","minPathLength","Math","min","lastSharedPathCompIndex","ownComp","numUpwardsMoves","componentCount","newPathComps","up","ToParent","down","globalPathStr","relativePathStr","PathByAppendingPath","ConvertPathToRelative","prop","StringBuilder","string","Append","format","_len","args","_key","replace","match","num","InkListItem","originName","itemName","nameParts","fullName","otherItem","JSON","stringify","parse","isLikeInkListItem","Null","inkListItem","item","InkList","_Map","_arguments","origins","_originNames","otherList","otherOriginNames","originNames","singleOriginListName","originStory","SetInitialOriginName","listDefinitions","_possibleConstructorReturn","def","TryListGetDefinition","exists","singleElement","Add","Key","Value","itemOrItemName","AddItem","origin","intVal","TryGetValueForItem","foundListDef","ContainsItemWithName","itemVal","ValueForItem","_slicedToArray","fromSerializedKey","has","serialized","serializedKey","delete","size","maxOriginName","maxItem","every","Count","initialOriginName","initialOriginNames","_step5","max","_iterator5","_step5$value","isNull","_step6","_iterator6","_step6$value","list","_step7","_iterator7","_step8","_iterator8","items","_step8$value","ContainsKey","_step9","_iterator9","_step10","_iterator10","_step10$value","_step11","union","_iterator11","_step11$value","_step12","intersection","_iterator12","_step12$value","_step13","_iterator13","listToRemove","_step14","_iterator14","what","ContainsItemNamed","_step15","_iterator15","minItem","minBound","maxBound","ordered","orderedItems","minValue","maxValue","Number","MAX_SAFE_INTEGER","isInteger","subList","SetInitialOriginNames","_step16","_iterator16","otherInkList","_step17","_iterator17","_step18","_iterator18","_step18$value","sort","x","y","localeCompare","sb","NaN","myListItem","listValue","_a","FindSingleItemListWithName","Map","StoryException","useEndLineNumber","tryGetValueFromMap","map","val","AbstractValue","ValueType","_InkObject","Create","valueObject","targetType","valueType","preferredNumberType","Int","IntValue","Float","isNaN","FloatValue","BoolValue","StringValue","String","DivertTargetValue","ListValue","_AbstractValue","_super2","_Value","_super3","Bool","newType","BadCastException","_Value2","_super4","_Value3","_super5","_Value4","_super6","_this2","_isNewline","_isInlineWhitespace","isNewline","isInlineWhitespace","parsedInt","defaultValue","tryParseInt","parsedFloat","parseFloat","tryParseFloat","_Value5","_super7","targetPath","DivertTarget","VariablePointerValue","_Value6","_super8","variableName","_this3","contextIndex","_contextIndex","VariablePointer","_Value7","_super9","listOrSingleItem","singleValue","_this4","List","oldValue","newValue","oldList","newList","SearchResult","approximate","searchResult","_content","namedContent","visitsShouldBeCounted","turnIndexShouldBeCounted","countingAtStartOnly","_pathToFirstLeafContent","namedOnlyContentDict","_step$value","inkObject","named","existingNamedOnly","namedOnlyContent","AddToNamedContentOnly","flags","CountFlags","Visits","Turns","CountStartOnly","flag","internalPathToFirstLeafContent","components","contentObjOrList","contentObj","TryAddNamedContent","namedContentObj","partialPathStart","partialPathLength","currentContainer","currentObj","comp","foundObj","ContentWithPathComponent","otherContainer","_this$content","component","foundContent","BuildStringOfHierarchy","indentation","pointedObj","appendIndentation","AppendFormat","AppendLine","onlyNamed","_step7$value","ControlCommand","commandType","CommandType","NotSet","_commandType","EvalStart","EvalOutput","EvalEnd","Duplicate","PopEvaluatedValue","PopFunction","PopTunnel","BeginString","EndString","NoOp","ChoiceCount","TurnsSince","ReadCount","Random","SeedRandom","VisitIndex","SequenceShuffleIndex","StartThread","Done","End","ListFromInt","ListRange","ListRandom","BeginTag","EndTag","Expression","_prototypeRuntimeConstantExpression","outputWhenComplete","RuntimeContainer","RuntimeControlCommand","GenerateIntoContainer","GenerateConstantIntoContainer","copy","Copy","Void","NativeFunctionCall","_name","_numberOfParameters","_prototype","_isPrototype","_operationFuncs","GenerateNativeFunctionsIfNecessary","numberOfParameters","_nativeFunctions","parameters","Call","hasList","CallBinaryListOperation","coercedParams","CoerceValuesToSingleType","coercedType","CallType","parametersOfSingleType","param1","valType","val1","paramCount","opForTypeObj","val2","opForType","resultVal","CallListIncrementOperation","v1","v2","op","asBooleanOrThrows","isTruthy","listIntParams","listVal","resultInkList","_step2$value","listItemKey","listItemValue","listItem","intOp","targetInt","itemOrigin","incrementedItem","TryGetItemWithValue","parametersIn","specialCaseList","parametersOut","originOfMaxItem","castedValue","Cast","functionName","t","AddIntBinaryOp","Subtract","Multiply","Divide","floor","Mod","AddIntUnaryOp","Negate","Equal","Greater","Less","GreaterThanOrEquals","LessThanOrEquals","NotEquals","Not","And","Or","Max","Min","Pow","pow","Floor","Identity","Ceiling","AddFloatBinaryOp","AddFloatUnaryOp","ceil","AddStringBinaryOp","Has","includes","Hasnt","AddListBinaryOp","Union","Without","Contains","Intersect","GreaterThan","LessThan","AddListUnaryOp","Invert","inverse","All","all","ListMin","MinAsList","ListMax","MaxAsList","ValueOfList","AddOpToNativeFunc","d1","d2","nativeFunc","AddOpFuncForType","NumberExpression","_Expression","subtype","isInt","isFloat","isBool","numberExpression","UnaryExpression","inner","innerExpression","CallWithName","nativeNameForOp","WithInner","innerNumber","BinaryExpression","left","right","opName","leftExpression","rightExpression","NativeNameForOp","_get","_getPrototypeOf","prototype","leftUnary","CharacterSet","arg","Set","add","AddRange","start","end","charCodeAt","fromCharCode","AddCharacters","chars","FromRange","CharacterRange","_start","_end","excludes","_correspondingCharSet","_excludes","ToCharacterSet","ii","Define","ChoicePoint","PushPopType","onceOnly","_pathOnChoice","hasCondition","hasStartContent","hasChoiceOnlyContent","isInvisibleDefault","choiceTargetObj","choiceTarget","ResolvePath","pathOnChoice","CompactPathString","SymbolType","Pointer","PathByAppendingComponent","Divert","stackPushType","_targetPath","_targetPointer","variableDivertName","pushesToStack","isExternal","externalArgs","isConditional","targetObj","targetPointer","Resolve","lastComponent","StartOf","otherDivert","hasVariableTarget","targetStr","Function","targetPathString","VariableAssignment","isNewDeclaration","isGlobal","Choice","startContent","choiceOnlyContent","innerContent","_condition","_innerContentContainer","_outerContainer","_runtimeChoice","_returnToR1","_returnToR2","_r1Label","_r2Label","_divertToStartContentOuter","_divertToStartContentInner","_startContentRuntimeContainer","hasWeaveStyleInlineBrackets","varAssign","RuntimeVariableAssignment","RuntimeDivert","varDivert","choiceOnlyRuntimeContent","AddContentsOfContainer","innerChoiceOnlyContent","story","indentationDepth","innerContentContainer","runtimeChoice","CheckForNamingCollisions","SubFlowAndWeave","StringParserElement","characterIndex","characterInLineIndex","lineIndex","reportedErrorInScope","uniqueId","customFlags","CopyFrom","fromElement","_uniqueIdCounter","SquashFrom","StringParserState","_stack","_numElements","Push","prevElement","newElement","Pop","expectedRuleId","currentElement","Peek","PeekPenultimate","Squash","penultimateEl","lastEl","NoteErrorReported","ParseSuccess","Symbol","StringParser","ParseRule","hadError","BeginRule","state","FailRule","CancelRule","SucceedRule","stateAtSucceedRule","stateAtBeginRule","RuleDidSucceed","finalResult","Expect","rule","recoveryRule","ParseObject","butSaw","lineRemainder","LineRemainder","ErrorOnLine","ErrorWithParsedObject","lineNumber","errorReportedAlreadyInScope","errorType","ParseUntilCharactersFromString","SetFlag","trueOrFalse","GetFlag","ruleId","stackHeightBefore","stackHeight","Parse","OneOf","array","OneOrMore","results","Optional","Exclude","OptionalExclude","ParseString","TryAddResultToList","flatten","Interleave","ruleA","ruleB","untilTerminator","firstA","lastMainResult","outerResult","remainingLength","cli","li","success","tempIdx","_chars","ParseSingleCharacter","maxCount","ParseCharactersFromString","ParseUntilCharactersFromCharSet","charSet","ParseCharactersFromCharSet","maxCountOrShouldIncludeStrChars","shouldIncludeChars","startIndex","count","ParseInt","oldIndex","oldCharacterInLineIndex","negative","parsedString","numbersCharacterSet","MIN_SAFE_INTEGER","ParseFloat","leadingInt","afterDecimalPointStr","ParseNewline","strPreProc","PreProcessInputString","inputString","stopRule","pauseCharacters","endCharacters","pauseAndEnd","values","partialParsedString","endOfInput","pauseCharacter","currentCharacter","CommentEliminator","FlowLevel","_StringParser","_commentOrNewlineStartCharacter","_commentBlockEndCharacter","_newlineCharacters","Process","stringList","CommentsAndNewlines","MainInk","ParseUntil","newLines","ParseSingleComment","EndOfLineComment","BlockComment","startLineIndex","commentResult","repeat","Conditional","initialCondition","branches","_reJoinTarget","branchContainer","ownExpression","isElse","pathToReJoin","branch","returnDivert","Text","ConstantDeclaration","assignedExpression","_expression","constantIdentifier","Var","Gather","_b","argOne","argTwo","_dotSeparatedComponents","baseTargetLevel","WeavePoint","dotSeparatedComponents","ResolveFromContext","baseTargetObject","ResolveBaseTarget","ResolveTailComponents","originalContext","firstComp","firstComponent","ancestorContext","deepSearch","foundBase","GetChildFromContext","rootTarget","foundComponent","compName","minimumExpectedLevel","foundFlow","FlowBase","flowLevel","childName","minimumLevel","forceDeepSearch","ambiguousChildLevel","weaveContext","Weave","WeavePointNamed","flowContext","shouldDeepSearch","Knot","ContentWithNameAtLevel","Object","_baseTargetLevel","baseLevelIsAmbiguous","Story","filter","ReturnType","returnedExpression","ClosestFlowBase","iamFlowbase","Identifier","topLevelObjects","isFunction","isIncludedStory","_rootWeave","_subFlowsByName","_startingSubFlowDivert","_startingSubFlowRuntime","_firstChildFlow","variableDeclarations","SplitWeaveAndSubFlowContent","contentObjs","isRootStory","weaveObjs","subFlowObjs","subFlow","finalContent","ResolveVariableWithName","varName","fromNode","ownerFlow","_assertThisInitialized","isArgument","isTemporary","AddNewVariableDeclaration","varDecl","varab","prevDeclError","ResolveWeavePointNaming","foundReturn","CheckForDisallowedFunctionFlowControl","Stitch","GenerateArgumentVariableAssignments","contentIdx","childFlow","childFlowRuntime","hasParameters","existingChild","errorMsg","ValidateTermination","WarningInTermination","paramName","assign","level","weavePointResult","DeepSearchForAnyLevelContent","weaveResultSelf","deepResult","divert","isFunctionCall","choice","terminatingObject","terminatingDivert","isTunnel","target","PreProcessTopLevelObjects","_","Arg","jj","symbolType","ContentList","objects","dontFlatten","TrimTrailingWhitespace","RegExp","contentObjRuntime","DontFlattenContainer","moreObjects","VariableReference","pathForCount","pathStringForCount","pathIdentifiers","_runtimeVarRef","isConstantReference","isListItemReference","constantValue","constants","RuntimeVariableReference","listItemName","listName","ResolveListItem","id","parsedPath","targetForCount","containerForCounting","runtimePath","targetFlow","FunctionCall","_divertTargetToCount","_variableReferenceToCount","shouldPopReturnedValue","foundList","ResolveList","usingProxyDivert","isChoiceCount","isTurns","isTurnsSince","isReadCount","divertTarget","variableDivertTarget","isRandom","isSeedRandom","isListRange","isListRandom","CallExistsWithName","nativeCall","msg","RuntimeInkList","_proxyDivert","strArgs","runtimeDivert","attemptingTurnCountOfVariableTarget","targetObject","runtimeVarRef","IsBuiltIn","MultipleConditionExpression","SequenceType","conditionExpressions","isFirst","subExpressions","_runtimeDivert","_runtimeDivertTargetValue","runtimeDivertTargetValue","otherDivTarget","isDone","isEnd","usageContext","badUsage","foundUsage","usageParent","binaryExprParent","funcCall","ConditionalSingleBranch","parentFunc","isEmpty","isThread","ResolveTargetContent","CheckArgumentValidity","requiresArgCodeGen","targetArguments","argToPass","argExpected","varRef","varPointer","Tunnel","PathAsVariableName","variableTargetName","flowBaseScope","resolveResult","argument","find","a","numArgs","butClause","flowArg","divArgExpr","knotCountPath","CheckExternalArgumentValidity","externalName","external","externals","externalArgCount","argumentNames","ownArgCount","returnString","targetWasFound","isBuiltIn","numberOfComponents","IsExternal","RuntimePath","GatherPointToResolve","targetRuntimeObj","SequenceDivertToResolve","Sequence","CustomFlags","elementContentLists","sequenceType","_sequenceDivertsToResolve","once","Once","cycle","Cycle","stopping","Stopping","shuffle","Shuffle","seqBranchCount","sequenceElements","postShuffleNoOp","lastIdx","skipShuffleDivert","AddDivertToResolve","elementCountToShuffle","postSequenceNoOp","elIndex","sequenceDivert","contentContainerForSequenceBranch","seqBranchCompleteDivert","elementContentList","seqElObject","toResolve","TunnelOnwards","_overrideDivertTarget","_divertAfter","divertAfter","returnRuntimeObj","returnRuntimeContainer","evalStart","evalEnd","cmd","returnDivertObj","ListDefinition","_items","_itemNameToValues","itemDefinitions","variableAssignment","_elementsByName","ItemNamed","el","initialValues","itemDef","inInitialList","RuntimeInkListItem","seriesValue","currentValue","explicitValue","allItems","RuntimeListDefinition","_ref","isGlobalDeclaration","isTemporaryNewDeclaration","listDef","variableIdentifier","_runtimeAssignment","expression","listDefinition","newDeclScope","isNewTemporaryDeclaration","isDeclaration","Temp","variableReference","resolvedVarAssignment","cont","indentIndex","previousWeavePoint","addContentToPreviousWeavePoint","hasSeenChoiceInSection","_unnamedGatherCount","_choiceCount","_rootContainer","_namedWeavePoints","looseEnds","gatherPointsToResolve","namedWeavePoints","w","weavePoint","existingWeavePoint","existingObj","_c","ConstructWeaveHierarchyFromIndentation","weaveIndentIdx","baseIndentIndex","innerWeaveStartIdx","innerWeaveObj","weaveContentCount","weaveContent","weave","DetermineBaseIndentationFromContent","contentList","AddRuntimeForWeavePoint","_this$gatherPointsToR","AddRuntimeForNestedWeave","AddGeneralRuntimeContent","PassLooseEndsToAncestors","AddRuntimeForGather","gather","autoEnter","gatherContainer","runtimeContainer","rootContainer","looseEnd","looseWeavePoint","WeavePointHasLooseEnd","closestInnerWeaveAncestor","closestOuterWeaveAncestor","nested","weaveAncestor","received","ReceiveLooseEnd","receivingWeave","childWeaveLooseEnd","IsGlobalDeclaration","varAss","ContentThatFollowsWeavePoint","returned","parentWeave","laterObj","badTerminationHandler","lastParsedSignificantObject","looseEndFlow","ValidateFlowOfObjectsTerminates","BadNestedTerminationHandler","terminatingObj","conditional","toLowerCase","objFlow","defaultObj","terminated","flowObj","d","innerDivert","CheckForWeavePointNamingCollisions","ancestorFlows","ancestry","flow","weavePointName","otherContentWithName","lastObject","lastText","lastWeave","isNestedWeave","gatherPoint","_contentContainer","_conditionalDivert","_ownExpression","_innerWeave","isTrueBranch","matchingEquality","isInline","startsWith","duplicatesStackValue","needsEval","GenerateRuntimeForContent","StatementLevel","DebugMetadata","endLineNumber","startCharacterNumber","endCharacterNumber","fileName","sourceName","newDebugMetadata","ExternalDeclaration","AddExternal","FlowDecl","Glue","_Wrap","glue","Wrap","_objToWrap","IncDecExpression","varIdentifier","isIncOrExpression","isInc","varResolveResult","incrementDecrementWord","IncludedFile","includedStory","InfixOperator","precedence","requireWhitespace","_FlowBase","parentStory","stitchName","subFlowsByName","knotWithStitchName","stitch","itemIdentifierList","runtimeRawList","itemIdentifier","ListElementDefinition","indentifier","_thisSuper","parentList","ListItem","exports","Tag","tagText","threadAtGeneration","sourcePath","tags","originalThreadIndex","ListDefinitionsOrigin","lists","_lists","_allUnambiguousListValueCache","listOfLists","definition","JsonSerialisation","jArray","skipLast","jTok","runtimeObj","JTokenToRuntimeObject","writer","dictionary","WriteObjectStart","WritePropertyStart","WriteRuntimeObject","WritePropertyEnd","WriteObjectEnd","WriteArrayStart","WriteArrayEnd","dict","_step3$value","WriteIntProperty","WriteRuntimeContainer","divTypeKey","WriteProperty","choicePoint","pathStringOnChoice","boolVal","WriteBool","WriteInt","floatVal","WriteFloat","strVal","Write","WriteStringStart","WriteStringInner","WriteStringEnd","WriteInkList","divTargetVal","varPtrVal","controlCmd","_controlCommandNames","readCountPath","tag","WriteChoice","jObject","token","firstChar","propValue","varPtr","isDivert","divPushType","readCountVarRef","isVarAss","isGlobalVar","isNewDecl","listContent","rawList","namesAsObjs","nameToVal","JObjectToChoice","JArrayToContainer","toJson","me","removes","space","k","v","some","r","withoutName","countFlags","hasNameProperty","hasTerminator","namedContainer","WriteNull","JArrayToRuntimeObjList","namedContentItem","namedSubContainer","jObj","WritePropertyNameStart","WritePropertyNameInner","WritePropertyNameEnd","listDefJson","defsObj","allDefs","nameValueKey","nameValue","TOTAL_VALUES","CallStack","_threadCounter","_startOfRoot","storyContext","Reset","toCopy","_threads","otherThread","callStack","elements","cs","callstack","Thread","Element","jThreadObj","thread","WriteObject","WriteJson","newThread","currentThread","threadIndex","forkedThread","canPopThread","elementIsEvaluateFromGame","FunctionEvaluationFromGame","externalEvaluationStackHeight","outputStreamLengthWithPushed","currentPointer","evaluationStackHeightWhenPushed","functionStartInOutputStream","canPop","CanPop","pop","currentElementIndex","varValue","temporaryVariables","declareNew","contextElement","RetainListOriginsForAssignment","filtered","isCurrent","pointer","inExpressionEvaluation","previousPointer","jElementObj","pushPopType","currentContainerPathStr","currentContainerPathStrToken","threadPointerResult","temps","JObjectToDictionaryRuntimeObjs","clear","prevContentObjPath","prevPath","PointerAtPath","WriteDictionaryRuntimeObjs","resolvedPointer","VariablesState","_VariablesStateAccess","listDefsOrigin","variableChangedEventCallbacks","patch","_batchObservingVariableChanges","_defaultGlobalVariables","_changedVariablesForBatchObs","_globalVariables","_callStack","_listDefsOrigin","Proxy","$","callback","variableChangedEvent","varContents","TryGetGlobal","SetGlobal","globals","namedVarKey","namedVarValue","changedVariables","jToken","varValKey","varValValue","loadedToken","tokenInkObject","keyValKey","keyValValue","dontSaveDefaultValues","defaultVal","RuntimeObjectsEqual","obj1","obj2","constructor","GetRawVariableWithName","ValueAtVariablePointer","variableValue","GetTemporaryVariableWithName","GetVariableWithName","setGlobal","GlobalVariableExistsWithName","ResolveVariablePointer","existingPointer","SetTemporaryVariable","batchObservingVariableChanges","AddChangedVariable","GetContextIndexOfVariableNamed","doubleRedirectionPointer","_class","PRNG","seed","next","StatePatch","_changedVariables","_visitCounts","_turnIndices","_globals","SimpleJson","Reader","ToDictionary","ToArray","_rootObject","Writer","_currentPropertyName","_currentString","_stateStack","_collectionStack","_propertyNameStack","_jsonObject","StartNewObject","newObject","State","Property","currentCollection","currentPropertyName","propertyName","None","StateElement","innerOrContent","IncrementChildCount","childCount","PropertyName","_addToCurrentObject","error","POSITIVE_INFINITY","NEGATIVE_INFINITY","currEl","Flow","SetJsonToken","outputStream","currentChoices","jChoiceThreadsObj","LoadFlowChoiceThreads","WriteListRuntimeObjs","hasChoiceThreads","ThreadWithIndex","jChoiceThreads","foundActiveThread","jSavedChoiceThread","StoryState","kInkSaveStateVersion","kMinCompatibleLoadVersion","onDidLoadState","_currentErrors","_currentWarnings","divertedPointer","_currentTurnIndex","storySeed","previousRandom","didSafeExit","_currentText","_currentTags","_outputStreamTextDirty","_outputStreamTagsDirty","_patch","_aliveFlowNames","_namedFlows","kDefaultFlowName","_aliveFlowNamesDirty","_currentFlow","OutputStreamDirty","_evaluationStack","_variablesState","currentTurnIndex","timeSeed","Date","getTime","GoToStart","indented","ToJson","json","TextToDictionary","LoadJsonObj","pathString","visitCountOut","TryGetVisitCount","containerPathStr","count2","currCount","VisitCountForContainer","SetVisitCount","SetTurnIndex","TryGetTurnIndex","index2","depth","canContinue","hasError","currentErrors","currentWarnings","inTag","outputObj","textContent","controlCommand","CleanOutputWhitespace","currentWhitespaceStart","startOfLine","charAt","Length","txt","Clear","keys","flowName","mainContentContainer","variablesState","SwitchFlow_Internal","SwitchToDefaultFlow_Internal","_copy$_currentFlow$cu","_copy$_currentFlow$ou","_copy$evaluationStack","_copy$_currentErrors","_copy$_currentWarning","_step4$value","namedFlowKey","namedFlowValue","hasWarning","evaluationStack","ApplyPatch","visitCounts","ApplyCountChanges","turnIndices","newCount","isVisit","_loop","WriteIntDictionary","inkVersionCurrent","jSaveVersion","flowsObj","flowsObjDict","_i","_flowsObjDictEntries","entries","_flowsObjDictEntries$","currFlowName","currentDivertTargetPath","divertPath","JObjectToIntDictionary","_this$outputStream","objs","listText","TrySplittingHeadTailWhitespace","textObj","PushToOutputStreamIndividual","single","headFirstNewlineIdx","headLastNewlineIdx","tailLastNewlineIdx","tailFirstNewlineIdx","listTexts","innerStrStart","innerStrEnd","leadingSpaces","innerStrText","numSpaces","trailingSpaces","includeInOutput","TrimNewlinesFromOutputStream","functionTrimIndex","glueTrimIndex","o","isNonWhitespace","RemoveExistingGlue","callStackElements","outputStreamEndsInNewline","outputStreamContainsContent","removeWhitespaceFrom","numberOfObjects","functionStartPoint","popType","TrimWhitespaceFromFunctionEnd","incrementingTurnIndex","newPointer","funcContainer","PassArgumentsToEvaluationStack","PushEvaluationStack","callStackTrace","originalEvaluationStackHeight","returnedObj","poppedObj","PopEvaluationStack","PopCallStack","returnVal","Stopwatch","startTime","nVal","isFinite","inkVersionMinimumCompatible","onError","onDidContinue","onMakeChoice","onEvaluateFunction","onCompleteEvaluateFunction","onChoosePathString","_prevContainers","allowExternalFunctionFallbacks","_listDefinitions","_variableObservers","_hasValidatedExternals","_temporaryEvaluationContainer","_asyncContinueActive","_stateSnapshotAtLastNewline","_sawLookaheadUnsafeFunctionAfterNewline","_recursiveContinueCount","_asyncSaving","_profiler","_mainContentContainer","jsonString","_externals","rootObject","versionObj","formatFromFile","listDefsObj","rootToken","JTokenToListDefinitions","ResetState","choices","_state","IfAsyncWeCant","currentText","currentTags","currentFlowName","currentFlowIsDefaultFlow","aliveFlowNames","shouldReturn","ObserveVariableChange","VariableStateDidChangeEvent","bind","ResetGlobals","ResetErrors","ForceEnd","originalPointer","ChoosePath","ContinueInternal","SnapshotDefaultGlobals","RemoveFlow_Internal","ContinueAsync","millisecsLimitAsync","ValidateExternalBindings","PreContinue","isAsyncTimeLimited","ResetOutput","durationStopwatch","Start","ContinueSingleStep","AddError","ElapsedMilliseconds","Stop","RestoreStateSnapshot","generatedChoices","PostContinue","PreStep","Step","PostStep","TryFollowDefaultInvisibleChoice","PreSnapshot","inStringEvaluation","change","CalculateNewlineOutputStateChange","OutputStateChange","ExtendedBeyondNewline","NewlineRemoved","DiscardSnapshot","StateSnapshot","PostSnapshot","prevText","currText","prevTagCount","currTagCount","newlineStillExists","NoChange","Continue","pathLengthToUse","CopyAndStartPatching","RestoreAfterPatch","ApplyAnyPatch","stateToSave","shouldAddToStream","containerToEnter","VisitContainer","currentContentObj","isLogicOrFlowControl","PerformLogicAndFlowControl","ProcessChoice","contextIdx","ContextForVariableNamed","PushToOutputStream","NextContent","PushThread","atStart","IncrementVisitCountForContainer","RecordTurnIndexVisitToContainer","prevAncestor","currentChildOfContainer","currentContainerAncestor","allChildrenEnteredAtStart","enteringAtStart","choiceOnlyStrVal","PeekEvaluationStack","showChoice","conditionValue","IsTruthy","startText","choiceOnlyText","PopChoiceStringAndTags","ForkThread","divTarget","currentDivert","intContent","errorMessage","CallExternalFunction","evalCommand","output","overrideTunnelReturnTarget","popped","TryExitFunctionEvaluationFromGame","names","expected","contentStackForTag","outputCountConsumed","command","PopFromOutputStream","_contentStackForTag","choiceTag","contentStackForString","contentToRetain","_i3","_contentToRetain","rescuedTag","choiceCount","extraNote","eitherCount","correctObj","TurnsSinceForContainer","maxInt","minInt","randomRange","resultSeed","nextRandom","chosenValue","shuffleIndex","NextSequenceShuffleIndex","PopThread","listNameVal","generatedListValue","foundItem","targetList","ListWithSubRange","listItemIndex","listEnumerator","randomItem","assignedVal","Assign","foundValue","containerForCount","func","funcParams","resetCallstack","ResetCallstack","funcDetail","activityStr","SetChosenPath","VisitChangedContainersDueToDivert","choiceIdx","choiceToChoose","KnotContainerWithName","returnTextOutput","trim","outputStreamBefore","StartFunctionEvaluationFromGame","stringOutput","textOutput","CompleteFunctionEvaluationFromGame","exprContainer","startCallStackHeight","evalStackHeight","funcName","numberOfArguments","funcDef","fallbackFunctionContainer","foundExternal","lookAheadSafe","valueObj","funcResult","function","returnObj","lookaheadSafe","BindExternalFunctionGeneral","coercedArgs","TryCoerce","missingExternals","from","observer","variableNames","observers","ObserveVariable","specificVariableName","variableObservers","newValueObj","TagsAtStartOfFlowContainerWithPathString","flowContainer","firstContent","IncrementContentPointer","didPop","successfulIncrement","nextAncestor","indexInAncestor","allChoices","invisibleChoices","numElementsIntVal","seqContainer","numElements","seqCount","loopIndex","iterationIndex","seqPathStr","sequenceHash","randomSeed","random","unpickedIndices","chosen","chosenIndex","currentDebugMetadata","errorTypeStr","lineNum","toplevelObjects","isInclude","_errorHandler","_hadError","_hadWarning","_dontFlattenContainers","_listDefs","ExportRuntime","constDecl","existingDefinition","constantName","variableInitialisation","runtimeLists","runtimeListDefinition","runtimeVarAss","runtimeStory","RuntimeStory","FlattenContainersIn","originalFoundList","itemInThisList","innerContainers","innerContainer","namedInnerContainer","TryFlattenContainer","parentContainer","ownDebugMetadata","Author","ResetError","namedFuncTarget","decl","NameConflictError","typeNameToPrint","IsReservedKeyword","knotOrFunction","_step9$value","topLevelContent","flowsFromOtherFiles","file","posOfObj","nonFlowContent","subStory","subStoryObj","StringExpression","otherStr","isSingleString","isStart","inChoice","DefaultFileHandler","rootPath","ResolveInkFilename","LoadInkFileContents","InkParser","filename","externalErrorHandler","rootParser","ParseStory","StatementsAtLevel","Top","_rootParser","SeparatedList","mainRule","separatorRule","firstElement","allElements","nextElementRuleId","nextElement","CreateDebugMetadata","stateAtStart","stateAtEnd","md","_filename","parsedObj","parsedListObjs","parsedListObj","hasOwnDebugMetadata","OnStringParserError","fullMessage","_externalErrorHandler","Whitespace","IdentifierWithMetadata","ExtendIdentifierCharacterRanges","identifierCharSet","ListAllCharacterRanges","charRange","_parsingChoice","onceOnlyChoice","bullets","optionalName","BracketedName","conditionExpr","ChoiceCondition","startTextAndLogic","MixedTextAndLogic","optionOnlyContent","EndTagIfNecessary","optionOnlyTextAndLogic","innerTextAndLogic","diverts","MultiDivert","emptyContent","divObj","div","conditions","ChoiceSingleCondition","ChoiceConditionsSpace","Newline","condExpr","DisallowIncrement","gatherDashCountObj","GatherDashes","gatherDashCount","ParseDashNotArrow","InnerConditionalContent","initialQueryExpression","ConditionExpression","alternatives","canBeInline","InlineConditionalBranches","MultilineConditionalBranches","soleContent","InnerBlock","elseBranch","SingleMultilineCondition","emptyTrueBranch","earlierBranchesHaveOwnExpression","isLast","alt","finalClause","trueBranch","MultilineWhitespace","multipleConditions","expr","ElseExpression","_nonTextPauseCharacters","_nonTextEndCharacters","_notTextEndCharactersChoice","_notTextEndCharactersString","TrimEndWhitespace","mixedTextAndLogicResults","terminateWithSpace","lastObjIdx","lastObj","LineOfMixedTextAndLogic","firstText","EndOfLine","SkipToNextLine","Spaced","ContentText","InlineLogicOrGlueOrStartTag","_results","ContentTextAllowingEscapeChar","ContentTextNoEscape","gotEscapeChar","endChars","parsingStringExpression","pureTextContent","ParseDivertArrow","ParseThreadArrow","threadDivert","arrowsAndDiverts","ParseDivertArrowOrTunnelOnwards","DivertIdentifierWithArguments","tunnelOnwards","tunnelOnwardDivert","gatherDivert","targetComponents","DotSeparatedDivertPathComponents","optionalArguments","ExpressionFunctionCallArguments","SingleDivert","numArrows","_binaryOperators","_maxBinaryOpLength","TempDeclarationOrAssignment","ParseTempKeyword","isIncrement","isDecrement","ReturnStatement","minimumPrecedence","ExpressionUnary","infixOp","ParseInfixOperator","expectationMessage","multiaryExpr","ExpressionInfixRight","_ret","ExpressionDivertTarget","prefixOp","ExpressionNot","ExpressionList","ExpressionParen","ExpressionFunctionCall","ExpressionVariableName","ExpressionLiteral","postfixOp","ExpressionFloat","ExpressionInt","ExpressionBool","ExpressionString","intOrNull","floatOrNull","textAndLogic","iden","commas","innerExpr","memberNames","ListMember","identifier2","RegisterExpressionOperators","RegisterBinaryOperator","infix","_openFilenames","IncludeStatement","fullFilename","FilenameIsAlreadyOpen","AddOpenFilename","includedString","RemoveOpenFilename","KnotDefinition","knotDecl","KnotDeclaration","KnotStitchNoContentRecoveryRule","KnotTitleEquals","knotName","isFunc","parameterNames","BracketedKnotDeclArguments","multiEquals","StitchDefinition","StitchDeclaration","flowArgs","flowArguments","FlowDeclArgument","firstIden","divertArrow","secondIden","funcIdentifier","argNames","_identifierCharSet","LogicLine","funCall","VariableDeclaration","ListElementDefinitionSeparator","ListDeclaration","AnyWhitespace","needsToCloseParen","elementValue","elementValueNum","ConstDeclaration","InlineLogic","StartTag","RuntimeGlue","wasParsingString","wasTagActive","tagActive","logic","InnerLogic","explicitSeqType","SequenceTypeAnnotation","contentLists","InnerSequenceObjects","rules","InnerSequence","InnerExpression","_rules","isNumberCharsOnly","_sequenceTypeSymbols","seqType","parsedSeqType","annotation","SequenceTypeSymbolAnnotation","SequenceTypeWordAnnotation","sequenceAnnotations","sequenceTypes","SequenceTypeSingleWord","combinedSequenceType","word","InnerMultilineSequenceObjects","InnerInlineSequenceObjects","interleavedContentAndPipes","justHadContent","contentOrPipe","SingleMultilineSequenceElement","_statementRulesAtLevel","_statementBreakRulesAtLevel","StatementAtLevel","StatementsBreakForLevel","rulesAtLevel","statement","breakRules","breakRuleResult","GenerateStatementLevelRules","levels","_i2","_levels","breakingRules","Line","inlineRule","_inlineWhitespaceChars","EndOfFile","newlines","anyWhitespace","MultiSpaced","_fileHandler","fullRootInkPath","ParsingString","TagActive","outputContentList","LatinBasic","LatinExtendedA","LatinExtendedB","Greek","Cyrillic","Armenian","Hebrew","Arabic","Korean","JsonFileHandler","fileHierarchy","Compiler","inkSource","options","_errors","_warnings","_authorMessages","_parsedStory","_runtimeStory","_parser","_debugSourceRanges","Compile","OnError","parser","errors","parsedStory","RetrieveDebugSourceForLatestContent","range","debugSourceRanges","DebugMetadataForContentAtOffset","offset","currOffset","lastValidMetadata","_inputString","_options"],"mappings":"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"}